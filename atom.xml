<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Farmer</title>
  <icon>https://blog.farmer233.top/favicon.png</icon>
  <subtitle>-Farmer的自习室</subtitle>
  <link href="https://blog.farmer233.top/atom.xml" rel="self"/>
  
  <link href="https://blog.farmer233.top/"/>
  <updated>2021-08-02T13:18:17.400Z</updated>
  <id>https://blog.farmer233.top/</id>
  
  <author>
    <name>-Farmer</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[Leetcode]数据库题目集的最后一天</title>
    <link href="https://blog.farmer233.top/2021/08/02/Leetcode-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%A2%98%E7%9B%AE%E9%9B%86%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E5%A4%A9/"/>
    <id>https://blog.farmer233.top/2021/08/02/Leetcode-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%A2%98%E7%9B%AE%E9%9B%86%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E5%A4%A9/</id>
    <published>2021-08-02T10:48:19.000Z</published>
    <updated>2021-08-02T13:18:17.400Z</updated>
    
    <content type="html"><![CDATA[<p>终于刷完了，芜湖！🛫🛫🛫<br>这套题目集总体难度不高，适合刚学的时候作为随堂练习。<br>题目代码我也同步到<code>GitHub</code>仓库了🎈：<a href="https://github.com/Farmer-chong/LearnProcess/tree/master/Leetcode/leetcode-dataStruct-1" target="_blank" rel="noopener">https://github.com/Farmer-chong/LearnProcess/tree/master/Leetcode/leetcode-dataStruct-1</a></p><a id="more"></a><h2 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h2><blockquote><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p></blockquote><p>假设一个二叉搜索树具有如下特征：</p><ul><li>节点的左子树只包含<strong>小于</strong>当前节点的数。</li><li>节点的右子树只包含<strong>大于</strong>当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p>示例 1:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">输入:</span></span><br><span class="line">    <span class="number">2</span></span><br><span class="line">   <span class="string">/</span> <span class="string">\</span></span><br><span class="line">  <span class="number">1</span>   <span class="number">3</span></span><br><span class="line"><span class="string">输出:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">    <span class="number">5</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">1</span>   <span class="number">4</span></span><br><span class="line">     / \</span><br><span class="line">    <span class="number">3</span>   <span class="number">6</span></span><br><span class="line">输出: <span class="literal">false</span></span><br><span class="line">解释: 输入为: [<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">3</span>,<span class="number">6</span>]。</span><br><span class="line">     根节点的值为 <span class="number">5</span> ，但是其右子节点值为 <span class="number">4</span> 。</span><br></pre></td></tr></table></figure><h3 id="解题思路-amp-题解"><a href="#解题思路-amp-题解" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>因为是一颗二叉搜索树，因此每个节点都满足左边小、右边大这个特性。<br>因此每次判断的时候记录<strong>最小值</strong>和<strong>最大值</strong>，然后判断即可。解题思路如下：</p><ol><li>由题目得知是整型，因此最大最小值分别为最小、最大的整型数值</li><li>当前节点值和最大最小值比较，错误则返回<code>F</code></li><li>将当前节点的值作为最大、最小值传入左右子树</li><li>返回左右子树的判断结果</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValidBST</span><span class="params">(root *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> validBST(root, math.MinInt64, math.MaxInt64)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">validBST</span><span class="params">(root *TreeNode, min, max <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> root.Val &lt;= min || root.Val &gt;= max &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> validBST(root.Left, min, root.Val) &amp;&amp; validBST(root.Right, root.Val, max)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="两数之和-IV-输入-BST"><a href="#两数之和-IV-输入-BST" class="headerlink" title="两数之和 IV - 输入 BST"></a>两数之和 IV - 输入 BST</h2><blockquote><p>给定一个二叉搜索树 root 和一个目标结果 k，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。</p></blockquote><p>示例 1：<br><img src="https://assets.leetcode.com/uploads/2020/09/21/sum_tree_1.jpg" alt=""></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="number">7</span>], k = <span class="number">9</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>示例 2：<br><img src="https://assets.leetcode.com/uploads/2020/09/21/sum_tree_2.jpg" alt=""></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="number">7</span>], k = <span class="number">28</span></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>], k = <span class="number">4</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>示例 4：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>], k = <span class="number">1</span></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>示例 5：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>], k = <span class="number">3</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>提示:</p><ul><li>二叉树的节点个数的范围是  <code>[1, 104]</code>.</li><li><code>-104 &lt;= Node.val &lt;= 104</code></li><li><code>root</code> 为二叉搜索树</li><li><code>-105 &lt;= k &lt;= 105</code></li></ul><h3 id="解题思路-amp-题解-1"><a href="#解题思路-amp-题解-1" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>这题的解题思路大致和<code>求两数和</code>差不多，只是将for循环换成了递归遍历，然后利用<code>hashMap</code>存储已遍历的内容。    </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findTarget</span><span class="params">(root *TreeNode, k <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">hashMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>, <span class="number">100</span>*<span class="number">100</span>)</span><br><span class="line"><span class="keyword">return</span> preOrder(root, hashMap, k)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preOrder</span><span class="params">(root *TreeNode, hashMap <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>, k <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> _, ok := hashMap[k-root.Val]; ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">hashMap[root.Val] = <span class="literal">true</span></span><br><span class="line"><span class="keyword">return</span> preOrder(root.Left, hashMap, k) || preOrder(root.Right, hashMap, k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a>二叉搜索树的最近公共祖先</h2><blockquote><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p></blockquote><blockquote><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p></blockquote><p>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png" alt=""></p><p>示例 1:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [<span class="number">6</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">3</span>,<span class="number">5</span>], p = <span class="number">2</span>, q = <span class="number">8</span></span><br><span class="line">输出: <span class="number">6</span> </span><br><span class="line">解释: 节点 <span class="number">2</span> 和节点 <span class="number">8</span> 的最近公共祖先是 <span class="number">6</span>。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [<span class="number">6</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">3</span>,<span class="number">5</span>], p = <span class="number">2</span>, q = <span class="number">4</span></span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">解释: 节点 <span class="number">2</span> 和节点 <span class="number">4</span> 的最近公共祖先是 <span class="number">2</span>, 因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure><p>说明:</p><ul><li>所有节点的值都是唯一的。</li><li><code>p、q</code> 为不同节点且均存在于给定的二叉搜索树中。</li></ul><h3 id="解题思路-amp-题解-2"><a href="#解题思路-amp-题解-2" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>解题思路：</p><ol><li>当前节点和<code>p、q</code>节点进行比较</li><li>如果是<code>p、q</code>节点、则返回该节点</li><li>获取左右子树的节点，当左右节点都存在，则证明当前节点为最近的<code>祖先节点</code></li><li>如果只有单一一个节点，则继续将该节点返回</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lowestCommonAncestor</span><span class="params">(root, p, q *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> root == p || root == q &#123;</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> leftNode, rightNode *TreeNode</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> p.Val &gt; q.Val &#123;</span><br><span class="line"><span class="comment">// 左 大于 右 则交换。保证左边小于右边（p &lt; q)</span></span><br><span class="line">p, q = q, p</span><br><span class="line">&#125;</span><br><span class="line">leftNode = lowestCommonAncestor(root.Left, p, q)</span><br><span class="line">rightNode = lowestCommonAncestor(root.Right, p, q)</span><br><span class="line"><span class="keyword">if</span> leftNode != <span class="literal">nil</span> &amp;&amp; rightNode != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> leftNode != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> leftNode</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> rightNode != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> rightNode</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;终于刷完了，芜湖！🛫🛫🛫&lt;br&gt;这套题目集总体难度不高，适合刚学的时候作为随堂练习。&lt;br&gt;题目代码我也同步到&lt;code&gt;GitHub&lt;/code&gt;仓库了🎈：&lt;a href=&quot;https://github.com/Farmer-chong/LearnProcess/tree/master/Leetcode/leetcode-dataStruct-1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/Farmer-chong/LearnProcess/tree/master/Leetcode/leetcode-dataStruct-1&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="学了些什么" scheme="https://blog.farmer233.top/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="笔记" scheme="https://blog.farmer233.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="刷题" scheme="https://blog.farmer233.top/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.farmer233.top/tags/leetcode/"/>
    
    <category term="算法和数据结构" scheme="https://blog.farmer233.top/tags/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="Golang" scheme="https://blog.farmer233.top/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>[Leetcode]二叉搜索树中的搜索&amp;插入</title>
    <link href="https://blog.farmer233.top/2021/08/02/Leetcode-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2-%E6%8F%92%E5%85%A5/"/>
    <id>https://blog.farmer233.top/2021/08/02/Leetcode-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2-%E6%8F%92%E5%85%A5/</id>
    <published>2021-08-02T10:35:07.000Z</published>
    <updated>2021-08-02T12:51:34.298Z</updated>
    
    <content type="html"><![CDATA[<p>第十三天了！快刷完了~！😊🛫<br>题目开始涉及二叉树、二叉堆等难一点的操作了，还有二叉树的调整。<br>做完感觉知识点掌握的更扎实了，果然温故而知新啊！</p><a id="more"></a><h2 id="二叉搜索树中的搜索"><a href="#二叉搜索树中的搜索" class="headerlink" title="二叉搜索树中的搜索"></a>二叉搜索树中的搜索</h2><blockquote><p>给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p></blockquote><p>例如，</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">给定二叉搜索树:</span><br><span class="line"></span><br><span class="line">        <span class="number">4</span></span><br><span class="line">       / \</span><br><span class="line">      <span class="number">2</span>   <span class="number">7</span></span><br><span class="line">     / \</span><br><span class="line">    <span class="number">1</span>   <span class="number">3</span></span><br><span class="line"></span><br><span class="line">和值: <span class="number">2</span></span><br><span class="line">你应该返回如下子树:</span><br><span class="line"></span><br><span class="line">      <span class="number">2</span>     </span><br><span class="line">     / \   </span><br><span class="line">    <span class="number">1</span>   <span class="number">3</span></span><br></pre></td></tr></table></figure><p>在上述示例中，如果要找的值是<code>5</code>，但因为没有节点值为 <code>5</code>，我们应该返回 <code>NULL</code>.</p><h3 id="解题思路-amp-题解"><a href="#解题思路-amp-题解" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>因为这是一颗搜索树，因此搜索功能实现起来特别简单，思路如下：</p><ol><li>判断当前节点的值，相同则返回</li><li>判断当前节点的值与目标的值，根据大小选择左子树还是右子树</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchBST</span><span class="params">(root *TreeNode, val <span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> || root.Val == val &#123;</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> root.Val &gt; val &#123;</span><br><span class="line"><span class="keyword">return</span> searchBST(root.Left, val)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> root.Val &lt; val &#123;</span><br><span class="line"><span class="keyword">return</span> searchBST(root.Right, val)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉搜索树中的插入操作"><a href="#二叉搜索树中的插入操作" class="headerlink" title="二叉搜索树中的插入操作"></a>二叉搜索树中的插入操作</h2><blockquote><p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。</p></blockquote><p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。</p><p>示例 1：<br><img src="https://assets.leetcode.com/uploads/2020/10/05/insertbst.jpg" alt=""></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>], val = <span class="number">5</span></span><br><span class="line">输出：[<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">解释：另一个满足题目要求可以通过的树是：</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2020/10/05/bst.jpg" alt=""></p><p>示例 2：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">40</span>,<span class="number">20</span>,<span class="number">60</span>,<span class="number">10</span>,<span class="number">30</span>,<span class="number">50</span>,<span class="number">70</span>], val = <span class="number">25</span></span><br><span class="line">输出：[<span class="number">40</span>,<span class="number">20</span>,<span class="number">60</span>,<span class="number">10</span>,<span class="number">30</span>,<span class="number">50</span>,<span class="number">70</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">25</span>]</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>], val = <span class="number">5</span></span><br><span class="line">输出：[<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>给定的树上的节点数介于 <code>0</code> 和 <code>10^4</code> 之间</li><li>每个节点都有一个唯一整数值，取值范围从 <code>0</code> 到 <code>10^8</code></li><li><code>-10^8 &lt;= val &lt;= 10^8</code></li><li>新值和原始二叉搜索树中的任意节点值都不同</li></ul><h3 id="解题思路-amp-题解-1"><a href="#解题思路-amp-题解-1" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>这题感觉有点漏洞，因为这题是往一颗<strong>搜索二叉树</strong>里面插入<strong>一个</strong>数据，因此不会造成二叉树层数超标。<br>故思路如下：</p><ol><li>用搜索的思路，查找出插入位置</li><li>往目标位置插入</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertIntoBST</span><span class="params">(root *TreeNode, val <span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;TreeNode&#123;Val: val&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> root.Val &lt; val &#123;</span><br><span class="line">root.Right = insertIntoBST(root.Right, val)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">root.Left = insertIntoBST(root.Left, val)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;第十三天了！快刷完了~！😊🛫&lt;br&gt;题目开始涉及二叉树、二叉堆等难一点的操作了，还有二叉树的调整。&lt;br&gt;做完感觉知识点掌握的更扎实了，果然温故而知新啊！&lt;/p&gt;</summary>
    
    
    
    <category term="学了些什么" scheme="https://blog.farmer233.top/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="笔记" scheme="https://blog.farmer233.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="刷题" scheme="https://blog.farmer233.top/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.farmer233.top/tags/leetcode/"/>
    
    <category term="算法和数据结构" scheme="https://blog.farmer233.top/tags/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="Golang" scheme="https://blog.farmer233.top/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>[Leetcode]翻转二叉树&amp;路径总和</title>
    <link href="https://blog.farmer233.top/2021/08/01/Leetcode-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/"/>
    <id>https://blog.farmer233.top/2021/08/01/Leetcode-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/</id>
    <published>2021-08-01T13:42:03.000Z</published>
    <updated>2021-08-02T10:37:27.418Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h2><blockquote><p>翻转一棵二叉树。</p></blockquote><p>示例：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">     <span class="number">4</span></span><br><span class="line">   /   \</span><br><span class="line">  <span class="number">2</span>     <span class="number">7</span></span><br><span class="line"> / \   / \</span><br><span class="line"><span class="number">1</span>   <span class="number">3</span> <span class="number">6</span>   <span class="number">9</span></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">     <span class="number">4</span></span><br><span class="line">   /   \</span><br><span class="line">  <span class="number">7</span>     <span class="number">2</span></span><br><span class="line"> / \   / \</span><br><span class="line"><span class="number">9</span>   <span class="number">6</span> <span class="number">3</span>   <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="解题思路-amp-题解"><a href="#解题思路-amp-题解" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>利用递归，将左子树和右子树交换。代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">invertTree</span><span class="params">(root *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">left := invertTree(root.Right)</span><br><span class="line">root.Right = invertTree(root.Left)</span><br><span class="line">root.Left = left</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a>路径总和</h2><blockquote><p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。<br>叶子节点 是指没有子节点的节点。</p></blockquote><p>示例 1：<br><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg" alt=""></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="literal">null</span>,<span class="number">13</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">1</span>], targetSum = <span class="number">22</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>示例 2：<br><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg" alt=""></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], targetSum = <span class="number">5</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>], targetSum = <span class="number">0</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点的数目在范围 <code>[0, 5000]</code> 内</li><li><code>-1000</code> &lt;= Node.val &lt;= <code>1000</code></li><li><code>-1000</code> &lt;= targetSum &lt;= <code>1000</code></li></ul><h3 id="解题思路-amp-题解-1"><a href="#解题思路-amp-题解-1" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>这题和之前的<code>求两数和</code>差不多思路，将已遍历的节点值放入<code>haspMap</code>中，并且每次访问节点的时候，计算当前节点和目标数相减后的值是否存在<code>hashMap</code>中。<br><strong>具体思路如下</strong></p><ol><li>读取当前节点的值</li><li>将<code>当前节点的值</code>放入<code>hashMap</code>中</li><li>判断 <code>targetSum - 当前节点的值</code> 是否在<code>hashMap</code>中</li><li>在则返回<code>true</code>,不在则继续遍历</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasPathSum</span><span class="params">(root *TreeNode, targetSum <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> root.Left == <span class="literal">nil</span> &amp;&amp; root.Right == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> targetSum == root.Val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> hasPathSum(root.Left, targetSum-root.Val) || hasPathSum(root.Right, targetSum-root.Val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h2 id=&quot;翻转二叉树&quot;&gt;&lt;a href=&quot;#翻转二叉树&quot; class=&quot;headerlink&quot; title=&quot;翻转二叉树&quot;&gt;&lt;/a&gt;翻转二叉树&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;翻转一棵二叉树。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
      
    
    
    
    <category term="学了些什么" scheme="https://blog.farmer233.top/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="笔记" scheme="https://blog.farmer233.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="刷题" scheme="https://blog.farmer233.top/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.farmer233.top/tags/leetcode/"/>
    
    <category term="算法和数据结构" scheme="https://blog.farmer233.top/tags/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="Golang" scheme="https://blog.farmer233.top/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>[Leetcode]第十一天-树的更多操作</title>
    <link href="https://blog.farmer233.top/2021/08/01/Leetcode-%E7%AC%AC%E5%8D%81%E4%B8%80%E5%A4%A9-%E6%A0%91%E7%9A%84%E6%9B%B4%E5%A4%9A%E6%93%8D%E4%BD%9C/"/>
    <id>https://blog.farmer233.top/2021/08/01/Leetcode-%E7%AC%AC%E5%8D%81%E4%B8%80%E5%A4%A9-%E6%A0%91%E7%9A%84%E6%9B%B4%E5%A4%9A%E6%93%8D%E4%BD%9C/</id>
    <published>2021-08-01T13:21:23.000Z</published>
    <updated>2021-08-01T13:52:14.928Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="二叉树的层序遍"><a href="#二叉树的层序遍" class="headerlink" title="二叉树的层序遍"></a>二叉树的层序遍</h2><h3 id="解题思路-amp-题解"><a href="#解题思路-amp-题解" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrder</span><span class="params">(root *TreeNode)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">ret := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line">q := []*TreeNode&#123;root&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; <span class="built_in">len</span>(q) &gt; <span class="number">0</span>; i++ &#123;</span><br><span class="line">ret = <span class="built_in">append</span>(ret, []<span class="keyword">int</span>&#123;&#125;)</span><br><span class="line">p := []*TreeNode&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(q); j++ &#123;</span><br><span class="line">node := q[j]</span><br><span class="line">ret[i] = <span class="built_in">append</span>(ret[i], node.Val)</span><br><span class="line"><span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">p = <span class="built_in">append</span>(p, node.Left)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">p = <span class="built_in">append</span>(p, node.Right)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">q = p</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Queue []*TreeNode</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span> <span class="title">Add</span><span class="params">(data *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">*q = <span class="built_in">append</span>(*q, data)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span> <span class="title">Remove</span><span class="params">()</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">node := (*q)[<span class="number">0</span>]</span><br><span class="line">*q = (*q)[<span class="number">1</span>:]</span><br><span class="line"><span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(*q) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h2><blockquote><p>给定一个二叉树，找出其最大深度。<br>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。<br>说明: 叶子节点是指没有子节点的节点。</p></blockquote><p>示例：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定二叉树 [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">15</span>,<span class="number">7</span>]，</span><br><span class="line">    <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">9</span>  <span class="number">20</span></span><br><span class="line">    /  \</span><br><span class="line">   <span class="number">15</span>   <span class="number">7</span></span><br><span class="line">返回它的最大深度 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><h3 id="解题思路-amp-题解-1"><a href="#解题思路-amp-题解-1" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>简单的通过递归，在返回的时候判断左子树深还是右子树深，然后返回比较深的那颗子树的值。<br>代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxDepth</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">leftDeep := maxDepth(root.Left) + <span class="number">1</span></span><br><span class="line">rightDeep := maxDepth(root.Right) + <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> leftDeep &gt;= rightDeep &#123;</span><br><span class="line"><span class="keyword">return</span> leftDeep</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> rightDeep</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h2><h3 id="解题思路-amp-题解-2"><a href="#解题思路-amp-题解-2" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>和判断深度差不多，也是分为左子树和右子树。通过交叉传入左右子树判断节点的值是否相等。<br>代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSymmetric</span><span class="params">(root *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> check(root, root)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(p, q *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> p == <span class="literal">nil</span> &amp;&amp; q == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> p == <span class="literal">nil</span> || q == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p.Val == q.Val &amp;&amp; check(p.Left, q.Right) &amp;&amp; check(p.Right, q.Left)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h2 id=&quot;二叉树的层序遍&quot;&gt;&lt;a href=&quot;#二叉树的层序遍&quot; class=&quot;headerlink&quot; title=&quot;二叉树的层序遍&quot;&gt;&lt;/a&gt;二叉树的层序遍&lt;/h2&gt;&lt;h3 id=&quot;解题思路-amp-题解&quot;&gt;&lt;a href=&quot;#解题思</summary>
      
    
    
    
    <category term="学了些什么" scheme="https://blog.farmer233.top/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="笔记" scheme="https://blog.farmer233.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="刷题" scheme="https://blog.farmer233.top/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.farmer233.top/tags/leetcode/"/>
    
    <category term="算法和数据结构" scheme="https://blog.farmer233.top/tags/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="Golang" scheme="https://blog.farmer233.top/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>[Leetcode]题目集第十天-树的开始</title>
    <link href="https://blog.farmer233.top/2021/07/31/Leetcode-%E9%A2%98%E7%9B%AE%E9%9B%86%E7%AC%AC%E5%8D%81%E5%A4%A9-%E6%A0%91%E7%9A%84%E5%BC%80%E5%A7%8B/"/>
    <id>https://blog.farmer233.top/2021/07/31/Leetcode-%E9%A2%98%E7%9B%AE%E9%9B%86%E7%AC%AC%E5%8D%81%E5%A4%A9-%E6%A0%91%E7%9A%84%E5%BC%80%E5%A7%8B/</id>
    <published>2021-07-31T13:15:34.000Z</published>
    <updated>2021-08-01T13:29:24.129Z</updated>
    
    <content type="html"><![CDATA[<p>树是一种重要的数据结构，终于开始刷树了😊<br>今天刷的是二叉树的三种基本变量–二叉树的前序遍历、二叉树的中序遍历和二叉树的后序遍历。三种遍历大同小异，只是输出元素的位置不一样，就不过多赘述了。</p><h2 id="三种遍历"><a href="#三种遍历" class="headerlink" title="三种遍历"></a>三种遍历</h2><p>代码和leetcode上的不太一样，但稍微改动一下就能提交了。代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> nodeType <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">value       nodeType</span><br><span class="line">left, right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BinaryTree proOrder function</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *TreeNode)</span> <span class="title">preOrder</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> t == <span class="literal">nil</span> || t.value == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(t.value)</span><br><span class="line">t.left.preOrder()</span><br><span class="line">t.right.preOrder()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// binaryTree inOrder function</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *TreeNode)</span> <span class="title">inOrder</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> t == <span class="literal">nil</span> || t.value == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">t.left.inOrder()</span><br><span class="line">fmt.Println(t.value)</span><br><span class="line">t.right.inOrder()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BinaryTree postOrder function</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *TreeNode)</span> <span class="title">postOrder</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> t == <span class="literal">nil</span> || t.value == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">t.left.postOrder()</span><br><span class="line">t.right.postOrder()</span><br><span class="line">fmt.Println(t.value)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newTree</span><span class="params">(inputList *[]nodeType)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(*inputList) == <span class="number">0</span> || inputList == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data := (*inputList)[<span class="number">0</span>]</span><br><span class="line">*inputList = (*inputList)[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> data == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node := &amp;TreeNode&#123;data, <span class="literal">nil</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">node.left = newTree(inputList)</span><br><span class="line">node.right = newTree(inputList)</span><br><span class="line"><span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">inputList := []nodeType&#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="number">10</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="number">8</span>, <span class="literal">nil</span>, <span class="number">4</span>&#125;</span><br><span class="line">root := newTree(&amp;inputList)</span><br><span class="line">fmt.Println(<span class="string">"res"</span>, root.left.right.value)</span><br><span class="line">fmt.Println(<span class="string">"前序遍历"</span>)</span><br><span class="line">root.preOrder()</span><br><span class="line">fmt.Println(<span class="string">"中序遍历"</span>)</span><br><span class="line">root.inOrder()</span><br><span class="line">fmt.Println(<span class="string">"后续遍历"</span>)</span><br><span class="line">root.postOrder()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;树是一种重要的数据结构，终于开始刷树了😊&lt;br&gt;今天刷的是二叉树的三种基本变量–二叉树的前序遍历、二叉树的中序遍历和二叉树的后序遍历。三种遍历大同小异，只是输出元素的位置不一样，就不过多赘述了。&lt;/p&gt;
&lt;h2 id=&quot;三种遍历&quot;&gt;&lt;a href=&quot;#三种遍历&quot; clas</summary>
      
    
    
    
    <category term="学了些什么" scheme="https://blog.farmer233.top/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="笔记" scheme="https://blog.farmer233.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="刷题" scheme="https://blog.farmer233.top/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.farmer233.top/tags/leetcode/"/>
    
    <category term="算法和数据结构" scheme="https://blog.farmer233.top/tags/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="Golang" scheme="https://blog.farmer233.top/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>[Leetcode]有效的括号&amp;用栈实现队列</title>
    <link href="https://blog.farmer233.top/2021/07/31/Leetcode-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>https://blog.farmer233.top/2021/07/31/Leetcode-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</id>
    <published>2021-07-30T17:11:02.000Z</published>
    <updated>2021-07-31T13:16:13.268Z</updated>
    
    <content type="html"><![CDATA[<h2 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h2><blockquote><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p></blockquote><p><strong>有效字符串需满足：</strong></p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ol><p>示例 1：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"()"</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"()[]&#123;&#125;"</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"(]"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>示例 4：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"([)]"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>示例 5：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"&#123;[]&#125;"</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="解题思路-amp-题解"><a href="#解题思路-amp-题解" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>这道题和课堂例题没啥区别没啥好讲的，直接上代码：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValid</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s)%<span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">pars := []<span class="keyword">rune</span>&#123;</span><br><span class="line"><span class="string">'('</span>: <span class="string">')'</span>,</span><br><span class="line"><span class="string">'&#123;'</span>: <span class="string">'&#125;'</span>,</span><br><span class="line"><span class="string">'['</span>: <span class="string">']'</span>,</span><br><span class="line">&#125;</span><br><span class="line">stack := []<span class="keyword">rune</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> _, c := <span class="keyword">range</span> s &#123;</span><br><span class="line"><span class="keyword">if</span> c == <span class="string">'('</span> || c == <span class="string">'&#123;'</span> || c == <span class="string">'['</span> &#123;</span><br><span class="line">stack = <span class="built_in">append</span>(stack, c)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">jugeCh := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">if</span> c != pars[jugeCh] &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(stack) != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h2><blockquote><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：</p></blockquote><p>实现 <code>MyQueue</code> 类：</p><ul><li>void push(int x) 将元素 x 推到队列的末尾</li><li>int pop() 从队列的开头移除并返回元素</li><li>int peek() 返回队列开头的元素</li><li>boolean empty() 如果队列为空，返回 true ；否则，返回 false</li></ul><p><strong>说明：</strong><br>你只能使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。<br>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</p><p><strong>进阶：</strong><br>你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。</p><p>示例：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">"MyQueue"</span>, <span class="string">"push"</span>, <span class="string">"push"</span>, <span class="string">"peek"</span>, <span class="string">"pop"</span>, <span class="string">"empty"</span>]</span><br><span class="line">[[], [<span class="number">1</span>], [<span class="number">2</span>], [], [], []]</span><br><span class="line">输出：</span><br><span class="line">[<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="keyword">false</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MyQueue myQueue = <span class="keyword">new</span> MyQueue();</span><br><span class="line">myQueue.<span class="keyword">push</span>(<span class="number">1</span>); <span class="comment">// queue is: [1]</span></span><br><span class="line">myQueue.<span class="keyword">push</span>(<span class="number">2</span>); <span class="comment">// queue is: [1, 2] (leftmost is front of the queue)</span></span><br><span class="line">myQueue.peek(); <span class="comment">// return 1</span></span><br><span class="line">myQueue.<span class="keyword">pop</span>(); <span class="comment">// return 1, queue is [2]</span></span><br><span class="line">myQueue.empty(); <span class="comment">// return false</span></span><br></pre></td></tr></table></figure><h3 id="解题思路-amp-题解-1"><a href="#解题思路-amp-题解-1" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>这里利用了两个栈，一个栈处理输入另一个处理输出（in和out）。<br>利用栈的特性，当<strong>输出栈</strong>为空时将<strong>输入栈</strong>的内容<code>pop</code>到<strong>输出栈</strong>, 这样<strong>输出</strong>栈的顺序就是队列的顺序了！<br>代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyQueue <span class="keyword">struct</span> &#123;</span><br><span class="line">in, out []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">MyQueue</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> MyQueue&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyQueue)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">this.in = <span class="built_in">append</span>(this.in, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyQueue)</span> <span class="title">in2out</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(this.in) &gt; <span class="number">0</span> &#123;</span><br><span class="line">this.out = <span class="built_in">append</span>(this.out, this.in[<span class="built_in">len</span>(this.in)<span class="number">-1</span>])</span><br><span class="line">this.in = this.in[:<span class="built_in">len</span>(this.in)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyQueue)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(this.out) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 将输入栈 弹出到输出栈中</span></span><br><span class="line">this.in2out()</span><br><span class="line">&#125;</span><br><span class="line">out := this.out[<span class="built_in">len</span>(this.out)<span class="number">-1</span>]</span><br><span class="line">this.out = this.out[:<span class="built_in">len</span>(this.out)<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Get the front element. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyQueue)</span> <span class="title">Peek</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(this.out) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 将输入栈 弹出到输出栈中</span></span><br><span class="line">this.in2out()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> this.out[<span class="built_in">len</span>(this.out)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyQueue)</span> <span class="title">Empty</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(this.in) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(this.out) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * obj.Push(x);</span></span><br><span class="line"><span class="comment"> * param_2 := obj.Pop();</span></span><br><span class="line"><span class="comment"> * param_3 := obj.Peek();</span></span><br><span class="line"><span class="comment"> * param_4 := obj.Empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;有效的括号&quot;&gt;&lt;a href=&quot;#有效的括号&quot; class=&quot;headerlink&quot; title=&quot;有效的括号&quot;&gt;&lt;/a&gt;有效的括号&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串</summary>
      
    
    
    
    <category term="学了些什么" scheme="https://blog.farmer233.top/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="笔记" scheme="https://blog.farmer233.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="刷题" scheme="https://blog.farmer233.top/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.farmer233.top/tags/leetcode/"/>
    
    <category term="算法和数据结构" scheme="https://blog.farmer233.top/tags/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="Golang" scheme="https://blog.farmer233.top/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>[Leetcode]反转链表&amp;删除排序链表中的重复元素</title>
    <link href="https://blog.farmer233.top/2021/07/23/Leetcode-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
    <id>https://blog.farmer233.top/2021/07/23/Leetcode-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</id>
    <published>2021-07-22T16:30:03.000Z</published>
    <updated>2021-07-29T17:01:46.716Z</updated>
    
    <content type="html"><![CDATA[<p>第八天题目，涉及的都是些基本的链表操作~不算太难😀<br>去旅游玩几天👻🕊🕊🕊</p><a id="more"></a><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><blockquote><p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p></blockquote><p>示例 1：<br><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt=""></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：[<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>示例 2：<br><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" alt=""></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="comment">[]</span></span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></table></figure><h3 id="解题思路-amp-题解"><a href="#解题思路-amp-题解" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>这题第一时间想到了递归，当操作流程在<strong>递归</strong>触底前则表示正向递归，触底后计算则表示反向递归。<br>这里利用了<strong>反向递归</strong>（触底后操作），得到一个链表尾开头的链表和当前节点，然后将这条链添加当前元素。<br>此时，node节点表示反转后的链表。<br>代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br><span class="line">node := reverseList(head.Next)</span><br><span class="line">head.Next.Next = head</span><br><span class="line">head.Next = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除排序链表中的重复元素"><a href="#删除排序链表中的重复元素" class="headerlink" title="删除排序链表中的重复元素"></a>删除排序链表中的重复元素</h2><blockquote><p>存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除所有重复的元素，使每个元素 只出现一次 。<br>返回同样按升序排列的结果链表。</p></blockquote><p>示例 1：<br><img src="https://assets.leetcode.com/uploads/2021/01/04/list1.jpg" alt=""></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>示例 2：<br><img src="https://assets.leetcode.com/uploads/2021/01/04/list2.jpg" alt=""></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><h3 id="解题思路-amp-题解-1"><a href="#解题思路-amp-题解-1" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>这题有个大前提<code>按升序排列的链表</code>, 这个链表是排好序的。通过判断当前节点和下一个节点的值是否想等，相等就删除下一个节点。<br>代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteDuplicates</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">node := head</span><br><span class="line"><span class="keyword">for</span> node.Next != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> node.Val == node.Next.Val &#123;</span><br><span class="line">node.Next = node.Next.Next</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">node = node.Next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;第八天题目，涉及的都是些基本的链表操作~不算太难😀&lt;br&gt;去旅游玩几天👻🕊🕊🕊&lt;/p&gt;</summary>
    
    
    
    <category term="学了些什么" scheme="https://blog.farmer233.top/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="笔记" scheme="https://blog.farmer233.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="刷题" scheme="https://blog.farmer233.top/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.farmer233.top/tags/leetcode/"/>
    
    <category term="算法和数据结构" scheme="https://blog.farmer233.top/tags/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="Golang" scheme="https://blog.farmer233.top/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>[Leetcode]数据结构题目集第七天-链表</title>
    <link href="https://blog.farmer233.top/2021/07/22/Leetcode-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E7%9B%AE%E9%9B%86%E7%AC%AC%E4%B8%83%E5%A4%A9-%E9%93%BE%E8%A1%A8/"/>
    <id>https://blog.farmer233.top/2021/07/22/Leetcode-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E7%9B%AE%E9%9B%86%E7%AC%AC%E4%B8%83%E5%A4%A9-%E9%93%BE%E8%A1%A8/</id>
    <published>2021-07-21T17:04:04.000Z</published>
    <updated>2021-07-22T16:30:27.652Z</updated>
    
    <content type="html"><![CDATA[<p>这次题目有三题，分别是<code>环形链表</code>、<code>合并两个有序链表</code>和<code>移除链表元素</code>.<br>其中<code>环形链表</code>比较值得一看，解法有三种，感觉第一种有点骚✨</p><a id="more"></a><h2 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h2><blockquote><p>给定一个链表，判断链表中是否有环。<br>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：pos 不作为参数进行传递，</strong>仅仅是为了标识链表的实际情况。<br>如果链表中存在环，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p></blockquote><p><strong>进阶：</strong><br>你能用 O(1)（即，常量）内存解决此问题吗？</p><p>示例 1：<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt=""></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">-4</span>], pos = <span class="number">1</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p>示例 2：<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt=""></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>], pos = <span class="number">0</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p>示例 3：<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt=""></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>], pos = <span class="number">-1</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围是 [0, 104]</li><li>-105 &lt;= Node.val &lt;= 105</li><li>pos 为 -1 或者链表中的一个 有效索引 。</li></ul><h3 id="解题思路-amp-题解"><a href="#解题思路-amp-题解" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>这题有好几个方法解决，如下：</p><ol><li>利用一个特殊的值覆盖已遍历的元素，当再次遇到该值时表示有回环</li><li>利用哈希表存储记录节点地址</li><li>快慢指针法（传统法） </li></ol><h4 id="特殊值法"><a href="#特殊值法" class="headerlink" title="特殊值法"></a>特殊值法</h4><p>这个方法感觉有点奇葩，特殊值要测试点中不存在才可以😄</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasCycle</span><span class="params">(head *ListNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> head.Val == <span class="number">114514</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head.Val = <span class="number">114514</span></span><br><span class="line">        &#125;</span><br><span class="line">        head = head.Next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="哈希表存储节点"><a href="#哈希表存储节点" class="headerlink" title="哈希表存储节点"></a>哈希表存储节点</h4><p>这个方法只需要将链表遍历一次，但需要耗费更大的内存空间。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasCycle</span><span class="params">(head *ListNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">nodeMap := <span class="keyword">map</span>[ListNode]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">node := head</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">nodeMap[*node]++</span><br><span class="line"><span class="keyword">if</span> nodeMap[*node] &gt; <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">node = node.Next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="快慢指针法"><a href="#快慢指针法" class="headerlink" title="快慢指针法"></a>快慢指针法</h4><p>这个是传统的方法，但有可能需要遍历几次闭环，等慢指针追上快指针。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasCycle</span><span class="params">(head *ListNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    slow, fast := head, head.Next</span><br><span class="line">    <span class="keyword">for</span> fast != slow &#123;</span><br><span class="line">        <span class="keyword">if</span> fast == <span class="literal">nil</span> || fast.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow.Next</span><br><span class="line">        fast = fast.Next.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h2><blockquote><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p></blockquote><p>示例 1：<br><img src="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg" alt=""></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>], l2 = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = <span class="comment">[]</span>, l2 = <span class="comment">[]</span></span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = <span class="comment">[]</span>, l2 = <span class="comment">[0]</span></span><br><span class="line">输出：<span class="comment">[0]</span></span><br></pre></td></tr></table></figure><h3 id="解题思路-amp-题解-1"><a href="#解题思路-amp-题解-1" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p><strong>需要注意</strong>这题有一个大前提，题目给的两个链表都是<strong>升序</strong>的，因此这题类似前面的<code>合并两个有序数组</code>有点类似。</p><ol><li>通过比较头节点，小的添加到新链</li><li>遍历完其中一条链后，将另一条链直接拼接在后面<br>代码如下：<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTwoLists</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">res := &amp;ListNode&#123;&#125;</span><br><span class="line">node := res</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> l1 == <span class="literal">nil</span> &#123;</span><br><span class="line">node.Next = l2</span><br><span class="line"><span class="keyword">return</span> res.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> l2 == <span class="literal">nil</span> &#123;</span><br><span class="line">node.Next = l1</span><br><span class="line"><span class="keyword">return</span> res.Next</span><br><span class="line">&#125;</span><br><span class="line">tmp := &amp;ListNode&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> l1.Val &lt;= l2.Val &#123;</span><br><span class="line">tmp.Val = l1.Val</span><br><span class="line">l1 = l1.Next</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">tmp.Val = l2.Val</span><br><span class="line">l2 = l2.Next</span><br><span class="line">&#125;</span><br><span class="line">node.Next = tmp</span><br><span class="line">node = node.Next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="移除链表元素"><a href="#移除链表元素" class="headerlink" title="移除链表元素"></a>移除链表元素</h2><blockquote><p>给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。</p></blockquote><p>示例 1：<br><img src="https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg" alt=""></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], val = <span class="number">6</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="comment">[]</span>, val = 1</span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>], val = <span class="number">7</span></span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><h3 id="解题思路-amp-题解-2"><a href="#解题思路-amp-题解-2" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>这题就是基本的删除链表元素，直接上代码：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeElements</span><span class="params">(head *ListNode, val <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">root := &amp;ListNode&#123;Next: head&#125;</span><br><span class="line">node := root</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> node.Next != <span class="literal">nil</span> &amp;&amp; node.Next.Val == val &#123;</span><br><span class="line">node.Next = node.Next.Next</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">node = node.Next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;这次题目有三题，分别是&lt;code&gt;环形链表&lt;/code&gt;、&lt;code&gt;合并两个有序链表&lt;/code&gt;和&lt;code&gt;移除链表元素&lt;/code&gt;.&lt;br&gt;其中&lt;code&gt;环形链表&lt;/code&gt;比较值得一看，解法有三种，感觉第一种有点骚✨&lt;/p&gt;</summary>
    
    
    
    <category term="学了些什么" scheme="https://blog.farmer233.top/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="笔记" scheme="https://blog.farmer233.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="刷题" scheme="https://blog.farmer233.top/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.farmer233.top/tags/leetcode/"/>
    
    <category term="算法和数据结构" scheme="https://blog.farmer233.top/tags/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="Golang" scheme="https://blog.farmer233.top/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>[Leetcode]数据结构题目集第六天</title>
    <link href="https://blog.farmer233.top/2021/07/21/Leetcode-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E7%9B%AE%E9%9B%86%E7%AC%AC%E5%85%AD%E5%A4%A9/"/>
    <id>https://blog.farmer233.top/2021/07/21/Leetcode-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E7%9B%AE%E9%9B%86%E7%AC%AC%E5%85%AD%E5%A4%A9/</id>
    <published>2021-07-21T15:56:16.000Z</published>
    <updated>2021-07-21T16:57:44.546Z</updated>
    
    <content type="html"><![CDATA[<p>这次题目有三题，分别是<code>字符串中的第一个唯一字符</code>、<code>赎金信</code>和<code>有效的字母异位词</code>.<br>今天三道题目的思路都差不多，感觉都是<code>两个数组的交集 II</code>的变形,内容篇幅可能比较长，目录可以快速定位到对应题目的解题思路&amp;题解.  </p><h2 id="字符串中的第一个唯一字符"><a href="#字符串中的第一个唯一字符" class="headerlink" title="字符串中的第一个唯一字符"></a>字符串中的第一个唯一字符</h2><blockquote><p>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</p></blockquote><p>示例：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">s</span> = <span class="string">"leetcode"</span></span><br><span class="line">返回 <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">s</span> = <span class="string">"loveleetcode"</span></span><br><span class="line">返回 <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="解题思路-amp-题解"><a href="#解题思路-amp-题解" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>拿到题目的第一反应是和之前<code>两个数组的交集 II</code>一样的思路。<br>通过哈希表记录元素出现的下标，然后扫码字符串找出出现的次数为1的元素，然后返回该元素的下标。<br>大致思路: </p><ol><li>数组0-25表示’a’ -&gt; ‘z’</li><li>哈希表使用一个26长度的数组表示</li><li>数组内容表示元素出现次数</li></ol><p>代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">firstUniqChar</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">items := [<span class="number">26</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">items[s[i]-<span class="string">'a'</span>]++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> items[s[i]-<span class="string">'a'</span>] == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="赎金信"><a href="#赎金信" class="headerlink" title="赎金信"></a>赎金信</h2><blockquote><p>给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。</p></blockquote><p>(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)</p><p>示例 1：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">ransomNote</span> = <span class="string">"a"</span>, <span class="attr">magazine</span> = <span class="string">"b"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">ransomNote</span> = <span class="string">"aa"</span>, <span class="attr">magazine</span> = <span class="string">"ab"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">ransomNote</span> = <span class="string">"aa"</span>, <span class="attr">magazine</span> = <span class="string">"aab"</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="解题思路-amp-题解-1"><a href="#解题思路-amp-题解-1" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>这题与上一题差不多，思路上甚至更像<code>两个数组的交集 II</code>，也是通过一个数组哈希表存储字符出现的次数。<br>第二次遍历的时候将数组内容减一，当内容为0时表示内容不够则返回<code>false</code></p><p>代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canConstruct</span><span class="params">(ransomNote <span class="keyword">string</span>, magazine <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">conMap := [<span class="number">26</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(magazine); i++ &#123;</span><br><span class="line">conMap[magazine[i]-<span class="string">'a'</span>]++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(ransomNote); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> conMap[ransomNote[i]-<span class="string">'a'</span>] == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">conMap[ransomNote[i]-<span class="string">'a'</span>]--</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有效的字母异位词"><a href="#有效的字母异位词" class="headerlink" title="有效的字母异位词"></a>有效的字母异位词</h2><blockquote><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。<br><strong>注意：若 <code>s</code> 和 <code>t</code> 中每个字符出现的次数都相同，则称 <code>s</code> 和 <code>t</code> 互为字母异位词。</strong></p></blockquote><p>示例 1:</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="attr">s</span> = <span class="string">"anagram"</span>, <span class="attr">t</span> = <span class="string">"nagaram"</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="attr">s</span> = <span class="string">"rat"</span>, <span class="attr">t</span> = <span class="string">"car"</span></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="解题思路-amp-题解-2"><a href="#解题思路-amp-题解-2" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>这题应该就是<code>两个数组的交集 II</code>的变形了，今天这三题整体上思路都没啥区别，不过多赘述了。    </p><p>代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isAnagram</span><span class="params">(s <span class="keyword">string</span>, t <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">res := [<span class="number">26</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">res[s[i]-<span class="string">'a'</span>]++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(t); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> res[t[i]-<span class="string">'a'</span>] == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">res[t[i]-<span class="string">'a'</span>]--</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> res &#123;</span><br><span class="line"><span class="keyword">if</span> v != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这次题目有三题，分别是&lt;code&gt;字符串中的第一个唯一字符&lt;/code&gt;、&lt;code&gt;赎金信&lt;/code&gt;和&lt;code&gt;有效的字母异位词&lt;/code&gt;.&lt;br&gt;今天三道题目的思路都差不多，感觉都是&lt;code&gt;两个数组的交集 II&lt;/code&gt;的变形,内容篇幅可能比较长，目录</summary>
      
    
    
    
    <category term="学了些什么" scheme="https://blog.farmer233.top/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="笔记" scheme="https://blog.farmer233.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="刷题" scheme="https://blog.farmer233.top/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.farmer233.top/tags/leetcode/"/>
    
    <category term="算法和数据结构" scheme="https://blog.farmer233.top/tags/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="Golang" scheme="https://blog.farmer233.top/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>[Leetcode]有效的数独&amp;矩阵置零</title>
    <link href="https://blog.farmer233.top/2021/07/20/Leetcode-%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC-%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6/"/>
    <id>https://blog.farmer233.top/2021/07/20/Leetcode-%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC-%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6/</id>
    <published>2021-07-20T14:34:22.000Z</published>
    <updated>2021-07-20T14:53:58.707Z</updated>
    
    <content type="html"><![CDATA[<p>Leetcode数据结构题目集第五天，<code>有效的数独</code>和<code>矩阵置零</code>.<br>其中<code>矩阵置零</code>比较有趣放在前面，<code>有效的数独</code>只是代码量比较长，逻辑部分并不难。  </p><a id="more"></a><h2 id="矩阵置零"><a href="#矩阵置零" class="headerlink" title="矩阵置零"></a>矩阵置零</h2><blockquote><p>给定一个 <code>m x n</code> 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用<code>原地</code>算法。</p></blockquote><p>进阶：</p><ul><li>一个直观的解决方案是使用  O(mn) 的额外空间，但这并不是一个好的解决方案。</li><li>一个简单的改进方案是使用 O(m + n) 的额外空间，但这仍然不是最好的解决方案。<br>你能想出一个仅使用常量空间的解决方案吗？</li></ul><p>示例 1：<br><img src="https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg" alt=""></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]]</span><br></pre></td></tr></table></figure><p>示例 2：<br><img src="https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg" alt=""></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>]]</span><br><span class="line">输出：[[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>]]</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>m == matrix.length</li><li>n == matrix[0].length</li><li>1 &lt;= m, n &lt;= 200</li><li>-231 &lt;= matrix[i][j] &lt;= 231 - 1</li></ul><h3 id="解题思路-amp-题解"><a href="#解题思路-amp-题解" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p><strong>通过观察发现置零是将<code>0</code>的行号和列号记录下来，然后将记录下来的行列置零即可</strong><br>具体思路如下：</p><ul><li>当同一行有一个0时，则该行后面遇到0值时也无需关系这一行的变化-&gt;因为一行里面有一个0，整行都是0（列同理）</li><li>在同一行有两个0时需要注意，这意味着有两列也需要置零。</li></ul><p>代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setZeroes</span><span class="params">(matrix [][]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">row, col := []<span class="keyword">int</span>&#123;&#125;, []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> r := <span class="number">0</span>; r &lt; <span class="built_in">len</span>(matrix); r++ &#123;</span><br><span class="line"><span class="keyword">for</span> c := <span class="number">0</span>; c &lt; <span class="built_in">len</span>(matrix[r]); c++ &#123;</span><br><span class="line"><span class="keyword">if</span> matrix[r][c] == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 记录</span></span><br><span class="line">row = <span class="built_in">append</span>(row, r)</span><br><span class="line">col = <span class="built_in">append</span>(col, c)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> _, item := <span class="keyword">range</span> row &#123;</span><br><span class="line"><span class="keyword">for</span> index := <span class="keyword">range</span> matrix[item] &#123;</span><br><span class="line">matrix[item][index] = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, item := <span class="keyword">range</span> col &#123;</span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> matrix &#123;</span><br><span class="line">value[item] = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有效的数独"><a href="#有效的数独" class="headerlink" title="有效的数独"></a>有效的数独</h2><blockquote><p>请你判断一个 9x9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。<br>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）<br>数独部分空格内已填入了数字，空白格用 ‘.’ 表示。</p></blockquote><p><strong>注意：</strong></p><ul><li>一个有效的数独（部分已被填充）不一定是可解的。</li><li>只需要根据以上规则，验证已经填入的数字是否有效即可。</li></ul><p>示例 1：<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714svg.png" alt=""></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：board = </span><br><span class="line">[[<span class="string">"5"</span>,<span class="string">"3"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"7"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>]</span><br><span class="line">,[<span class="string">"6"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"1"</span>,<span class="string">"9"</span>,<span class="string">"5"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>]</span><br><span class="line">,[<span class="string">"."</span>,<span class="string">"9"</span>,<span class="string">"8"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"6"</span>,<span class="string">"."</span>]</span><br><span class="line">,[<span class="string">"8"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"6"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"3"</span>]</span><br><span class="line">,[<span class="string">"4"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"8"</span>,<span class="string">"."</span>,<span class="string">"3"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"1"</span>]</span><br><span class="line">,[<span class="string">"7"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"2"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"6"</span>]</span><br><span class="line">,[<span class="string">"."</span>,<span class="string">"6"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"2"</span>,<span class="string">"8"</span>,<span class="string">"."</span>]</span><br><span class="line">,[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"4"</span>,<span class="string">"1"</span>,<span class="string">"9"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"5"</span>]</span><br><span class="line">,[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"8"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"7"</span>,<span class="string">"9"</span>]]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：board = </span><br><span class="line">[[<span class="string">"8"</span>,<span class="string">"3"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"7"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>]</span><br><span class="line">,[<span class="string">"6"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"1"</span>,<span class="string">"9"</span>,<span class="string">"5"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>]</span><br><span class="line">,[<span class="string">"."</span>,<span class="string">"9"</span>,<span class="string">"8"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"6"</span>,<span class="string">"."</span>]</span><br><span class="line">,[<span class="string">"8"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"6"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"3"</span>]</span><br><span class="line">,[<span class="string">"4"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"8"</span>,<span class="string">"."</span>,<span class="string">"3"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"1"</span>]</span><br><span class="line">,[<span class="string">"7"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"2"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"6"</span>]</span><br><span class="line">,[<span class="string">"."</span>,<span class="string">"6"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"2"</span>,<span class="string">"8"</span>,<span class="string">"."</span>]</span><br><span class="line">,[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"4"</span>,<span class="string">"1"</span>,<span class="string">"9"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"5"</span>]</span><br><span class="line">,[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"8"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"7"</span>,<span class="string">"9"</span>]]</span><br><span class="line">输出：false</span><br><span class="line">解释：除了第一行的第一个数字从 <span class="number">5</span> 改为 <span class="number">8</span> 以外，空格内其他数字均与 示例<span class="number">1</span> 相同。 但由于位于左上角的 <span class="number">3</span>x3 宫内有两个 <span class="number">8</span> 存在, 因此这个数独是无效的。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>board.length == 9</li><li>board[i].length == 9</li><li>board[i][j] 是一位数字或者 ‘.’</li></ul><h3 id="解题思路-amp-题解-1"><a href="#解题思路-amp-题解-1" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>题目<del>没什么难度</del>，唯一需要注意的是：判断子矩阵的时候，是根据<code>当前坐标/矩阵大小</code>来决定的。<br>代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValidSudoku</span><span class="params">(board [][]<span class="keyword">byte</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">rowBuf := <span class="built_in">make</span>([][<span class="number">9</span>]<span class="keyword">bool</span>, <span class="number">9</span>)</span><br><span class="line">colBuf := <span class="built_in">make</span>([][<span class="number">9</span>]<span class="keyword">bool</span>, <span class="number">9</span>)</span><br><span class="line">boxBuf := <span class="built_in">make</span>([][<span class="number">9</span>]<span class="keyword">bool</span>, <span class="number">9</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> row:=<span class="number">0</span>; row&lt;<span class="number">9</span>; row++ &#123;</span><br><span class="line"><span class="keyword">for</span> col:=<span class="number">0</span>; col&lt;<span class="number">9</span>; col++ &#123;</span><br><span class="line"><span class="keyword">if</span> board[row][col] == <span class="string">'.'</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val := board[row][col] - <span class="string">'1'</span></span><br><span class="line"><span class="keyword">if</span> rowBuf[row][val] || colBuf[col][val] || boxBuf[row/<span class="number">3</span>*<span class="number">3</span>+col/<span class="number">3</span>][val] &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rowBuf[row][val] = <span class="literal">true</span></span><br><span class="line">colBuf[col][val] = <span class="literal">true</span></span><br><span class="line">boxBuf[row/<span class="number">3</span>*<span class="number">3</span>+col/<span class="number">3</span>][val] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">validDigit</span><span class="params">(digit <span class="keyword">byte</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> digit &gt;= <span class="string">'1'</span> &amp;&amp; digit &lt;= <span class="string">'9'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inRow</span><span class="params">(rows []<span class="keyword">byte</span>, col <span class="keyword">int</span>, digit <span class="keyword">byte</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> c := <span class="number">0</span>; c &lt; <span class="number">9</span>; c++ &#123;</span><br><span class="line"><span class="keyword">if</span> rows[c] == digit &amp;&amp; c != col &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inColumn</span><span class="params">(g [][]<span class="keyword">byte</span>, column, row <span class="keyword">int</span>, digit <span class="keyword">byte</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> r := <span class="number">0</span>; r &lt; <span class="number">9</span>; r++ &#123;</span><br><span class="line"><span class="keyword">if</span> g[r][column] == digit &amp;&amp; r != row &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inRegion</span><span class="params">(g [][]<span class="keyword">byte</span>, row, column <span class="keyword">int</span>, digit <span class="keyword">byte</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">startRow, startColumn := row/<span class="number">3</span>*<span class="number">3</span>, column/<span class="number">3</span>*<span class="number">3</span></span><br><span class="line"><span class="keyword">for</span> r := startRow; r &lt; startRow+<span class="number">3</span>; r++ &#123;</span><br><span class="line"><span class="keyword">for</span> c := startColumn; c &lt; startColumn+<span class="number">3</span>; c++ &#123;</span><br><span class="line"><span class="keyword">if</span> g[r][c] == digit &amp;&amp; r != row &amp;&amp; c != column &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Leetcode数据结构题目集第五天，&lt;code&gt;有效的数独&lt;/code&gt;和&lt;code&gt;矩阵置零&lt;/code&gt;.&lt;br&gt;其中&lt;code&gt;矩阵置零&lt;/code&gt;比较有趣放在前面，&lt;code&gt;有效的数独&lt;/code&gt;只是代码量比较长，逻辑部分并不难。  &lt;/p&gt;</summary>
    
    
    
    <category term="学了些什么" scheme="https://blog.farmer233.top/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="笔记" scheme="https://blog.farmer233.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="刷题" scheme="https://blog.farmer233.top/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.farmer233.top/tags/leetcode/"/>
    
    <category term="算法和数据结构" scheme="https://blog.farmer233.top/tags/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="Golang" scheme="https://blog.farmer233.top/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>[Leetcode]重塑矩阵&amp;杨辉三角</title>
    <link href="https://blog.farmer233.top/2021/07/19/Leetcode-%E9%87%8D%E5%A1%91%E7%9F%A9%E9%98%B5-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/"/>
    <id>https://blog.farmer233.top/2021/07/19/Leetcode-%E9%87%8D%E5%A1%91%E7%9F%A9%E9%98%B5-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/</id>
    <published>2021-07-19T11:49:09.000Z</published>
    <updated>2021-07-19T16:21:37.606Z</updated>
    
    <content type="html"><![CDATA[<p>Leetcode数据结构题目集第四天，<code>重塑矩阵</code>和<code>杨辉三角</code>.</p><h2 id="重塑矩阵"><a href="#重塑矩阵" class="headerlink" title="重塑矩阵"></a>重塑矩阵</h2><blockquote><p>在MATLAB中，有一个非常有用的函数 reshape，它可以将一个矩阵重塑为另一个大小不同的新矩阵，但保留其原始数据。<br>给出一个由二维数组表示的矩阵，以及两个正整数r和c，分别表示想要的重构的矩阵的行数和列数。<br>重构后的矩阵需要将原始矩阵的所有元素以相同的行遍历顺序填充。<br>如果具有给定参数的reshape操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。</p></blockquote><p>示例 1:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">nums = </span><br><span class="line">[[<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line"> [<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">r = <span class="number">1</span>, c = <span class="number">4</span></span><br><span class="line">输出: </span><br><span class="line">[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">解释:</span><br><span class="line">行遍历nums的结果是 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]。新的矩阵是 <span class="number">1</span> * <span class="number">4</span> 矩阵, 用之前的元素值一行一行填充新矩阵。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">nums = </span><br><span class="line">[[<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line"> [<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">r = <span class="number">2</span>, c = <span class="number">4</span></span><br><span class="line">输出: </span><br><span class="line">[[<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line"> [<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">解释:</span><br><span class="line">没有办法将 <span class="number">2</span> * <span class="number">2</span> 矩阵转化为 <span class="number">2</span> * <span class="number">4</span> 矩阵。 所以输出原矩阵。</span><br></pre></td></tr></table></figure><p>注意：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给定矩阵的宽和高范围在 [<span class="number">1</span>, <span class="number">100</span>]。</span><br><span class="line">给定的 r 和 c 都是正数。</span><br></pre></td></tr></table></figure><h3 id="解题思路-amp-题解"><a href="#解题思路-amp-题解" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>解题思路大体就是先转成一维矩阵，然后再转成目标矩阵。核心思想是下面的公式:</p><ol><li>(i, j) -&gt; i * n + j =&gt; x</li><li>i=x / n</li><li>j=x % n</li></ol><p>代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">matrixReshape</span><span class="params">(mat [][]<span class="keyword">int</span>, r <span class="keyword">int</span>, c <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">m, n := <span class="built_in">len</span>(mat), <span class="built_in">len</span>(mat[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">if</span> m*n != r*c &#123;</span><br><span class="line"><span class="keyword">return</span> mat</span><br><span class="line">&#125;</span><br><span class="line">res := <span class="built_in">make</span>([][]<span class="keyword">int</span>, r)</span><br><span class="line"><span class="keyword">for</span> r := <span class="keyword">range</span> res &#123;</span><br><span class="line">res[r] = <span class="built_in">make</span>([]<span class="keyword">int</span>, c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m*n; i++ &#123;</span><br><span class="line">res[i/c][i%c] = mat[i/n][i%n]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="杨辉三角"><a href="#杨辉三角" class="headerlink" title="杨辉三角"></a>杨辉三角</h2><blockquote><p>给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。<br>在杨辉三角中，每个数是它左上方和右上方的数的和。</p></blockquote><p>示例:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">5</span></span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">     [<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">   [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line"> [<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="解题思路-amp-题解-1"><a href="#解题思路-amp-题解-1" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>杨辉三角这算是一道经典题目了，大一就开始接触。这里主要用到这个特性-&gt;<code>每行长度等于当前列数 -&gt; 第一行只有一个，第二行有两个，第三行有三个。</code></p><p>代码如下: </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generate</span><span class="params">(numRows <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">res := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numRows; i++ &#123;</span><br><span class="line">temp := <span class="built_in">make</span>([]<span class="keyword">int</span>, i+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt;= i; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> j == <span class="number">0</span> || j == i &#123;</span><br><span class="line">temp[j] = <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">temp[j] = res[i<span class="number">-1</span>][j<span class="number">-1</span>] + res[i<span class="number">-1</span>][j]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">res = <span class="built_in">append</span>(res, temp)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Leetcode数据结构题目集第四天，&lt;code&gt;重塑矩阵&lt;/code&gt;和&lt;code&gt;杨辉三角&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&quot;重塑矩阵&quot;&gt;&lt;a href=&quot;#重塑矩阵&quot; class=&quot;headerlink&quot; title=&quot;重塑矩阵&quot;&gt;&lt;/a&gt;重塑矩阵&lt;/h2&gt;&lt;b</summary>
      
    
    
    
    <category term="学了些什么" scheme="https://blog.farmer233.top/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="笔记" scheme="https://blog.farmer233.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="刷题" scheme="https://blog.farmer233.top/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.farmer233.top/tags/leetcode/"/>
    
    <category term="算法和数据结构" scheme="https://blog.farmer233.top/tags/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="Golang" scheme="https://blog.farmer233.top/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>[Leetcode]两个数组的交集2&amp;买卖股票的最佳时机</title>
    <link href="https://blog.farmer233.top/2021/07/18/Leetcode-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%862-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"/>
    <id>https://blog.farmer233.top/2021/07/18/Leetcode-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%862-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</id>
    <published>2021-07-18T14:01:49.000Z</published>
    <updated>2021-07-19T11:49:57.480Z</updated>
    
    <content type="html"><![CDATA[<p>Leetcode数据结构题目集的第三天的题目。<br>这次分别是<code>两个数组的交集II</code>和<code>买卖股票的最佳时机</code>。</p><a id="more"></a><h2 id="两个数组的交集II"><a href="#两个数组的交集II" class="headerlink" title="两个数组的交集II"></a>两个数组的交集II</h2><blockquote><p>给定两个数组，编写一个函数来计算它们的交集。</p></blockquote><p>示例 1：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>], nums2 = [<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">4</span>,<span class="number">9</span>,<span class="number">5</span>], nums2 = [<span class="number">9</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">4</span>]</span><br><span class="line">输出：[<span class="number">4</span>,<span class="number">9</span>]</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。</li><li>我们可以不考虑输出结果的顺序。</li></ul><p><strong>进阶：</strong></p><ul><li>如果给定的数组已经排好序呢？你将如何优化你的算法？</li><li>如果 nums1 的大小比 nums2 小很多，哪种方法更优？<br>如果 nums2 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？</li></ul><h3 id="解题思路-amp-题解"><a href="#解题思路-amp-题解" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>题目要求两个数组的交集，但没有要求顺序。<br>故我们可以遍历长的那个数组，用哈希表来存放数据结构为<code>item-次数</code>的内容。<br>然后遍历短数组时，若元素在哈希表的key中则添加到结果，并将哈希表对应的内容次数减一。<br>代码如下:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intersect</span><span class="params">(nums1 []<span class="keyword">int</span>, nums2 []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">res := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">tmp := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 为了防止num1的长度比nums2小</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nums2) &gt; <span class="built_in">len</span>(nums1) &#123;</span><br><span class="line">nums1, nums2 = nums2, nums1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, num := <span class="keyword">range</span> nums1 &#123;</span><br><span class="line">tmp[num]++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, item := <span class="keyword">range</span> nums2 &#123;</span><br><span class="line"><span class="keyword">if</span> _, ok := tmp[item]; ok &amp;&amp; tmp[item] != <span class="number">0</span> &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, item)</span><br><span class="line">tmp[item]--</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h2><blockquote><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。<br>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。<br>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p></blockquote><p>示例 1：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：在第 <span class="number">2</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">5</span> 天（股票价格 = <span class="number">6</span>）的时候卖出，最大利润 = <span class="number">6</span><span class="number">-1</span> = <span class="number">5</span> 。</span><br><span class="line">     注意利润不能是 <span class="number">7</span><span class="number">-1</span> = <span class="number">6</span>, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [<span class="number">7</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：在这种情况下, 没有交易完成, 所以最大利润为 <span class="number">0</span>。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= prices.length &lt;= 105</code></li><li><code>0 &lt;= prices[i] &lt;= 104</code></li></ul><h3 id="解题思路-amp-题解-1"><a href="#解题思路-amp-题解-1" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>主要思路如下</p><ul><li>记录<strong>今天之前买入的最小值</strong></li><li>计算<strong>今天之前最小值，今天卖出的获利</strong> =&gt; 今天卖出能获利多少</li><li>遍历的时候比较<strong>每天的获利与最大值</strong><br>代码如下:<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">min := prices[<span class="number">0</span>]</span><br><span class="line">max := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, item := <span class="keyword">range</span> prices &#123;</span><br><span class="line"><span class="keyword">if</span> item &lt; min &#123;</span><br><span class="line">min = item</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> item-min &gt; max &#123;</span><br><span class="line">max = item - min</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Leetcode数据结构题目集的第三天的题目。&lt;br&gt;这次分别是&lt;code&gt;两个数组的交集II&lt;/code&gt;和&lt;code&gt;买卖股票的最佳时机&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="学了些什么" scheme="https://blog.farmer233.top/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="笔记" scheme="https://blog.farmer233.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="刷题" scheme="https://blog.farmer233.top/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.farmer233.top/tags/leetcode/"/>
    
    <category term="算法和数据结构" scheme="https://blog.farmer233.top/tags/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="Golang" scheme="https://blog.farmer233.top/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>[Leetcode]合并两个有序数组</title>
    <link href="https://blog.farmer233.top/2021/07/17/Leetcode-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <id>https://blog.farmer233.top/2021/07/17/Leetcode-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</id>
    <published>2021-07-17T13:58:31.000Z</published>
    <updated>2021-07-17T14:39:36.117Z</updated>
    
    <content type="html"><![CDATA[<p>Leetcode数据结构题目集的第二题🎉🎈<br>这次分别是“合并两个有序数组”和“两数之和”，由于两数之和之前已经做过了这里就不再赘述了。</p><a id="more"></a><h2 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a>合并两个有序数组</h2><blockquote><p>给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。<br>初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间大小等于 m + n，这样它就有足够的空间保存来自 nums2 的元素。</p></blockquote><p>示例 1：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3</span><br><span class="line">输出：[1,2,2,3,5,6]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1], m = 1, nums2 = [], n = 0</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><h2 id="解题思路-amp-题解"><a href="#解题思路-amp-题解" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h2><p>已知m, n为nums1, nums2的元素数量且nums1的空间大小等于 m + n，也就是说通过切片 我们能拿到nums1实际需要的元素内容。<br>由于nums1的空间大小足够我们合并，因此可以直接将nums2的内容直接添加到nums1数组的m - 1后面，然后再对合并后的数组进行排序则得到了题解。<br>代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(nums1 []<span class="keyword">int</span>, m <span class="keyword">int</span>, nums2 []<span class="keyword">int</span>, n <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    nums1 = <span class="built_in">append</span>(nums1[:m], nums2...)</span><br><span class="line">    sort.Ints(nums1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h2><p>官方的第一个解法其实就是我上面的解法，此外还有一个解法是我没有想出来的，看完后加上个人理解复现一下。</p><p>这里放一张leetcode官方的动图，直观的看到原理。</p><img src="/2021/07/17/Leetcode-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/1.gif" class="" title="doubelePoint"><p>原理：利用两个point变量来模拟指针，数组看成一个队列 当其中一个队列遍历完后退出循环。代码中有详细的注释辅助理解。<br>代码如下:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(nums1 []<span class="keyword">int</span>, m <span class="keyword">int</span>, nums2 []<span class="keyword">int</span>, n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 存放结果</span></span><br><span class="line">res := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, m+n)</span><br><span class="line"><span class="comment">// 两个数组的指针</span></span><br><span class="line">point1, point2 := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 数组一循环完, 将数组二剩余元素添加到结果里面</span></span><br><span class="line"><span class="keyword">if</span> point1 == m &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, nums2[point2:]...)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 与上面同理</span></span><br><span class="line"><span class="keyword">if</span> point2 == n &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, nums1[point1:]...)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 比较两个队列头的值，将小的放入结果数组中</span></span><br><span class="line"><span class="keyword">if</span> nums1[point1] &lt; nums2[point2] &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, nums1[point1])</span><br><span class="line">point1++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, nums2[point2])</span><br><span class="line">point2++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 不太清楚leetcode的判题程序，这里无法改变nums1的引用，因此使用copy复制。</span></span><br><span class="line">    <span class="comment">// nums1 = res</span></span><br><span class="line">    <span class="built_in">copy</span>(nums1, res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Leetcode数据结构题目集的第二题🎉🎈&lt;br&gt;这次分别是“合并两个有序数组”和“两数之和”，由于两数之和之前已经做过了这里就不再赘述了。&lt;/p&gt;</summary>
    
    
    
    <category term="学了些什么" scheme="https://blog.farmer233.top/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="笔记" scheme="https://blog.farmer233.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="刷题" scheme="https://blog.farmer233.top/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.farmer233.top/tags/leetcode/"/>
    
    <category term="算法和数据结构" scheme="https://blog.farmer233.top/tags/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="Golang" scheme="https://blog.farmer233.top/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>[Leetcode]存在重复元素&amp;最大子序和</title>
    <link href="https://blog.farmer233.top/2021/07/16/Leetcode-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
    <id>https://blog.farmer233.top/2021/07/16/Leetcode-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</id>
    <published>2021-07-16T09:41:16.000Z</published>
    <updated>2021-07-16T10:16:12.692Z</updated>
    
    <content type="html"><![CDATA[<p>这次刷的是leetcode的14天数据结构题目集，这是第一天的题目集✨🎉<br>最近在看王道的数据结构和《小灰漫画算法》，顺便练习一下Golang。</p><a id="more"></a><h2 id="存在重复元素"><a href="#存在重复元素" class="headerlink" title="存在重复元素"></a>存在重复元素</h2><blockquote><p>给定一个整数数组，判断是否存在重复元素。<br>如果存在一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。</p></blockquote><p>Example1:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p>Example2:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p>Example3:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,1,1,3,3,4,3,2,4,2]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><h3 id="解题思路-amp-题解"><a href="#解题思路-amp-题解" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>已知数组是一个整型数组，故我们可以对数组进行排序，然后遍历数组。<br>通过判断相邻两个元素是否相等，从而判断数组是否有重复元素。</p><p>题解如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">containsDuplicate</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    sort.Ints(nums)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] == nums[i<span class="number">-1</span>] &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h2><blockquote><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p></blockquote><p>Example1:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span><br></pre></td></tr></table></figure><p>Example2:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p>Example3:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p>Example4:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-1]</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><p>Example5:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-100000]</span><br><span class="line">输出：-100000</span><br></pre></td></tr></table></figure><h3 id="解题思路-amp-题解-1"><a href="#解题思路-amp-题解-1" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>这道题可以说是浙大数据结构讲的 <strong>最大子列和</strong> 问题的变形，第一时间想到的是在线处理。<br>但这里需要注意<strong>输入的内容可以是负的</strong>，因此将原本的在线处理稍微变形。for循环的时候将已经遍历的元素累加起来，如果<strong>当前元素和累加结果相加大于当前元素</strong></span>（<code>nums[i - 1] + nums[i] &gt; nums[i]</code>）则证明改子列不会变小，然后再和最大值进行比较。</p><p>题解如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">max := nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line"><span class="keyword">if</span>(nums[i - <span class="number">1</span>] + nums[i] &gt; nums[i])&#123;</span><br><span class="line">            nums[i] += nums[i - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; max) &#123;</span><br><span class="line">            max = nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;这次刷的是leetcode的14天数据结构题目集，这是第一天的题目集✨🎉&lt;br&gt;最近在看王道的数据结构和《小灰漫画算法》，顺便练习一下Golang。&lt;/p&gt;</summary>
    
    
    
    <category term="学了些什么" scheme="https://blog.farmer233.top/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="笔记" scheme="https://blog.farmer233.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="刷题" scheme="https://blog.farmer233.top/tags/%E5%88%B7%E9%A2%98/"/>
    
    <category term="leetcode" scheme="https://blog.farmer233.top/tags/leetcode/"/>
    
    <category term="算法和数据结构" scheme="https://blog.farmer233.top/tags/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="Golang" scheme="https://blog.farmer233.top/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>初探Typescript-使用http模块的简易爬虫</title>
    <link href="https://blog.farmer233.top/2021/03/12/%E5%88%9D%E6%8E%A2Typescript-%E4%BD%BF%E7%94%A8http%E6%A8%A1%E5%9D%97%E7%9A%84%E7%AE%80%E6%98%93%E7%88%AC%E8%99%AB/"/>
    <id>https://blog.farmer233.top/2021/03/12/%E5%88%9D%E6%8E%A2Typescript-%E4%BD%BF%E7%94%A8http%E6%A8%A1%E5%9D%97%E7%9A%84%E7%AE%80%E6%98%93%E7%88%AC%E8%99%AB/</id>
    <published>2021-03-12T11:45:30.000Z</published>
    <updated>2021-03-12T12:24:05.482Z</updated>
    
    <content type="html"><![CDATA[<p>这两天hxd找我写一道面试题，要求使用typescript<br>typescript是JavaScript的一个超集，它具有<strong>类型系统</strong>并且可以编译成普通的JavaScript代码。   </p><h2 id="1-从多个网页爬取内容，然后进行解析"><a href="#1-从多个网页爬取内容，然后进行解析" class="headerlink" title="1. 从多个网页爬取内容，然后进行解析"></a>1. 从多个网页爬取内容，然后进行解析</h2><p>有10个网页，1.txt 到 10.txt</p><p><a href="http://dy-public.oss-cn-shenzhen.aliyuncs.com/interviewTestData/1.txt" target="_blank" rel="noopener">http://dy-public.oss-cn-shenzhen.aliyuncs.com/interviewTestData/1.txt</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">abc</span>&gt;</span> <span class="tag">&lt;<span class="name">de</span></span></span><br><span class="line"><span class="tag"><span class="attr">f</span>&gt;</span>data : 1992; name : agent 1 <span class="tag">&lt;/<span class="name">def</span>&gt;</span><span class="tag">&lt;/<span class="name">abc</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="0"><li>格式有可能有区别</li><li>用 promise, async, await 分别实现并发、串行爬取</li><li>网页下载使用nodejs的http即可</li><li>使用正则表达式获取data后面的字段，将10个文件的data值全部获取，并相加</li></ol><h2 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h2><p>Node.js 有大量的网络请求模块，题目这里要求用node的http模块<br>http模块是node自带的，使用起来十分简单，代码如下:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">http.get(url, <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    res.setEncoding(<span class="string">'utf8'</span>)</span><br><span class="line">    res.on(<span class="string">'data'</span>, <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(data)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).on(<span class="string">'error'</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(e.message)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>http模块还可以指定options，但这里只需要下载网页，因此使用简单的get请求足以。  </p><h2 id="爬虫主体"><a href="#爬虫主体" class="headerlink" title="爬虫主体"></a>爬虫主体</h2><p>爬虫大致分为两部分-&gt; <strong>网络请求</strong>和 <strong>数据清理</strong>, 网络请求已经实现了，剩下就是把请求回来的数据进行清理了。这里也没啥多的选择，题目要求使用正则表达式，简单的构建整理一下就得到了下面的代码:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> http <span class="keyword">from</span> <span class="string">'http'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Spider &#123;</span><br><span class="line">    sum: <span class="built_in">Number</span></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.sum = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    httpGet(url) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            http.get(url, <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                res.setEncoding(<span class="string">'utf8'</span>)</span><br><span class="line">                res.on(<span class="string">'data'</span>, <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">                    resolve(data)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;).on(<span class="string">'error'</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">                reject(e.message)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    render(urls) &#123;</span><br><span class="line">        urls.reduce(<span class="function">(<span class="params">promise, url</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> promise.then(_ =&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.httpGet(url)</span><br><span class="line">            &#125;).then(<span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.flush(node)</span><br><span class="line">            &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.sum += res</span><br><span class="line">            &#125;)</span><br><span class="line">                .catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e))</span><br><span class="line">        &#125;, <span class="built_in">Promise</span>.resolve())</span><br><span class="line">    &#125;</span><br><span class="line">    flush(data) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> re = <span class="regexp">/:\s(\d+?);/gi</span></span><br><span class="line">            <span class="keyword">const</span> <span class="built_in">number</span> = <span class="built_in">Number</span>(re.exec(<span class="built_in">String</span>(data))[<span class="number">1</span>])</span><br><span class="line">            resolve(<span class="built_in">number</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> baseUrl = <span class="string">'http://dy-public.oss-cn-shenzhen.aliyuncs.com/interviewTestData/'</span></span><br><span class="line"><span class="keyword">let</span> urlList = []</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">1</span>; index &lt;= <span class="number">10</span>; index++) &#123;</span><br><span class="line">    urlList.push(<span class="string">`<span class="subst">$&#123;baseUrl&#125;</span><span class="subst">$&#123;index&#125;</span>.txt`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> spider = <span class="keyword">new</span> Spider()</span><br><span class="line">spider.render(urlList)</span><br><span class="line"><span class="comment">// 模拟等待微队列运行完成， 可以用await语法糖</span></span><br><span class="line"><span class="comment">// 这里只是写个大题的框架罢了，后面根据具体的要求改动</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(spider.sum)</span><br><span class="line">&#125;, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure><h2 id="The-End"><a href="#The-End" class="headerlink" title="The End"></a>The End</h2><p>到此为止，整个爬虫就写完了，总结一下体验。typescript是具有类型系统，这对于我这写多了python和JavaScript的人来说太好上手了！ </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这两天hxd找我写一道面试题，要求使用typescript&lt;br&gt;typescript是JavaScript的一个超集，它具有&lt;strong&gt;类型系统&lt;/strong&gt;并且可以编译成普通的JavaScript代码。   &lt;/p&gt;
&lt;h2 id=&quot;1-从多个网页爬取内容，然后</summary>
      
    
    
    
    <category term="学了些什么" scheme="https://blog.farmer233.top/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="前端" scheme="https://blog.farmer233.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="web" scheme="https://blog.farmer233.top/tags/web/"/>
    
    <category term="笔记" scheme="https://blog.farmer233.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="TypeScript" scheme="https://blog.farmer233.top/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>简单看看JavaScript中的Promise</title>
    <link href="https://blog.farmer233.top/2021/02/08/%E7%AE%80%E5%8D%95%E7%9C%8B%E7%9C%8BJavaScript%E4%B8%AD%E7%9A%84Promise/"/>
    <id>https://blog.farmer233.top/2021/02/08/%E7%AE%80%E5%8D%95%E7%9C%8B%E7%9C%8BJavaScript%E4%B8%AD%E7%9A%84Promise/</id>
    <published>2021-02-08T07:49:23.000Z</published>
    <updated>2021-02-08T09:02:22.007Z</updated>
    
    <content type="html"><![CDATA[<p>谈到JavaScript相信它的事件回调大家肯定都听过。即使只有一个执行线程，它也能处理异步高并发。<br>同样很多人回调写多了都不可避免的会变成<strong>Callback Hell(回调地狱)</strong>，这样的代码会非常复杂难懂，因为回调不像同步代码，它的执行顺序不是从上至下的，读回调代码必须反复横跳，思考什么情况下回跳到什么地方。<br>Promise就是一种异步编程，很早就有了随着ES6的发布Promise也成了JavaScript原生支持的对象,但学校这学期的课程并没有相关章节。因此顺便学习下Promise对象的使用。</p><p>以JavaScript原生的AJAX为栗子，AJAX的请求形式如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">url, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">    xhr.open(<span class="string">'GET'</span>, url)</span><br><span class="line">    xhr.send()</span><br><span class="line">    xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.status == <span class="number">200</span>) &#123;</span><br><span class="line">            callback(<span class="built_in">JSON</span>.parse(<span class="keyword">this</span>.response))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"加载失败"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们就以此方式依次请求三个接口(地址)，假设响应体的JSON格式是<code>{id: 1, name: &quot;farmer&quot;}</code>, JS代码如下:  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ajax(<span class="string">'http://127.0.0.1:5003/?name=farmer'</span>, (user) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 先拿到一个东西，再用这个东西去查别的，比如通过用户名查该用户的资料</span></span><br><span class="line">    ajax(<span class="string">'http://127.0.0.1:5003/?name='</span> + user.name, (e) =&gt; &#123;</span><br><span class="line">        ajax(<span class="string">'http://127.0.0.1:5003/?name='</span> + user.name, (e) =&gt; &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(e)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>是不是觉得嵌套很多？ 如果连续请求更多的地址，那嵌套就要看傻了。 接下来我们试试用Promise对象对ajax进行封装，看看效果怎么样。 代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">        xhr.open(<span class="string">'GET'</span>, url)</span><br><span class="line">        xhr.send()</span><br><span class="line">        xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.status == <span class="number">200</span>) &#123;</span><br><span class="line">                resolve(<span class="built_in">JSON</span>.parse(<span class="keyword">this</span>.response))</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                reject(<span class="string">"加载失败"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            reject(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中，我们自己封装的AJAX会返回一个“Promise”对象，初始化该对象时我们要传入一个函数，这个函数又接受两个回调函数作为参数，分别是<code>resolve</code>和<code>reject</code>。<code>resolve</code>就是你操作成功时调用的方法，<code>reject</code>就是失败时调用的。接下来让我们同样实现前面三个接口的功能:  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> url = <span class="string">"http://127.0.0.1:5003/"</span></span><br><span class="line">ajax(<span class="string">`<span class="subst">$&#123;url&#125;</span>?name=xiaotao`</span>).then(</span><br><span class="line">    value =&gt;&#123;</span><br><span class="line">        <span class="comment">// 这里可以通过第一个数据再发送请求</span></span><br><span class="line">        <span class="keyword">return</span> ajax(<span class="string">`<span class="subst">$&#123;url&#125;</span>?name=`</span> + value.name)</span><br><span class="line">    &#125;</span><br><span class="line">).then(<span class="function"><span class="params">value</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ajax(<span class="string">`<span class="subst">$&#123;url&#125;</span>?name=`</span> + value.name)</span><br><span class="line">&#125;).then(</span><br><span class="line">    value =&gt; <span class="built_in">console</span>.log(value),</span><br><span class="line">    reason =&gt; <span class="built_in">console</span>.log(reason)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>大家是不是发现，本来长长的嵌套，变成了顺序执行的代码了？ 到此就是Promise的简单探讨了。 如果你对上面的栗子还不太清楚，那下面是一些Promise对象更基础、详细的解释or栗子。希望能帮到你~😃</p><h2 id="Promise怎么用？"><a href="#Promise怎么用？" class="headerlink" title="Promise怎么用？"></a>Promise怎么用？</h2><p>相信刚接触Promise的童鞋都比较迷惑，到底应该怎么用Promise。其实上面有提到过，初始化该对象时我们要传入一个函数(我这里使用的是匿名函数)，这个函数又接受两个回调函数作为参数(这里读起来比较拗口，可以和下面的栗子结合起来看)，分别是<code>resolve</code>和<code>reject</code>。<code>resolve</code>就是你操作成功时调用的方法，<code>reject</code>就是失败时调用的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// resolved 成功</span></span><br><span class="line"><span class="comment">// rejected 拒绝</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 工作流程</span></span><br><span class="line">    resolve(<span class="string">"成功状态"</span>)</span><br><span class="line">    <span class="comment">// reject("失败状态")</span></span><br><span class="line">&#125;).then( <span class="comment">// then -&gt; 微任务列表</span></span><br><span class="line">    <span class="comment">// 工作后的处理</span></span><br><span class="line">    <span class="comment">// then方法有两个参数，第一个是成功的回调函数，第二个是失败的</span></span><br><span class="line">    value =&gt; &#123;</span><br><span class="line">        <span class="comment">// 成功</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"成功业务处理-1"</span>)</span><br><span class="line">    &#125;, </span><br><span class="line">    reason =&gt; &#123;</span><br><span class="line">        <span class="comment">// 失败</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'失败(拒绝)的业务处理-1'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">).then(</span><br><span class="line">    value =&gt; <span class="built_in">console</span>.log(<span class="string">"成功业务处理-2"</span>),</span><br><span class="line">    reason =&gt; <span class="built_in">console</span>.log(<span class="string">'失败(拒绝)的业务处理-2'</span>)</span><br><span class="line">    <span class="comment">// 上面一个Then可能不太清晰，这里和上面的逻辑是一样的。</span></span><br><span class="line">    <span class="comment">// then有两个参数，这两个参数是两个回调函数。</span></span><br><span class="line">    <span class="comment">// 一个是成功状态的回调函数，对应这里的value。 而这个成功状态则是上面的resolve</span></span><br><span class="line">    <span class="comment">// 一个是失败状态的回调函数，对应这里的reason。而这个失败状态则是上面的reject</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="Then的更多用法"><a href="#Then的更多用法" class="headerlink" title="Then的更多用法"></a>Then的更多用法</h2><p>我们从上面的栗子可以看到，then函数也有两个参数，也是一个成功一个失败。其实then也是一个Promise。<br>但从上面的栗子也可以发现，第二个then无论前一个then是哪个参数处理的，都只会出发成功状态。如果我们想让第二个then的失败处理也能生效，我们应该将代码改成下面这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'fulfilled'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = p1.then(</span><br><span class="line">    value =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(value)</span><br><span class="line">        <span class="comment">// 第一个Then return的内容, Then默认返回成功(resolve)</span></span><br><span class="line">        <span class="comment">// return 'Farmer'</span></span><br><span class="line">        <span class="comment">// 返回一个Promise</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// resolve("解决")</span></span><br><span class="line">            reject(<span class="string">"Then 解决失败"</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    reason =&gt; &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(reason)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">// resolve("解决")</span></span><br><span class="line">                    reject(<span class="string">"Then 解决失败"</span>)</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">).then(</span><br><span class="line">    value =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(value)</span><br><span class="line">    &#125;,</span><br><span class="line">    reason =&gt; <span class="built_in">console</span>.log(reason)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>当第一个then返回一个Promise对象后，第二个then就能根据前一个then返回的Promise的状态进行处理。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于Promise一些更深层次的理论这里就不探讨了，网上资料很多，大家可以去搜索下。本文中的示例代码可以在<a href="https://gitee.com/Farmer-chong/my-codes/tree/master/PromiseLearn" target="_blank" rel="noopener">这里下载</a>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;谈到JavaScript相信它的事件回调大家肯定都听过。即使只有一个执行线程，它也能处理异步高并发。&lt;br&gt;同样很多人回调写多了都不可避免的会变成&lt;strong&gt;Callback Hell(回调地狱)&lt;/strong&gt;，这样的代码会非常复杂难懂，因为回调不像同步代码，它的执</summary>
      
    
    
    
    <category term="学了些什么" scheme="https://blog.farmer233.top/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="前端" scheme="https://blog.farmer233.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="web" scheme="https://blog.farmer233.top/tags/web/"/>
    
    <category term="JavaScript" scheme="https://blog.farmer233.top/tags/JavaScript/"/>
    
    <category term="笔记" scheme="https://blog.farmer233.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>前端 | Skeleton骨架屏</title>
    <link href="https://blog.farmer233.top/2021/01/12/%E5%89%8D%E7%AB%AF-Skeleton%E9%AA%A8%E6%9E%B6%E5%B1%8F/"/>
    <id>https://blog.farmer233.top/2021/01/12/%E5%89%8D%E7%AB%AF-Skeleton%E9%AA%A8%E6%9E%B6%E5%B1%8F/</id>
    <published>2021-01-12T09:56:43.000Z</published>
    <updated>2021-01-12T10:54:19.539Z</updated>
    
    <content type="html"><![CDATA[<p>之前在众多App上看到过骨架屏，不过今天才知道这个效果叫骨架屏hhh.<br>这个效果体验上比焦虑圈要好很多🚀<br>基础栗子: <a href="/demo/Skeleton/index.html">Base_demo</a><br>加载栗子: <a href="/demo/Skeleton/apiLoading/index.html">loading_demo</a></p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天刷视频的时候看到骨架屏对用户体验有显著的提升，边学边敲-&gt;<a href="/demo/Skeleton/index.html">Base_demo</a><br>后面对代码进行了少量的修改 -&gt; <a href="/demo/Skeleton/apiLoading/index.html">loading_demo</a>, 将代码和请求相结合。后期可以和懒加载配合使用。🚀🌙    </p><h2 id="基础栗子"><a href="#基础栗子" class="headerlink" title="基础栗子"></a>基础栗子</h2><h3 id="HTML结构"><a href="#HTML结构" class="headerlink" title="HTML结构"></a>HTML结构</h3><p>这里有两个div, 一个表示加载后的, 一个表示加载中的. </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"image"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://www.imagesource.com/wp-contentuploads/2019/06/Rio.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h4</span>&gt;</span>Skeleton Demo<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"description"</span>&gt;</span></span><br><span class="line">            骨架框效果测试样例，这是一段测试使用噶文字This is a test text.</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"card loading"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"image"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h4</span>&gt;</span><span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"description"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><p>观察栗子可以发现，加载的时候背景有一道白色光影划过。这里利用了<code>background</code>的 <code>linear-gradient</code>函数，这是一种特别的image。表示渐变轴为100°, 从<code>rgba(255, 255, 255, 0) 40%</code> 渐变到 <code>rgba(255, 255, 255, .5) 50%</code>.<br>然后用<code>background-size</code> 将 <code>linear-gradient</code>图片宽拉伸一倍.<br>最后通过改变<code>position</code>来移动白色反光区域，造成光影特效.  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span>&#123;</span><br><span class="line">    <span class="attribute">--loading-grey</span>: <span class="number">#ededed</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#fefefe</span>;</span><br><span class="line">    <span class="attribute">font-family</span>: Arial, Helvetica, sans-serif;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: space-evenly;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">100vh</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.card</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">320px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">6px</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0px</span> <span class="number">4px</span> <span class="number">6px</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, .<span class="number">12</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.image</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.image</span> <span class="selector-tag">img</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: inherit;</span><br><span class="line">    <span class="attribute">object-fit</span>: cover;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.content</span>&#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">2rem</span> <span class="number">1.8rem</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h4</span>&#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">1rem</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1.5rem</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1.5rem</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.description</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1rem</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1.4rem</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.loading</span> <span class="selector-class">.image</span>,</span><br><span class="line"><span class="selector-class">.loading</span> <span class="selector-tag">h4</span>,</span><br><span class="line"><span class="selector-class">.loading</span> <span class="selector-class">.description</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">var</span>(--loading-grey);</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(</span><br><span class="line">        <span class="number">100deg</span>,</span><br><span class="line">        rgba(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>) <span class="number">40%</span>,</span><br><span class="line">        <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, .<span class="number">5</span>) <span class="number">50%</span>,</span><br><span class="line">        <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>) <span class="number">60%</span></span><br><span class="line">    ) <span class="built_in">var</span>(--loading-grey);</span><br><span class="line">    <span class="attribute">background-size</span>: <span class="number">200%</span> <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background-position-x</span>: <span class="number">120%</span>;</span><br><span class="line">    <span class="attribute">animation</span>: <span class="number">1s</span> loading ease-in-out infinite;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> loading&#123;</span><br><span class="line">    <span class="selector-tag">to</span>&#123;</span><br><span class="line">        <span class="attribute">background-position-x</span>: -<span class="number">20%</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.loading</span> <span class="selector-tag">h4</span>&#123;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">1.6rem</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">    <span class="attribute">animation-delay</span>: .<span class="number">05s</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.loading</span> <span class="selector-class">.description</span>&#123;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">4rem</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">    <span class="attribute">animation-delay</span>: .<span class="number">06s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初步结束"><a href="#初步结束" class="headerlink" title="初步结束"></a>初步结束</h3><p>到此为止，基本的效果已经实现了。-&gt; <a href="/demo/Skeleton/index.html">Base_demo</a></p><h2 id="稍微修改一下"><a href="#稍微修改一下" class="headerlink" title="稍微修改一下"></a>稍微修改一下</h2><p>修改了一下，将加载和加载后相结合.  </p><h3 id="HTML结构-1"><a href="#HTML结构-1" class="headerlink" title="HTML结构"></a>HTML结构</h3><p>因为将加载和加载后结合起来, 这里取消了第二个<code>div</code>.   </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"Skeleton"</span> <span class="attr">class</span>=<span class="string">"card loading"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"image"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">"img"</span> <span class="attr">src</span>=<span class="string">"https://www.imagesource.com/wp-content/uploads/2019/06/Rio.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h4</span>&gt;</span>Skeleton Demo<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"description"</span>&gt;</span></span><br><span class="line">                骨架框效果测试样例，这是一段测试使用噶文字。This is a test text.</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="CSS-1"><a href="#CSS-1" class="headerlink" title="CSS"></a>CSS</h3><p>沿用上面的css, 这里不再重复.   </p><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><p>这里用了<code>onreadystatechange</code>, 当页面加载完时<code>readyState</code>属性会是 <code>complete</code>来判断是否加载完资源,后期可以灵活更改。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.onreadystatechange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> Skeleton = <span class="built_in">document</span>.querySelector(<span class="string">"#Skeleton"</span>)</span><br><span class="line">    Skeleton.classList.add(<span class="string">"loading"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> text = <span class="built_in">document</span>.querySelectorAll(<span class="string">".content h4"</span>)</span><br><span class="line">    text.forEach(<span class="function"><span class="params">e</span> =&gt;</span> &#123; e.innerText = <span class="string">""</span> &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> description = <span class="built_in">document</span>.querySelectorAll(<span class="string">".description"</span>)</span><br><span class="line">    description.forEach(<span class="function"><span class="params">e</span> =&gt;</span> &#123; e.innerText = <span class="string">""</span> &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.readyState == <span class="string">"complete"</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(Skeleton.classList.remove(<span class="string">"loading"</span>))</span><br><span class="line">        text.forEach(<span class="function"><span class="params">e</span> =&gt;</span> &#123; e.innerText = <span class="string">"Skeleton Demo"</span> &#125;)</span><br><span class="line">        description.forEach(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">            e.innerText = <span class="string">"骨架框效果测试样例，这是一段测试使用噶文字。This is a test text."</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前在众多App上看到过骨架屏，不过今天才知道这个效果叫骨架屏hhh.&lt;br&gt;这个效果体验上比焦虑圈要好很多🚀&lt;br&gt;基础栗子: &lt;a href=&quot;/demo/Skeleton/index.html&quot;&gt;Base_demo&lt;/a&gt;&lt;br&gt;加载栗子: &lt;a href=&quot;/demo/Skeleton/apiLoading/index.html&quot;&gt;loading_demo&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="学了些什么" scheme="https://blog.farmer233.top/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="前端" scheme="https://blog.farmer233.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="web" scheme="https://blog.farmer233.top/tags/web/"/>
    
    <category term="JavaScript" scheme="https://blog.farmer233.top/tags/JavaScript/"/>
    
    <category term="笔记" scheme="https://blog.farmer233.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript小游戏——2048Game</title>
    <link href="https://blog.farmer233.top/2020/12/29/JavaScript%E5%B0%8F%E6%B8%B8%E6%88%8F-2048Game/"/>
    <id>https://blog.farmer233.top/2020/12/29/JavaScript%E5%B0%8F%E6%B8%B8%E6%88%8F-2048Game/</id>
    <published>2020-12-29T15:17:31.000Z</published>
    <updated>2020-12-29T15:33:56.847Z</updated>
    
    <content type="html"><![CDATA[<p>这几天学校JavaScript课程实训，项目是做一个2048小游戏<br>好久没玩这个游戏了，感觉偶尔玩玩还是不错的.<br>预览、案例、栗子: <a href="/demo/2048Game/index.html">Demo</a><br>ps: 纯粹方便自己日后玩2333.   </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这几天学校JavaScript课程实训，项目是做一个2048小游戏&lt;br&gt;好久没玩这个游戏了，感觉偶尔玩玩还是不错的.&lt;br&gt;预览、案例、栗子: &lt;a href=&quot;/demo/2048Game/index.html&quot;&gt;Demo&lt;/a&gt;&lt;br&gt;ps: 纯粹方便自己日后玩233</summary>
      
    
    
    
    <category term="学了些什么" scheme="https://blog.farmer233.top/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="前端" scheme="https://blog.farmer233.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="web" scheme="https://blog.farmer233.top/tags/web/"/>
    
    <category term="JavaScript" scheme="https://blog.farmer233.top/tags/JavaScript/"/>
    
    <category term="笔记" scheme="https://blog.farmer233.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>蓝桥杯校内选拔WP</title>
    <link href="https://blog.farmer233.top/2020/12/23/%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%A0%A1%E5%86%85%E9%80%89%E6%8B%94WP/"/>
    <id>https://blog.farmer233.top/2020/12/23/%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%A0%A1%E5%86%85%E9%80%89%E6%8B%94WP/</id>
    <published>2020-12-23T03:38:29.000Z</published>
    <updated>2020-12-24T07:37:23.859Z</updated>
    
    <content type="html"><![CDATA[<p>上周五参加了蓝桥杯的校内选拔，给虐的惨目忍睹。<br>啪的一下很快啊，欺负我这个大三的老同志/(ㄒoㄒ)/~<br>这次我选的是python组，有点后悔没选C/C++, python一上来就图论就离谱😟<br>试卷就没有了，仅写一下当时考试时脑子短路没想到的几道题  </p><a id="more"></a><h2 id="第一题-细胞分裂"><a href="#第一题-细胞分裂" class="headerlink" title="第一题-细胞分裂"></a>第一题-细胞分裂</h2><p>题目描述：现在有一个细胞，每一个小时分裂一次，第三个小时时细胞自然死亡<br>问：第N个小时后还有几个细胞存活    </p><p>输入：<br><code>5</code><br>输出:<br><code>24</code></p><p>这道题看上去就想斐波那契数列的变形，考场上第一想法就是用数组来解但一直解决不了细胞死亡问题导致第一道程序设计题就卡壳了。<br>最气的是一出考场就想到了解法….我….<br>题解：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">n = int(input())</span><br><span class="line"></span><br><span class="line">temp_list = [</span><br><span class="line">    &#123;<span class="string">"old"</span>: <span class="number">1</span>,<span class="string">"new"</span>: <span class="number">0</span>, <span class="string">"all"</span>: <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"old"</span>: <span class="number">1</span>,<span class="string">"new"</span>: <span class="number">1</span>, <span class="string">"all"</span>: <span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"old"</span>: <span class="number">2</span>,<span class="string">"new"</span>: <span class="number">2</span>, <span class="string">"all"</span>: <span class="number">4</span>&#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line">    old = temp_list[<span class="number">-1</span>][<span class="string">"all"</span>]</span><br><span class="line">    die = temp_list[<span class="number">-3</span>][<span class="string">"old"</span>]</span><br><span class="line">    temp_dict = &#123;</span><br><span class="line">        <span class="string">"old"</span>: old,</span><br><span class="line">        <span class="string">"new"</span>: old,</span><br><span class="line">        <span class="string">"all"</span>: old * <span class="number">2</span> - die</span><br><span class="line">    &#125;</span><br><span class="line">    temp_list.append(temp_dict)</span><br><span class="line"></span><br><span class="line">print(temp_list[<span class="number">-1</span>][<span class="string">"all"</span>])</span><br></pre></td></tr></table></figure><h2 id="第二题-猴子选大王"><a href="#第二题-猴子选大王" class="headerlink" title="第二题-猴子选大王"></a>第二题-猴子选大王</h2><p>题目描述：一群猴子要选新猴王。新猴王的选择方法是：让N只候选猴子围成一圈，从某位置起顺序编号为1~N号。从第1号开始报数，每轮从1报到3，凡报到3的猴子即退出圈子，接着又从紧邻的下一只猴子开始同样的报数。如此不断循环，最后剩下的一只猴子就选为猴王。请问是原来第几号猴子当选猴王？</p><p><strong>输入格式：</strong><br>输入在一行中给一个正整数N（≤1000）。<br>example:    </p><blockquote><p>11</p></blockquote><p><strong>输出格式：</strong><br>在一行中输出当选猴王的编号。<br>example:   </p><blockquote><p>7</p></blockquote><p>题解:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">n = int(input())</span><br><span class="line">temp_list = list(range(n))</span><br><span class="line">target = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> len(temp_list) &gt; <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> temp_list[:]:</span><br><span class="line">        <span class="keyword">if</span> target == <span class="number">3</span>:</span><br><span class="line">            temp_list.remove(value)</span><br><span class="line">            target = <span class="number">0</span></span><br><span class="line">        target += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">print(temp_list[<span class="number">-1</span>] + <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>很多题目以前都在PTA上自己解答过，但一上考场就凉了，还是自己太菜了~</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上周五参加了蓝桥杯的校内选拔，给虐的惨目忍睹。&lt;br&gt;啪的一下很快啊，欺负我这个大三的老同志/(ㄒoㄒ)/~&lt;br&gt;这次我选的是python组，有点后悔没选C/C++, python一上来就图论就离谱😟&lt;br&gt;试卷就没有了，仅写一下当时考试时脑子短路没想到的几道题  &lt;/p&gt;</summary>
    
    
    
    <category term="胡思乱语" scheme="https://blog.farmer233.top/categories/%E8%83%A1%E6%80%9D%E4%B9%B1%E8%AF%AD/"/>
    
    
    <category term="算法和数据结构" scheme="https://blog.farmer233.top/tags/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="python" scheme="https://blog.farmer233.top/tags/python/"/>
    
    <category term="蓝桥杯" scheme="https://blog.farmer233.top/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>软考网络攻城狮学习笔记</title>
    <link href="https://blog.farmer233.top/2020/11/10/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%9F%8E%E7%8B%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://blog.farmer233.top/2020/11/10/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%9F%8E%E7%8B%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-11-10T09:27:09.000Z</published>
    <updated>2020-11-27T10:00:55.686Z</updated>
    
    <content type="html"><![CDATA[<p>前天考完软考-网络攻城狮，写一下笔记趴✌🙌<br>随便记录一下，写的不算好，单纯只是做个笔记以后复习用(自己能看懂就行)</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>互联网可以划分为多个自治系统(autonomous system, AS) ，每个AS内部可以和别的 AS 使用不同的路由选择协议，根据使用的范围差异可以将路由选择协议划分为自治系统内部的协议和自治系统外的协议    </p><h2 id="Web安全"><a href="#Web安全" class="headerlink" title="Web安全"></a>Web安全</h2><p>这次软考下午卷考了一手web安全，常见的sql注入、XSS、一句话木马、Excel宏病毒等等，不过都说些简单问题稍有了解就能答出来。写在前面是因为这东西比较好玩并且有了解过所以在前面记录一下。<br>常见的类型: </p><ul><li>sql注入</li><li>XSS</li><li>一句话木马</li><li>Excel宏病毒</li><li>APT</li><li>DDos</li><li>蠕虫病毒</li></ul><h2 id="RIP-amp-OSPF-路由-Hot"><a href="#RIP-amp-OSPF-路由-Hot" class="headerlink" title="RIP &amp; OSPF 路由(Hot)"></a>RIP &amp; OSPF 路由(Hot)</h2><p><strong>这两个协议都是自治系统内的协议</strong>，只能用于内部网络或者说小型网络    </p><h3 id="rip"><a href="#rip" class="headerlink" title="rip"></a>rip</h3><p>通过邻居获取网络路由，再与自己的路由表合并</p><h3 id="ospf"><a href="#ospf" class="headerlink" title="ospf"></a>ospf</h3><ul><li>寻找邻居</li><li>建立邻接关系</li><li>链路状态信息传递</li><li>计算路由</li></ul><h3 id="两者对比"><a href="#两者对比" class="headerlink" title="两者对比"></a>两者对比</h3><table><thead><tr><th align="center">对比</th><th align="center">rip</th><th align="center">ospf</th></tr></thead><tbody><tr><td align="center">协议对比</td><td align="center">距离矢量协议</td><td align="center">链路状态协议</td></tr><tr><td align="center">传输成本</td><td align="center">开销低</td><td align="center">传输成本好</td></tr><tr><td align="center">实现方式</td><td align="center">计算路由跳数</td><td align="center">洪泛法(向自治系统中的所有路由发送信息)</td></tr><tr><td align="center">时间</td><td align="center">每30s发送一次</td><td align="center">当网络拓扑改变的时候</td></tr><tr><td align="center">跳数限制</td><td align="center">最多15跳(16则不可达)</td><td align="center">没限制</td></tr><tr><td align="center">使用的算法</td><td align="center">距离向量算法</td><td align="center">最短路径算法(Dijkstra)</td></tr><tr><td align="center">适用网络</td><td align="center">小型网络</td><td align="center">大型网络</td></tr><tr><td align="center">ospf的优势</td><td align="center"></td><td align="center">没有跳数限制、可变子网掩码(VESM)、网络规模大、收敛速度快</td></tr><tr><td align="center">ospf中DR的作用范围</td><td align="center"></td><td align="center">一个网段</td></tr></tbody></table><h2 id="广播域-amp-amp-冲突域-Hot"><a href="#广播域-amp-amp-冲突域-Hot" class="headerlink" title="广播域 &amp;&amp; 冲突域(Hot)"></a>广播域 &amp;&amp; 冲突域(Hot)</h2><p>区别:  </p><ul><li>广播域可以跨网段，而冲突域只是发生的同一个网段的。</li><li>冲突域：在同一个冲突域中的每一个节点都能收到所有被发送的帧;</li><li>广播域：网络中能接收任一设备发出的广播帧的所有设备的集合;</li><li>冲突域：基于第一层（物理层）;</li><li>广播域：基于第二层（数据链路层）;</li><li>一个局域网就是一个广播域（往往是指一个IP段内），广播域中的机器可以收到域中其他任何一台机器的播，而不能收到域外机器的广播，域外机器也不能收到域内机器发的广播；</li><li>冲突域：一个站点向另一个站点发出信号。能收到信号的站点就构成一个冲突域。</li><li>集线器（HUB） 所有端口都在同一个广播域，冲突域内。</li></ul><h2 id="DNSの两种查询-Hot"><a href="#DNSの两种查询-Hot" class="headerlink" title="DNSの两种查询(Hot)"></a>DNSの两种查询(Hot)</h2><h3 id="迭代查询-主机向本地域名服务器查询"><a href="#迭代查询-主机向本地域名服务器查询" class="headerlink" title="迭代查询 (主机向本地域名服务器查询)"></a>迭代查询 (主机向本地域名服务器查询)</h3><p>如果主机所询问的本地域名服务器不知道被查询域名的ip, 那么本地域名服务器就以DNS客户的身份，向其他根域名服务器继续发出查询请求报文(即替该主机继续查询)，而不是让该主机自己进行下一步的查询.因此，递归擦汗寻返回的查询结果或者是所要查询的ip地址，或者是报错，表示无法查询到所需的IP地址。</p><h3 id="递归查询-本地域名服务器向根域名服务器查询"><a href="#递归查询-本地域名服务器向根域名服务器查询" class="headerlink" title="递归查询 (本地域名服务器向根域名服务器查询)"></a>递归查询 (本地域名服务器向根域名服务器查询)</h3><p>当根域名服务器收到本地域名服务器发出的迭代查询请求报文是，要么给出所要查询的IP地址，要么告诉本地域名服务器进行后续的查询(而不是替本地域名服务器进行后续的查询)。</p><img src="/2020/11/10/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%9F%8E%E7%8B%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/query.jpg" class="" title="query"><center>图片来源->bing搜索</center><h2 id="Tcp-amp-Udp-Hot"><a href="#Tcp-amp-Udp-Hot" class="headerlink" title="Tcp &amp; Udp(Hot)"></a>Tcp &amp; Udp(Hot)</h2><h3 id="Tcp"><a href="#Tcp" class="headerlink" title="Tcp"></a>Tcp</h3><ul><li>握手&amp;挥手</li><li>滑窗控制 –&gt; 动态规划<h3 id="udp"><a href="#udp" class="headerlink" title="udp"></a>udp</h3></li><li>头部大小: 8字节</li></ul><p>这部分内容太多了甚至还能引申出算法内容，以后单独拿出来讲吧~<br>(绝对不是挖坑！🕊)</p><h2 id="电子邮件协议-IMAP-amp-POP3-Hot"><a href="#电子邮件协议-IMAP-amp-POP3-Hot" class="headerlink" title="电子邮件协议(IMAP &amp; POP3)(Hot)"></a>电子邮件协议(IMAP &amp; POP3)(Hot)</h2><p>区别: </p><ol><li>pop3协议允许电子邮件客户端下载服务器上的邮件，但是在客户端的操作(移动、标记已读等)，不会反馈到服务器上。</li><li>IMAP客户端的操作都会反馈到服务器上</li></ol><h2 id="DES加密算法-Hot-None"><a href="#DES加密算法-Hot-None" class="headerlink" title="DES加密算法(Hot)(None)"></a>DES加密算法(Hot)(None)</h2><p>做了5年的软考题，DES加密算法可以说是必考题了，每年都考。</p><h2 id="卫星通信中的差错控制"><a href="#卫星通信中的差错控制" class="headerlink" title="卫星通信中的差错控制"></a>卫星通信中的差错控制</h2><ol><li>选择重传ARQ</li><li>前项差错控制FEC</li><li>多站分集的自动反馈重发</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前天考完软考-网络攻城狮，写一下笔记趴✌🙌&lt;br&gt;随便记录一下，写的不算好，单纯只是做个笔记以后复习用(自己能看懂就行)&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;互</summary>
      
    
    
    
    <category term="学了些什么" scheme="https://blog.farmer233.top/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="笔记" scheme="https://blog.farmer233.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机网络基础" scheme="https://blog.farmer233.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
