<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Farmer</title>
  <icon>https://blog.farmer233.top/favicon.png</icon>
  <subtitle>-Farmer的自习室</subtitle>
  <link href="https://blog.farmer233.top/atom.xml" rel="self"/>
  
  <link href="https://blog.farmer233.top/"/>
  <updated>2023-11-12T17:49:26.349Z</updated>
  <id>https://blog.farmer233.top/</id>
  
  <author>
    <name>-Farmer</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《OSTEP》学习笔记（一）操作系统介绍</title>
    <link href="https://blog.farmer233.top/2023/10/13/%E3%80%8AOSTEP%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D/"/>
    <id>https://blog.farmer233.top/2023/10/13/%E3%80%8AOSTEP%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D/</id>
    <published>2023-10-12T17:36:51.000Z</published>
    <updated>2023-11-12T17:49:26.349Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本系列文章将按照《Operating Systems: Three Easy Pieces》一书的章节顺序编写，结合原文与自己的感悟，以作笔记之用，如有不足之处，恳请在评论区指出</p></blockquote><p>操作系统主要的三个部分分别是：虚拟化（virtualization）、并发（concurrency）和持久化（persistence），这是本书主要学习的3个关键概念。通过学习这三个概念来理解操作系统这门课程。</p><p>国内许多教材&#x2F;八股文对操作系统的描述可能与本书差异较大，但我个人感觉其实都是描述一个东西，相比之下教材上只是描述的更具体。比如进程&#x2F;线程其实是操作系统实现虚拟化的其中一个手段的等等。</p><h2 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h2><h3 id="CPU-虚拟化"><a href="#CPU-虚拟化" class="headerlink" title="CPU 虚拟化"></a>CPU 虚拟化</h3><p>下面是一个简单的程序，它所做的只是循环每秒打印出用户在命令行中传入的字符串：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: cpu &lt;string&gt;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> *str = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Spin(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>common.h</code> 头文件将放在本文末尾，当然你也可以访问<a href="https://pages.cs.wisc.edu/~remzi/OSTEP/">官网</a>&#x2F;<a href="https://github.com/FarmerChillax/ostep-code/blob/master/intro/common.h">GitHub</a>来获取</p></blockquote><p>当我们在一个单处理器（cpu）的系统上编译并运行它，我们将看到以下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">farmer:~/studys/operating-systems/ch02$ ./cpu A</span><br><span class="line">A</span><br><span class="line">A</span><br><span class="line">A</span><br><span class="line">A</span><br><span class="line">A</span><br><span class="line">^C</span><br><span class="line">farmer:~/studys/operating-systems/ch02$</span><br></pre></td></tr></table></figure><p>这个结果看起来十分合理不是吗？现在让我们运行同一个程序的不同实例，来看看结果：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">farmer:</span>~/studys/operating-systems/ch02$ ./cpu A &amp; ./cpu <span class="keyword">B</span> &amp; ./cpu C &amp;</span><br><span class="line">[<span class="number">1</span>] <span class="number">208278</span></span><br><span class="line">[<span class="number">2</span>] <span class="number">208279</span></span><br><span class="line">[<span class="number">3</span>] <span class="number">208280</span></span><br><span class="line"><span class="keyword">B</span></span><br><span class="line">C</span><br><span class="line">A</span><br><span class="line"><span class="keyword">B</span></span><br><span class="line">C</span><br><span class="line">C</span><br><span class="line"><span class="keyword">B</span></span><br><span class="line">A</span><br><span class="line"><span class="keyword">B</span></span><br><span class="line">A</span><br><span class="line">C</span><br><span class="line"><span class="keyword">B</span></span><br><span class="line">A</span><br><span class="line">C</span><br><span class="line"><span class="symbol">...</span></span><br></pre></td></tr></table></figure><p>现在事情开始有趣起来了，尽管只有一个处理器，但是这几个程序在我们用户的视角看来还是在同时运行的，看起来就像有多个处理器在同时执行这3个程序一样！</p><p>而这种将单个CPU（或其中一小部分）转换成看似多个CPU，从而让许多程序看似同时运行的技术，这就是所谓的虚拟化CPU（virtualizing the CPU）</p><h3 id="内存虚拟化"><a href="#内存虚拟化" class="headerlink" title="内存虚拟化"></a>内存虚拟化</h3><p>看完了CPU让我们来看看内存，现代机器提供的物理内存（physical memory）模型其实非常的简单，就是一个字节数组而已。程序通过指定一个地址（address）来访问、写入或更新存在那里的数据。</p><p>程序运行时一直要访问内存，程序将所有数据结构保存在内存中，并通过各种指令来访问它们，因此每次读取指令都会访问内存。下面来看一个简单的demo：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">//a1</span></span><br><span class="line">    assert(p != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(%d) memory address of p: %08x\n&quot;</span>, getpid(), (<span class="type">unsigned</span>) p); <span class="comment">//a2</span></span><br><span class="line"></span><br><span class="line">    *p = <span class="number">0</span>; <span class="comment">//a3</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Spin(<span class="number">1</span>);</span><br><span class="line">        *p = *p + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;(%d) p: %d\n&quot;</span>, getpid(), *p); <span class="comment">// a4</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序的输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">farmer:~/studys/operating-systems/ch02$ ./mem </span><br><span class="line">(208544) memory address of p: 18afa2a0</span><br><span class="line">(208544) p: 1</span><br><span class="line">(208544) p: 2</span><br><span class="line">(208544) p: 3</span><br><span class="line">(208544) p: 4</span><br><span class="line">(208544) p: 5</span><br><span class="line">^C</span><br></pre></td></tr></table></figure><p>这个demo首先为 p 这个变量分配了一些内存（a1行）。然后打印出内存的地址（a2），然后将数字0放入新分配的内存（a3）的第一个空位中。最后程序循环，延迟一秒钟并递增 p 中保存的地址值。在每个打印语句中，它还会打印出正在运行程序的进程标识符（PID）。</p><p>同样的，我们再次运行多个实例来看看会发生什么：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">farmer:~/studys/operating-systems/ch02$ ./mem &amp; ./mem &amp;</span><br><span class="line">[1] 24113</span><br><span class="line">[2] 24114</span><br><span class="line">(24113) memory address of p: 00200000</span><br><span class="line">(24114) memory address of p: 00200000</span><br><span class="line">(24113) p: 1</span><br><span class="line">(24114) p: 1</span><br><span class="line">(24114) p: 2</span><br><span class="line">(24113) p: 2</span><br><span class="line">(24113) p: 3</span><br><span class="line">(24114) p: 3</span><br><span class="line">(24113) p: 4</span><br><span class="line">(24114) p: 4</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>我们可以看到每个实例都在相同的地址（00200000）分配了内存，但每个似乎都独立更新了00200000处的值！就好像每个正在运行的程序都有自己的私有地址，而不是与其他正在运行的程序共享相同的物理内存。</p><p>而这真是操作系统虚拟化内存（virtualizing memory）时发生的情况，每个进程访问自己的私有虚拟地址空间（virtual address space）（有时称为地址空间，address space），操作系统以某种方式映射到机器的物理内存上，让正在运行的实例完全拥有自己的物理内存。</p><p>但实际情况是，物理内存是由操作系统管理的共享资源。而这也正是上文提到的「虚拟化」的内容。</p><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>并发是这本书的第二个部分，并发只是一个用来代指「<strong>同时处理很多事情</strong>」所带来一系列问题的代词，而这些问题是在同时（并发）处理很多事情时出现且必须解决的。</p><p>那么为什么并发通常出现在《操作系统》这门课中呢？其实是因为并发问题首先出现在操作系统中，而随着软件工程的发展，现代多线程（multi-threaded）程序也存在相同的问题。我们来看一个具体的多线程例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common_threads.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> loops;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">worker</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; loops; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123; </span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: threads &lt;loops&gt;\n&quot;</span>); </span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    loops = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">pthread_t</span> p1, p2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Initial value : %d\n&quot;</span>, counter);</span><br><span class="line">    Pthread_create(&amp;p1, <span class="literal">NULL</span>, worker, <span class="literal">NULL</span>); </span><br><span class="line">    Pthread_create(&amp;p2, <span class="literal">NULL</span>, worker, <span class="literal">NULL</span>);</span><br><span class="line">    Pthread_join(p1, <span class="literal">NULL</span>);</span><br><span class="line">    Pthread_join(p2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Final value   : %d\n&quot;</span>, counter);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子中利用<code>Pthread_create()</code>创建了两个线程（thread），每个线程开始在一个名为<code>worker()</code>的函数中运行，该函数中只是递增一个计数器，循环 loops 次。</p><p>下面是将变量loops的输入值设置为 1000 时的输出结果，根据代码我们可以很容易的猜到运行结果是 2000，因为每个线程会循环 1000 次并对计数器做一个累加的操作。也就是说当输入为 N 时，直观的预计结果为 2N：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">farmer:~/studys/operating-systems/ch02$ ./thread 1000</span><br><span class="line">Initial value : 0</span><br><span class="line">Final value   : 2000</span><br></pre></td></tr></table></figure><p>但如果对并发编程有点了解的话会发现这段代码中存在一个问题：计数器累加操作并非原子方式（atomically）的。让我们运行相同的程序，但 loops 的值更高，然后看看会发生什么：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">farmer:~/studys/operating-systems/ch02$ ./thread 100000</span><br><span class="line">Initial value : 0</span><br><span class="line">Final value   : 100000</span><br><span class="line">farmer:~/studys/operating-systems/ch02$ ./thread 100000</span><br><span class="line">Initial value : 0</span><br><span class="line">Final value   : 105018</span><br><span class="line">farmer:~/studys/operating-systems/ch02$ ./thread 100000</span><br><span class="line">Initial value : 0</span><br><span class="line">Final value   : 135669</span><br></pre></td></tr></table></figure><p>事实证明当我们将 loops 值设置的更高后，得到的最终值不是 200000。并且其最终值在每次运行中都是不一样的结果！</p><p>这些奇怪的，不合常理的结果与指令如何执行有关。上面程序中的关键部分是增加共享计数器（counter）的地方，它需要 3 条指令：一是将计数器的值翀内存中加载到寄存器，二是将其做递增操作，三是将其保存回内存。因为这三条指令并不是以原子的方式执行（所有的指令一次性执行）的，所以才会导致这些奇怪的事情发生。而这种问题通常叫：并发（concurrency）问题</p><h2 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h2><p>我们都知道程序是运行在内存中的，如果发生断电或系统崩溃等情况，那么内存中的数据是容易丢失的。因为像 DRAM 这样的设备以易失（volatile）的方式存储数据，因此我们需要硬件和软件来持久化（persistently）的存储数据。这样的存储对于所有系统来说都十分重要，因为数据是无价的。</p><p>操作系统中管理硬盘的软件通常称为文件系统（file system）。因此它负责以可靠和高效的方式，将用户创建的任何文件（file）存储在系统的磁盘上。而不像 CPU 和内存一样需要操作系统提虚拟化，因为它是可以被多个程序所共有的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/tmp/file&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);</span><br><span class="line">    assert(fd &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(buffer, <span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> rc = write(fd, buffer, <span class="built_in">strlen</span>(buffer));</span><br><span class="line">    assert(rc == (<span class="built_in">strlen</span>(buffer)));</span><br><span class="line">    fsync(fd);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的程序向操作系统发出了 3 个调用。一是 <code>open()</code> 调用，用来创建并打开一个文件。第二个是 <code>write()</code> 调用，将一些数据(「hello world\n」这串字符) 写入文件。第三则是 <code>close()</code> 调用来关闭文件，从而表明程序不会再向该文件写入更多的数据。</p><p>而上面提到的这些系统调用（system call）会被转到称为文件系统的操作系统部分，然后由文件系统处理这些请求，并向用户返回某种代码来表示结果。</p><p>首先确定新数据将驻留在磁盘上的哪个位置，然后在文件系统所维护的各种结构中对其进行记录。这样做需要向底层存储设备发出 I&#x2F;O 请求，以读取现有结构或更新（写入）它们。所有写过设备驱动程序（device driver）的人都知道，让设备现表你执行某项操作是一个复杂而详细的过程。它需要深入了解低级别设备接口及其确切的语义。幸运的是，操作系统提供了一种通过系统调用来访问设备的标准和简单的方法。因此，OS 有时被视为标准库（standard library）。</p><p>出于性能方面的原因，大多数文件系统首先会<code>延迟</code>这些写操作一段时间，希望将其<code>批量分组</code>为较大的组。为了处理写入期间系统崩溃的问题，大多数文件系统都包含某种复杂的写入协议，如日志（journaling）或写时复制（copy-on-write），仔细<code>排序</code>写入磁盘的操作，以确保如果在写入序列期间发生故障，系统可以在之后恢复到合理的状态。为了使不同的通用操作更高效，文件系统采用了许多不同的数据结构和访问方法，从简单的列表到复杂的 <code>B 树</code>。</p><h2 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h2><p>设计目标指的是「开发和设计操作系统时所设定的主要目标和原则」，或者说是操作系统的一些基本设计原则。</p><ol><li><strong>一个最基本的目标，是建立一些抽象（abstraction）</strong>，让系统方便和易于使用。抽象对我们在计算机科学中做的每件事都很有帮助。抽象使得编写一个大型程序成为可能，将其划分为小而且容易理解的部分</li><li><strong>设计和实现操作系统的第二个目标，是提供高性能（performance）</strong>。换言之，我们的目标是<code>最小化</code>操作系统的<code>开销</code>（minimize the overhead）。但是虚拟化的设计是为了易于使用，无形之中会增大开销，比如虚拟页的切换，cpu 的调度等等，所以尽可能的保持易用性与性能的平衡至关重要</li><li><strong>在应用程序之间以及在 OS 和应用程序之间提供保护（protection）</strong>。因为我们希望让许多程序同时运行，所以要确保一个程序的恶意或偶然的不良行为不会损害其他程序。保护是操作系统基本原理之一的核心，这就是<code>隔离</code>（isolation）。让进程彼此隔离是保护的关键，因此决定了 OS 必须执行的大部分任务</li><li><strong>操作系统往往力求提供高度的可靠性（reliability）</strong>。因为操作系统必须不间断运行，当它失效时，系统上运行的所有应用程序也会失效。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章节主要用于对操作系统全貌的一个介绍，回答了：“操作系统是什么” 的问题。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://pages.cs.wisc.edu/~remzi/OSTEP/Chinese/">《Operating Systems: Three Easy Pieces》中文版</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本系列文章将按照《Operating Systems: Three Easy Pieces》一书的章节顺序编写，结合原文与自己的感悟，以作笔记之用，如有不足之处，恳请在评论区指出&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;操作系统主要的三个部分分别</summary>
      
    
    
    
    <category term="操作系统" scheme="https://blog.farmer233.top/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="C语言" scheme="https://blog.farmer233.top/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="操作系统" scheme="https://blog.farmer233.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>MySQL的存储与索引(InnoDB)</title>
    <link href="https://blog.farmer233.top/2023/09/27/MySQL%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E7%B4%A2%E5%BC%95/"/>
    <id>https://blog.farmer233.top/2023/09/27/MySQL%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E7%B4%A2%E5%BC%95/</id>
    <published>2023-09-27T07:42:31.000Z</published>
    <updated>2023-11-12T17:26:19.918Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL 是当下一款主流的关系型数据库，它所有的数据均以磁盘文件的方式存储。在日常开发中我们都会听到许多为了加快 SQL 查询的效率而添加索引，同时许多文档也都会告诉我们要添加太多的索引， 索引不要太长， 使用数字或者空字符串来代替 NULL 等等的许多建议。那么为什么会有这些建议？这些建议又是否正确？这些答案都能从MySQL数据的物理存储方式中找到。</p><h2 id="一行记录的存储格式"><a href="#一行记录的存储格式" class="headerlink" title="一行记录的存储格式"></a>一行记录的存储格式</h2><p>我们执行 SQl 的时候，查询的结果是一行行的格式返回的.因此在讲解索引、数据页前我们先来看一下 MySQL 中一行记录是怎么存储的：</p><img src="/2023/09/27/MySQL%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E7%B4%A2%E5%BC%95/record.png" class="" title="一行记录的存储格式"><p>在上图中我们可以看到,一条完整的记录分为「记录头」与「真实数据」两部份，下面展开看看记录头的部份：</p><!-- **1. 变长字段长度**我们知道 MySQL 支持一些变长的数据类型，比如 TEXT、VARCHAR 等等。这些类型的字段存储多少字节的数据是不固定的，所以我们在存储数据的时候把长度记录下来，这样后续读取的时候才知道读哪些内容**2. NULL 值列表**在一条记录中某些列是可以存放 NULL 值的，如果把这些 NULL 值都放到真实数据部份中存储会很占地方，所以我们把 NULL 的列统一管理起来 --><p><strong>1. 记录头信息</strong><br>我们知道 MySQL 支持一些变长的数据类型与NULL值，比如 TEXT、VARCHAR 等等。这些类型的字段存储多少字节的数据是不固定的，所以我们在存储数据的时候把对应信息存储下来方便后续读取。因为该部份对本文影响不大，因此没有展开。</p><p><strong>2. next_record 字段</strong><br>在记录头中这个显眼的「next_record」字段相信已经引起了你的注意，正如其字面意思，该字段表示的是当前记录与一下条记录的<strong>偏移量</strong>。换一个说法就是，该字段是一个<strong>指向下一条记录的指针</strong>。</p><p>所以我们可以看到，在 InnoDB 中所有的数据就是通过该字段串起来成了一个单链表。而 MySQL 优化手段也是基于此进行改造的。</p><blockquote><p>上图是我经过简化后的示意图，我把一些与本篇无关的内容隐藏掉了，仅保留了比较关键的内容</p></blockquote><h2 id="InnoDB数据页"><a href="#InnoDB数据页" class="headerlink" title="InnoDB数据页"></a>InnoDB数据页</h2><p>页是 InnoDB 管理存储空间的基本单位，一个页的大小一般是 16k。数据页中则存放着我们上面提到的一行行记录，现在我们知道记录之间是通过 <code>next_record</code> 字段串联形成一个单向链表。那么在一个数据页中要查找某条记录该怎么办呢？</p><p>最笨的办法是从第一条记录开始遍历一遍链表，那么第一条记录我们怎么知道是哪条呢？以及当数据很多时，遍历一遍的时间也是无法忽视的，MySQL是怎么优化的？下面我们来看一下 MySQL 中数据页的格式，如下图：</p><img src="/2023/09/27/MySQL%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E7%B4%A2%E5%BC%95/page.png" class="" title="数据页格式"><p>在上图中我们可以看到一个数据页中关键的几个东西：</p><ol><li>页号：页号是唯一的，如同身份证号码一样，InnoDB 通过页号来唯一定位一个页</li><li>最小记录&#x2F;最大记录：页面中的最小记录和最大记录，用于指向真实数据记录，相当于真实记录链表的头尾哨兵</li><li>槽（slot）：页目录，用于快速定位页面中的记录，加速查找过程（通过二分查找）。<ol><li>将所有正常的记录（包括最大&#x2F;最小记录）划分为几个组，一个组对应槽中的一位（对应图中黄色范围）</li><li>每组记录的最后一条记录中的记录头中会有一个 <code>n_owned</code> 属性表示该组内共有几条记录</li><li>将每个组中最后一条记录在页面中的偏移量单独提取出来（就是槽中的每一位均指向每组记录中最大的那条记录）</li></ol></li></ol><h3 id="页目录（槽）"><a href="#页目录（槽）" class="headerlink" title="页目录（槽）"></a>页目录（槽）</h3><p>比如现在图中有5条记录，InnoDB 会把他们分成2个组，第一组只有一个「最小记录」（也就是头哨兵），第二组则是剩余的4条记录，一共两个组。因此对应着2个槽，每个槽中存放每个组中最大的那条记录在页面中的地址偏移量（即指向最大记录的指针）。每个分组中的记录条数都有规定，规定如下：</p><ol><li>最小记录（头哨兵）所在的分组只能有一条记录</li><li>最大记录（尾哨兵）所在的分组拥有的记录数只能在1～8条之间</li><li>剩余的分组中记录的条数范围为4～8条之间</li></ol><p>所以初始情况下只有最小&#x2F;大记录，因此页目录（槽）中只有两个组。之后每插入一条记录，都会从页目录上找到对应记录的主键值比准备插入的主键值大，且差值最小（为了让主键顺序排列-从小到大）的槽，然后把该槽的 <code>n_owned</code> 值加一，表示添加了一条记录，直到该组记录中的记录数等于8个。8个后再插入则不满足第二条规则，因此会产生新的一个组，并将原有记录进行迁移，使得满足三条规则。</p><h3 id="在数据页中定位记录"><a href="#在数据页中定位记录" class="headerlink" title="在数据页中定位记录"></a>在数据页中定位记录</h3><p>当前页面中记录太少，不好演示页目录如何加快查找速度的，为此我们往页面添加几条记录，添加后的数据页如下（为了清晰的展示槽与组之间的关系，我将记录之间的指针隐藏了，详细看上一张图片）：</p><img src="/2023/09/27/MySQL%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E7%B4%A2%E5%BC%95/page_more_data.png" class="" title="更多数据的数据页"><p>因为记录的主键都是从小到大排列的，所以我们可以使用二分法快速查找记录，如图中所示一共有5个槽，接下来我们模拟一下在该表中找到「记录6」的过程：</p><ol><li>根据槽的信息，可以得到最低的槽 low &#x3D; 0，最高的槽 high&#x3D;4（也就是二分查找的初始边界）</li><li>计算中间槽的位置：(0+4)&#x2F;2 &#x3D; 2，查看槽2对应记录为8，又因为 8 &gt; 6，所以设置 high&#x3D;2, low 保持不变</li><li>重新计算中间槽的位置：(0+2)&#x2F;2 &#x3D; 1，查看槽1对应组最大记录的主键值为4；又因为 4 &lt; 6,所以设置 low&#x3D;1, high 保持不变</li><li>因为 high-low &#x3D; 1，所以确定主键值为6的记录在槽2对应的组中</li><li>此时我们只需从槽1的最大记录开始遍历每条记录（也就是从槽2的开头遍历），便能很快找到「记录6」了。</li></ol><p>上面我们已经介绍过，每个组中包含的记录条数最多是8条，所以遍历一个组中的记录代价是很小的。因此我们可以将上面的步骤再提炼一下，总结成在一个数据页中查找元素的步骤：</p><ol><li>在页目录中通过二分法确认记录所在的槽</li><li>通过记录的 <code>next_record</code> 属性遍历该槽所在的组中的各个记录</li></ol><p>至此，我们已经知道了如何在数据页中快速查找到一条记录，而将这一个个数据页连接起来便能是我们存储的所有数据了。那么如何才能高效的在这么多数据页中查找记录，接下来就轮到“索引同志”登场了。</p><h2 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h2><p>我们知道一个数据页的大小是 16K，而我们业务中一个表的数据动辄就上G，显然一个数据页是无法装下我们的数据的。那么在一个表中的数据页是怎么链接起来的？我们回到查询一条记录的语句上，要在这么多数据页中找到一条记录，最笨的方法便是遍历所有的数据页，那么为什么要遍历所有的数据页呢？我们不能有个聪明点的方法吗？原因是因为数据页之间是没有规律的，我们并不知道搜索调节会匹配哪些页的记录（因为没有规律，所有的数据页都有可能存在），因此不得不遍历所有数据页。</p><p>那么如何快速定位到记录在哪些数据页中？我们还记得在数据页里面为了快速定位一条记录，我们为页中的数据划分了组，并且为此建立了一个页目录（槽）。同样的我们也可以想办法为了「<strong>快速定位记录所在的页</strong>」而建立一个目录，在建立这个目录的过程中需要满足这几个条件（页与页之间的规定）：</p><ol><li>下一个数据页中「真实记录」的主键值必须大于上一个页中「真实记录」的主键值（叶子节点）</li><li>数据页之间通过前后指针相连</li><li>给所有页建立一个目录项（内节点）</li></ol><p>为此我们得到了一个简易版的索引方案，如下图：</p><img src="/2023/09/27/MySQL%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E7%B4%A2%E5%BC%95/simple_index.png" class="" title="简易索引"><p>为什么说这是简易版的索引呢？因为我们这么做的前提是假设了目录项是有连续的存储空间的，但实际并非如此，因此会引起下面的几个问题：</p><ol><li>InnoDB 使用页作为管理存储空间的基本单位，也就是只能保证16KB的连续存储空间</li><li>我们经常会对记录做增、删、改的操作，如果某个页中最后一条记录删除会导致该页被移除，为了紧凑设计会导致目录项中该页后面的所有记录都需要往前挪动</li></ol><p>为此我们需要一种更灵活的方式来管理目录项，我们不难发现目录项与「真实记录」长的很像，只不过目录项中的两个列是主键与页号而已，为此我们可以复用存储用户记录的数据页来存储目录项，我们把这些用来表示目录项的记录称为<strong>目录项记录</strong></p><p>那么我们把前面简易版本的索引方案修改后，便能得到下图所示的结构：</p><img src="/2023/09/27/MySQL%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E7%B4%A2%E5%BC%95/index.png" class="" title="索引结构"><p>以查找记录9为例子，我们来看看是如何通过目录项加快查询速度的：</p><ol><li>先到目录项记录所在的页（也就是页10）中通过二分法快速定位到对应的目录项记录，因为 1&lt; 9 &lt; 2，所以定位到对应的「真实记录」所在的页为页21</li><li>再到存储用户记录的页21中根据二分法快速定位到「记录9」</li></ol><p>虽然说目录页中只存放主键值与页号，比用户记录所需要的空间要小很多，但因为一个页只有16K大小，因此能存放的目录项也是有限的。如果表中的数据太多了导致目录页存放不下，那么便会重新分配一个目录页。目录页与目录页之间也通过上述的办法进行复用（利用目录页定位目录页），从而减少单次二分查找的数量，提高效率。在插入很多数据后，整个结构便像下图一样：</p><img src="/2023/09/27/MySQL%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E7%B4%A2%E5%BC%95/index_full.png" class="" title="B+树"><p>上图所示的便是许多文章中提到的 <strong>B+树</strong> 了，无论是存放用户记录的数据页，还是存放目录项的数据页，我们都把它们存放到B+树这个数据结构中。从上图中我们也可以看出，我们的<strong>「真实记录」其实都存放在B+树最底层的节点上</strong>（叶子节点）。其余用来存放目录项的节点为非叶子节点或内节点。</p><p>我们来简单的计算一下，假设<strong>叶子节点</strong>所代表的数据页可以存放 100 条用户记录，而<strong>内节点</strong>可以存放1000条记录，那么：</p><ol><li>如果该树有2层，则最多能存放 1000 x 100 &#x3D; 100000 条用户记录</li><li>如果该树有3层，最多能存放 1000 x 1000 x 100 &#x3D; 100,000,000 条用户记录</li><li>如果有4层，最多能存放 1000 x 1000 x 1000 x 100 &#x3D; 100,000,000,000 条记录</li></ol><p>所以在一般情况下，我们用到的B+树都不会超过3层。这样一来在通过主键去查找某条记录时，最多只需要进行4个页面内的查找（3个目录页与一个真实记录的页），又因为每个页中有<strong>页目录</strong>（槽），所以在页面内可以通过二分查找快速定位记录。因此我们可以看到这就是使用B+树查询高效的原因。</p><blockquote><p>这种根据主键ID构建的B+树，我们称为「<strong>聚簇索引</strong>」，这也引申出来了 InnoDB 中所谓的“索引即数据，数据即索引”。</p></blockquote><p>我们可以看到这里只有 ID 作为索引列，但我们平时使用的过程中还可以为其他列建立的索引，因此这就引申出<strong>二级索引</strong>与<strong>联合索引</strong>了。</p><h3 id="二级索引与联合索引"><a href="#二级索引与联合索引" class="headerlink" title="二级索引与联合索引"></a>二级索引与联合索引</h3><p>无论是二级索引亦或是联合索引，其实都是基于上面提到的聚簇索引而引申出来的。我们先来看看二级索引与聚簇索引的区别：</p><ol><li>聚簇索引是根据主键进行排序的，而我们刚刚提到无论是页面内还是页面之间都强调了一个<strong>有序（从小到大）</strong>的特性。因此二级索引也是需要进行排序的，但二级索引是根据<strong>索引列</strong>进行排序，排序的规则则是根据设置的字符集来排序</li><li>二级索引的叶子节点中只存放「索引列」与主键值，因此如果需要获取完整的记录，需要根据主键值到聚簇索引中查询（这个操作也叫回表）</li></ol><p>二级索引如下图所示：</p><img src="/2023/09/27/MySQL%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E7%B4%A2%E5%BC%95/sec_index.png" class="" title="二级索引"><p>我们除了可以使用某一列进行索引外，还可以同时为多个列建立索引，而多个列建立的索引则称为「<strong>联合索引</strong>」。许多文章都会提到<strong>最左匹配</strong>等概念，而这也是与我们联合索引的结构息息相关的，比如我们想让B+树按照A和B列的大小进行排序，这里面就包含了两层含义：</p><ol><li>先把各个记录和页按照A列进行排序（因为A在前面）</li><li>在A列相同的情况下，再根据B列进行排序</li></ol><p>该索引如下图所示：</p><img src="/2023/09/27/MySQL%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E7%B4%A2%E5%BC%95/cover_index.png" class="" title="联合索引"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在创建和使用索引时应该注意以下事项：</p><ol><li>只为用于搜索、排序或分组的列创建索引</li><li>当列中不重复值的个数在总记录数中占比很大时，才值得建立索引</li><li>索引列的类型要尽可能的小</li><li>可以只为索引列创建前缀索引，减少索引占用的空间</li><li>尽量覆盖索引进行查询，避免出现回表</li><li>为了减少让<strong>聚簇索引</strong>出现页分裂的情况，主键最好要自增</li></ol><!-- 本文简单粗略的介绍了 MySQL 数据库中 InnoDB 存储引擎的存储与索引结构，对该部份掌握的深浅决定了写出来的 SQL 是否高效、合理。这一年多的工作中可以说天天和 MySQL 打交道，在解决了几个线上慢SQL告警后才意思到要好好补补这方面的知识，希望这篇笔记能让大家对 InnoDB 的存储与索引有一个更清晰的认知吧🚀 -->]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;MySQL 是当下一款主流的关系型数据库，它所有的数据均以磁盘文件的方式存储。在日常开发中我们都会听到许多为了加快 SQL 查询的效率而添加索引，同时许多文档也都会告诉我们要添加太多的索引， 索引不要太长， 使用数字或者空字符串来代替 NULL 等等的许多建议。那么为什么会</summary>
      
    
    
    
    <category term="MySQL" scheme="https://blog.farmer233.top/categories/MySQL/"/>
    
    
    <category term="笔记" scheme="https://blog.farmer233.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MySQL" scheme="https://blog.farmer233.top/tags/MySQL/"/>
    
    <category term="数据库" scheme="https://blog.farmer233.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Go性能分析工具</title>
    <link href="https://blog.farmer233.top/2023/07/04/Go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/"/>
    <id>https://blog.farmer233.top/2023/07/04/Go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/</id>
    <published>2023-07-04T02:08:33.000Z</published>
    <updated>2023-11-12T17:26:19.890Z</updated>
    
    <content type="html"><![CDATA[<!-- ## 前言 --><p>对于 Golang 程序性能分析来说，pprof 一定是一个大杀器般的存在。主要可以分析 CPU、内存的使用情况、阻塞情况、Goroutine 的堆栈信息以及锁争用情况等性能问题。</p><p>pprof 是一个性能分析工具，Go 在语言层面就内置了 profile 采样工具。这会涉及到 <code>runtime/pprof</code> 与 <code>net/http/pprof</code> 这两个包。但本文着重于使用 pprof 来分析问题，故不讲解采样相关内容。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>以大家优秀的编码水平一般不会写出性能堪忧的程序，所以在此我们使用一个 GitHub 上开源的<a href="https://github.com/FarmerChillax/go-pprof-practice">项目</a>，这个项目预埋了许多炸弹代码。这个性能堪忧的“炸弹”可以有效的帮助我们观测到程序的性能问题。</p><blockquote><p>务必确保你是在个人机器上运行“炸弹”的，能接受机器死机重启的后果（虽然这发生的概率很低）。请你务必不要在危险的边缘试探，比如在线上服务器运行这个程序。</p></blockquote><h3 id="图形化依赖安装"><a href="#图形化依赖安装" class="headerlink" title="图形化依赖安装"></a>图形化依赖安装</h3><p>pprof 默认提供命令行的方式来查看各项数据，但命令行的方式显然不够直观。因此我们安装一个图形化的依赖（<a href="https://graphviz.gitlab.io/download/">graphviz</a>）来更直观的展示堆栈信息。</p><p>你可以在<a href="https://graphviz.gitlab.io/download/">官网</a>上寻找适合自己操作系统的安装方法，此外在下面这些系统上你可以通过包管理工具来安装它：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">brew install graphviz # macos</span><br><span class="line">apt install graphviz # ubuntu</span><br><span class="line">yum install graphviz # centos</span><br></pre></td></tr></table></figure><h3 id="获取炸弹-💣"><a href="#获取炸弹-💣" class="headerlink" title="获取炸弹 💣"></a>获取炸弹 💣</h3><p>该炸弹你可以通过 <code>git</code> 克隆下来，再按照一般的 Go 项目方式运行。为了演示的方便我这使用 <code>go get</code> 的方式展示，注意加上 <code>-d</code> 参数来避免自动安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go get -d github.com/FarmerChillax/go-pprof-practice</span><br><span class="line">cd $GOPATH/src/github.com/FarmerChillax/go-pprof-practice</span><br></pre></td></tr></table></figure><h2 id="指标查看"><a href="#指标查看" class="headerlink" title="指标查看"></a>指标查看</h2><p>保持程序的运行，然后打开浏览器访问 <code>http://127.0.0.1:6060/debug/pprof/</code>，可以看到如下页面：</p><!-- ![pprof_web](./pprof_web.jpg) --><img src="/2023/07/04/Go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/pprof_web.jpg" class="" title="pprof web"><p>页面上展示了程序运行采样数据，分别有：</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>allocs</td><td>内存分配情况的采样信息</td></tr><tr><td>blocks</td><td>阻塞操作情况的采样信息</td></tr><tr><td>cmdline</td><td>显示程序启动命令及参数</td></tr><tr><td>goroutine</td><td>当前所有协程的堆栈信息</td></tr><tr><td>heap</td><td>堆上内存使用情况的采样信息</td></tr><tr><td>mutex</td><td>锁争用情况的采样信息</td></tr><tr><td>profile</td><td>CPU 占用情况的采样信息</td></tr><tr><td>threadcreate</td><td>系统线程创建情况的采样信息</td></tr><tr><td>trace</td><td>程序运行跟踪信息</td></tr></tbody></table><p>由于直接阅读采样信息缺乏直观性，我们需要借助 <code>go tool pprof</code> 命令来排查问题，这个命令是 go 原生自带的，所以不用额外安装。</p><h2 id="CPU-占用过高"><a href="#CPU-占用过高" class="headerlink" title="CPU 占用过高"></a>CPU 占用过高</h2><p>首先看一下 CPU 的运行情况，打开管理器可以看到此项目在我电脑上占用了 <code>63.3%</code> 的 CPU。</p><img src="/2023/07/04/Go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/cpu_pre.jpg" class="" title="cpu_pre"><p>这显然是有问题的，我们使用 <code>go tool pprof</code> 来采集 10 秒 CPU 数据排查下问题：</p><p><code>go tool pprof &quot;http://localhost:6060/debug/pprof/profile?seconds=10&quot;</code></p><blockquote><p>因为我们这里采集的是 profile 类型，因此需要等待一定的时间来对 CPU 做采样。你可以通过查询字符串中 seconds 参数来调节采样时间的长短（单位为秒）</p></blockquote><p>等待一会儿后，会进入一个交互式终端：</p><img src="/2023/07/04/Go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/cpu_terminal.jpg" class="" title="cpu_terminal"><p>输入 <code>top</code> 命令，查看 CPU 占用较高的调用：</p><img src="/2023/07/04/Go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/cpu_top.jpg" class="" title="cpu top"><p><strong>参数说明：</strong></p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>flat</td><td>当前函数本身的执行耗时</td></tr><tr><td>flat%</td><td>flat 占 CPU 总时间的比例</td></tr><tr><td>sum%</td><td>上面每一行的 flat% 总和</td></tr><tr><td>cum</td><td>当前函数本身加上其周期函数的总耗时</td></tr><tr><td>cum%</td><td>cum 占 CPU 总时间的比例</td></tr></tbody></table><p>很明显 <code>Eat</code> 方法是造成 CPU 占用过高的原因，输入 <code>list Eat</code>，查看问题具体在代码的哪一个位置：</p><img src="/2023/07/04/Go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/list_eat.jpg" class="" title="list eat"><p>从输出结果里可以看到对应的文件为 <code>animal/felidae/tiger/tiger.go</code>，而且具体的代码行为 24 行的一百亿次 for 循环导致的。</p><p>还记得我们一开始安装的 graphviz 图形依赖吗？在安装这个工具后，我们可以通过 <code>web</code> 命令来生成一个可视化的页面：</p><img src="/2023/07/04/Go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/cpu_web.jpg" class="" title="cpu web"><blockquote><p>注意，虽然这个命令叫 web，但它实际上是生成一个 <code>.svg</code> 文件，并调用系统默认打开它。如果你的系统打开 <code>.svg</code> 默认不是浏览器，这时候你需要设置下默认使用浏览器打开，或者使用你喜欢的查看方式来查看 svg 文件</p></blockquote><p>上图中，<code>Eat</code> 函数的框特别大，箭头特别粗，就是代表这个函数的 CPU 占用很高（pprof 生怕你不知道.jpg）。到这为止我们已经发现了 cpu 占用过高的原因了，我们修复下这个问题：</p><img src="/2023/07/04/Go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/fix_cpu.jpg" class="" title="fix cpu"><img src="/2023/07/04/Go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/cpu_result.jpg" class="" title="fix cpu result"><h2 id="内存占用过高（Heap）"><a href="#内存占用过高（Heap）" class="headerlink" title="内存占用过高（Heap）"></a>内存占用过高（Heap）</h2><p>经过改造，可以发现CPU的问题已经解决了，但是内存使用还是很高，我们需要继续排查内存问题。</p><img src="/2023/07/04/Go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/heap_pre.jpg" class="" title="pre mark heap"><p>上面我们介绍了命令行与 web 页面两种方式，因为 web 页面可视化的方式排查比较直观，因此命令行排查的方式就不再展开了，输入以下命令可以看到堆内存的占用情况：</p><p><code>go tool pprof -http=:8080 &quot;http://localhost:6060/debug/pprof/heap&quot;</code></p><blockquote><p>这个命令中 http 选项将会启动一个 web 服务器并自动打开网页。其值为 web 服务器的 endpoint</p></blockquote><img src="/2023/07/04/Go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/heap_web.jpg" class="" title="heap web"><p>从上图我们可以看出 <code>Mouse</code> 这个对象的 <code>Steal</code> 方法占用的内存最多，然后我们点击 <code>view</code> -&gt; <code>source</code> 还可以查看到具体的代码文件及其行数：</p><img src="/2023/07/04/Go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/heap_source.jpg" class="" title="heap source"><p>采样说明，<code>SAMPLE</code> 菜单中有几个选项，对应说明如下：</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>alloc_objects</td><td>程序累计申请的对象数</td></tr><tr><td>alloc_space</td><td>程序累计申请的内存大小</td></tr><tr><td>inuse_objects</td><td>程序当前持有的对象数</td></tr><tr><td>inuse_space</td><td>程序当前占用的内存大小</td></tr></tbody></table><p>从代码中可以看到这么高的内存占用是因为会一直向 m.buffer 里追加长度为 1 MiB 的数组，直到总容量到达 1 GiB 为止，因此我们注释掉相关代码来解决这个问题。<br>再次编译运行，查看内存占用：</p><img src="/2023/07/04/Go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/heap_result.jpg" class="" title="heap result"><blockquote><p>如果你发现程序运行时间长后，内存还是会升高。请不用担心，这是因为后面用于模拟内存泄漏的炸弹</p></blockquote><h2 id="协程（Goroutine）"><a href="#协程（Goroutine）" class="headerlink" title="协程（Goroutine）"></a>协程（Goroutine）</h2><p>虽然 Go 是带 GC 的，一般不会发生内存泄漏。但凡事都有例外，<code>goroutine</code> 泄露也会导致内存泄露。我们在浏览器 debug 页面能看到此时程序的协程数有 106 条，虽然 106 不多，但对这样一个小程序来说显然是不正常的。</p><img src="/2023/07/04/Go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/goroutine_count_pre.jpg" class="" title="goroutine pre"><p>我们仍然以可视化的方式来排查这个问题，输入以下命令查看堆内存占用情况：</p><p><code>go tool pprof -http=:8080 &quot;http://localhost:6060/debug/pprof/goroutine&quot;</code></p><p><code>Graph</code> 类型我们在上面已经介绍过了方块与箭头的关系，相信你也一定能理解这里的关系。那么我们这次来看看 <code>Flame Graph</code> 类型，点击 <code>view</code> -&gt; <code>Flame Graph</code>：</p><img src="/2023/07/04/Go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/goroutine_web.jpg" class="" title="goroutine web"><p>我们在火焰图中可以看到 <code>wolf.(*Wolf).Drink.func1</code> 这个函数占了总 goroutine 数量的 95%，我们还是像排查内存一样切换的 <code>source</code> 页面，查看代码具体位置：</p><img src="/2023/07/04/Go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/goroutine_source.jpg" class="" title="goroutine source"><p>可以看到，Drink 方法每次会起 10 个协程，每个协程会 sleep 30 秒再推出，而 Drink 函数又被反复的调用，这才导致了大量的协程泄漏。试想一下，如果我们业务中起的协程会永久阻塞，那么泄漏的协程数量便会持续增加，从而导致内存的持续增加，那么迟早会被 OS Kill 掉。我们通过注释掉问题代码，重新运行可以看到协程数量已经降低到个位数的水平了。</p><h2 id="Mutex（锁）"><a href="#Mutex（锁）" class="headerlink" title="Mutex（锁）"></a>Mutex（锁）</h2><p>如果你跟着本文一步步走下来，到此为止我们可以说已经完成了拆蛋的工作了，这个程序的所有资源占用问题已经解决了。但日常业务中排查问题除了资源占用问题外，还有性能问题。</p><p>接下来我们进一步排查性能问题，首先能想到的便是<strong>不合理的锁争用</strong>的问题，比如加锁时间太长等等。我们重新看一下 debug 页面，虽然协程数量已经大幅度降低，但还显示有一个 <code>mutex</code> 争用问题：</p><img src="/2023/07/04/Go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/mutex_pre.jpg" class="" title="goroutine source"><p>相信看到这里你已经触类旁通了，通过 Graph 查看问题出现的函数，然后通过 <code>source</code> 定位具体的代码。还是和之前一样，打开可视化页面：</p><p><code>go tool pprof -http=:8080 http://localhost:6060/debug/pprof/mutex</code></p><img src="/2023/07/04/Go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/mutex_pre_web.jpg" class="" title="mutex web"><img src="/2023/07/04/Go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/mutex_source.jpg" class="" title="mutex source"><p>可以看到，这个锁由主协程 Lock，并启动子协程去 Unlock，主协程会阻塞在第二次 Lock 这里等待子协程完成任务，但由于子协程足足睡眠了一秒，导致主协程等待这个锁释放足足等了一秒钟。我们对此处代码进行修改即可修复问题。</p><h2 id="Block（阻塞）"><a href="#Block（阻塞）" class="headerlink" title="Block（阻塞）"></a>Block（阻塞）</h2><p>在程序中除了锁的竞争会导致阻塞外，还有很多逻辑会导致阻塞。我们继续看 debug 页面会发现，这里仍有 2 个阻塞的操作：</p><img src="/2023/07/04/Go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/block_pre.jpg" class="" title="block pre mark"><p>阻塞不一定是有问题的，但为了保证程序的性能，我们还是要排查一下。还是上面的那三板斧：</p><p><code>go tool pprof -http=:8080 http://localhost:6060/debug/pprof/block</code></p><img src="/2023/07/04/Go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/block_web.jpg" class="" title="block web graph"><img src="/2023/07/04/Go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/block_source.jpg" class="" title="block source"><p>可以看到这里不同于直接 sleep 一秒，这里是从一个 channel 里读数据时，发生了阻塞。直到这个 channel 在一秒后才有数据读出，因此这里会导致程序阻塞，而不是睡眠。<br>我们对此代码注释掉，重新编译运行后发现程序还有一个 block。通过排查分析后我们发现是因为程序提供了 HTTP 的 pprof 服务，程序阻塞在对 HTTP 端口的监听上，因此这个阻塞是正常的。</p><h2 id="基准比对的排查方式"><a href="#基准比对的排查方式" class="headerlink" title="基准比对的排查方式"></a>基准比对的排查方式</h2><p>pprof 中有一个 <code>-base</code> 选项，它用于指定基准采样文件，这样可以通过比较两个采样数据，从而查看到指标的变化，例如函数的 CPU 使用时间或内存分配情况。</p><p>举个具体的例子，在业务中有一个低频调用的接口存在内存泄漏（OOM），它每被调用一就会泄漏 1MiB 的内存。这个接口每天被调用10次。假设我们给这个服务分配了 100Mi 空余的内存，也就是说这个接口基本上每十天就会挂一次，但当我们排查问题的时候，会发现内存是缓慢增长的。此时如果你仅通过 pprof 采样单个文件来观察，基本上很难会发现泄漏点。</p><p>这时候 <code>base</code> 选项就派上用场了，我们可以在服务启动后采集一个基准样本，过几天后再采集一次。通过比对这两个样本增量数据，我们就很容易发现出泄漏点。</p><p>同样的，这个炸弹我也已经预埋了这样一个缓慢的泄漏点，但时间我缩短了一下。相信在上面的实操过程中你也发现了端倪，下面我们开始实操一下。</p><p>我们运行这个炸弹程序，将启动时的堆内存分配情况保存下来，你可以在 debug 页面点击下载，也可以在终端中执行 <code>curl -o heap-base http://localhost:6060/debug/pprof/heap</code> 来下载。</p><p>在资源管理器中我们可以看到程序刚启动的时候，内存占用并不高：</p><img src="/2023/07/04/Go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/base_pre.jpg" class="" title="base pre"><p>在程序运行了半分钟后，我们可以清楚的发现程序内存开始逐渐增长：</p><img src="/2023/07/04/Go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/base_pre_target.jpg" class="" title="base pre target"><p>此时我们再执行 <code>curl -o heap-target http://localhost:6060/debug/pprof/heap</code> 获取到当前的采样数据。</p><blockquote><p>在 debug 页面中直接点击 heap 链接会打开一个新的页面，你可以通过删除该页面 URL 中的 debug&#x3D;1 这个查询字符串来下载数据文件</p></blockquote><p>再获取到两个样本数据后，我们通过 <code>base</code> 选项将 <code>heap-base</code> 作为基准，查看运行的这段时间内哪里内存增长了</p><p><code>go tool pprof -http=:8080 -base heap-base heap-target</code></p><img src="/2023/07/04/Go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/base_web.jpg" class="" title="base web compare"><p>显然在这段时间中 <code>mouse</code> 的 <code>Pee</code> 方法增长了 1.20GB，显然这就是内存泄漏的地方，接下来还是通过那三板斧来定位出问题的代码，然后注释修复：</p><img src="/2023/07/04/Go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/base_source.jpg" class="" title="base source"><p>这里主要展示了如果通过 <code>base</code> 参数比对两个 pprof 采样文件，从而提高我们排查问题的效率。</p><blockquote><p>在 Graph 页面你可能会发现有一些绿色框框存在，机智的你肯定也能猜到绿色框框代表的就是减少的使用量</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要内容为 pprof 工具的使用，介绍了通过命令行、可视化等方式进行排查。虽然例子比较简单，但是相信通过这些简单的例子可以让你不在畏惧 pprof。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://blog.wolfogre.com/posts/go-ppof-practice/">golang pprof 实战</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- ## 前言 --&gt;

&lt;p&gt;对于 Golang 程序性能分析来说，pprof 一定是一个大杀器般的存在。主要可以分析 CPU、内存的使用情况、阻塞情况、Goroutine 的堆栈信息以及锁争用情况等性能问题。&lt;/p&gt;
&lt;p&gt;pprof 是一个性能分析工具，Go 在语言层</summary>
      
    
    
    
    <category term="学了些什么" scheme="https://blog.farmer233.top/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="Golang" scheme="https://blog.farmer233.top/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>生，活</title>
    <link href="https://blog.farmer233.top/2022/03/15/%E7%94%9F%EF%BC%8C%E6%B4%BB/"/>
    <id>https://blog.farmer233.top/2022/03/15/%E7%94%9F%EF%BC%8C%E6%B4%BB/</id>
    <published>2022-03-15T08:27:37.000Z</published>
    <updated>2023-11-12T17:26:19.950Z</updated>
    
    <content type="html"><![CDATA[<p>晃眼间大半年的休闲时光过去了，平淡而消沉地惶惶不可终日。混吃等死四年多，有可能即将面对人生的又一次十字路口，思量再三，发现终归是凡夫俗子一介草民，个人的选择终究会湮没在历史的进程中，索性随波逐流，逃离现场，美其名曰无欲无求，人各有志。</p><p>越来越多的故人失去联系，仅能从偶尔的一条朋友圈窥得一丝身影，惊然发现竟恍如隔世，不知不觉间发现自己正一步步的走向荒原、孤冢。愈发感觉到天机命途，不由我定，唯一能做的就是活着，好好的活着而已。</p><p>生活生活，先生后活。如此生活，别人与我，自有期望。</p><h2 id="不要败给生活"><a href="#不要败给生活" class="headerlink" title="不要败给生活"></a>不要败给生活</h2><p>我相信，慢慢我什么都会有的。</p><p>我会有很多懂我又不懂我的朋友，我会有很多不同姓的家人，我会见到很多风景，也会明白冷暖自知的人间苦楚。我有我的快乐、烦恼，我一步一步地走。</p><p>许久之后，我再回望我的青春时光，那样地生活过。他的身影印在这个城市里，我看见了他那时的理想和热血再一刻不停地催促着他向前走去。</p><h2 id="朝悟道，夕死可矣"><a href="#朝悟道，夕死可矣" class="headerlink" title="朝悟道，夕死可矣"></a>朝悟道，夕死可矣</h2><p>少年心气，已经深刻地认识到了我们自身的平庸，却依然在等待着生活中的诸多无意义。我在路上，不知是在企图逃离现实所赋予我的诸多责任，还是尝试寻找自己所信奉的东西。</p><p>我们这一代人，如此开放却又狭隘，精神如此丰富又贫瘠，如此乐观又封闭，如此喧嚣却又静寂。我们这群寂寞的人类都在忙着说话、交流、呐喊，然后在现实到来的那一刹那成长。我们眼界开阔，却又因为各种价值观，社会压力中被压得踹不过气来。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;晃眼间大半年的休闲时光过去了，平淡而消沉地惶惶不可终日。混吃等死四年多，有可能即将面对人生的又一次十字路口，思量再三，发现终归是凡夫俗子一介草民，个人的选择终究会湮没在历史的进程中，索性随波逐流，逃离现场，美其名曰无欲无求，人各有志。&lt;/p&gt;
&lt;p&gt;越来越多的故人失去联系，</summary>
      
    
    
    
    <category term="胡思乱语" scheme="https://blog.farmer233.top/categories/%E8%83%A1%E6%80%9D%E4%B9%B1%E8%AF%AD/"/>
    
    
    <category term="胡言乱语" scheme="https://blog.farmer233.top/tags/%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD/"/>
    
    <category term="emotion" scheme="https://blog.farmer233.top/tags/emotion/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你用APIFlask做毕业设计后端—基本简介与Hello APIFlask!(一)</title>
    <link href="https://blog.farmer233.top/2022/03/09/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E7%94%A8APIFlask%E5%81%9A%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94%E5%90%8E%E7%AB%AF/"/>
    <id>https://blog.farmer233.top/2022/03/09/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E7%94%A8APIFlask%E5%81%9A%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94%E5%90%8E%E7%AB%AF/</id>
    <published>2022-03-09T11:52:49.000Z</published>
    <updated>2023-11-12T17:26:19.942Z</updated>
    
    <content type="html"><![CDATA[<!-- **『注：本文更新于2022年3月15日』** --><blockquote><p>本文项目对应地存储库: <a href="https://github.com/Farmer-chong/HelloAPIFlask">https://github.com/Farmer-chong/HelloAPIFlask</a></p></blockquote><p>最近正值毕业阶段，相信许多人的毕业设计都无不例外的选择了Web相关的内容，毕竟这个比较容易实现。我发现许多人都出于从众心理无不例外的使用了Spring全家桶，Spring有着很庞大的生态、久远的历史以及很丰富的社区资料，这使得它被许多从业者使用。但也正是这些优势导致它对新手或者快速上手开发变得十分不好，再加之国内的毒瘤技术社区等原因，使得一个小问题往往需要花费大量的时间来排除错误的答案。</p><p>相比于繁重、学习成本较高的Spring，Flask其简单的语法可以是我们快速的上手完成(应对)毕设这一类学业任务, 因此本文仅停留在 <strong>能用</strong> 阶段, 更多底层原理需要读者自行了解(这里推荐一下李大的狗书<a href="https://helloflask.com/book/1/">《Flask Web 开发实战 》</a>) 另外出于为社区做贡献等情怀原因也是写这一系列的初衷。</p><h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><ol><li><a href="./">后端系列: 基本简介与Hello APIFlask! (一)</a><!-- 2.  --></li></ol><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><blockquote><p>本文默认使用Windows进行开发，Linux&#x2F;macOS会特别说明</p></blockquote><blockquote><p>相比于传统的后端渲染模板架构，本文采用目前主流的前后端分离结构</p></blockquote><p>对于前后端分离，服务端只需要提供API接口来处理请求。简单的来说就是前端不再局限于浏览器，还可以是app、小程序亦或者是爬虫程序。对后端而言，我们不再渲染html返回给前端，而是与前端共同约定一个数据格式进行交互。</p><p>如果读者的思想还停留在具体的浏览器中，那需要读者打开思维的局限来理解。无论是传统的后端渲染还是前后端分离，其本质都是操作 <strong>HTTP报文</strong> 。</p><blockquote><p>许多人此时会有个疑问：为什么一会儿Flask一会APIFlask的，这两者有什么关系？</p></blockquote><p>先来简单的说一下，<code>Flask</code>是一个十分流行的 <strong>Python Web</strong> 框架。而<code>APIFlask</code>则是基于<code>Flask</code>框架针对 <strong>Web API</strong>开发的特点二次开发的框架，这是一个针对API而生的框架(或者具体点前后端分离)。如果读者有<code>Java</code>开发经验，可以理解类似于<code>Spring</code>与<code>Spring Boot</code>的关系。</p><p>扩展阅读: </p><ol><li><a href="https://greyli.com/hello-apiflask/">APIFlask是什么</a></li><li><a href="https://greyli.com/flask-fastapi/">Flask、APIFlask与其他Web框架之间的关系</a></li></ol><p><em>因为APIFlask是一个Flask的扩展补充框架，因此它大部分都是与Flask保持一致的，你甚至可以把APIFlask当成Flask来写(当然这并不推荐)。因此对Flask有经验的读者许多内容是可以跳过阅读的，我甚至更推荐你去阅读 <a href="https://apiflask.com/">APIFlask的官方文档</a>。</em></p><h2 id="初识APIFlask-Hello-APIFlask"><a href="#初识APIFlask-Hello-APIFlask" class="headerlink" title="初识APIFlask(Hello APIFlask)"></a>初识APIFlask(Hello APIFlask)</h2><p>废话放在后面说，作为快速上手教程，理所应当地先来个Hello World感受一下<code>Flask</code>的魅力，作为一篇保姆级教程下面就让从<code>pip</code>这个包管理器开始安装一下<code>APIFlask</code>吧（默认安装好python及其包管理器）</p><h3 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h3><p>小白的话就直接运行下面这条命令即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install apiflask # Linux环境用pip3</span><br></pre></td></tr></table></figure><p>当然本人还是强烈建议使用虚拟环境哈。细节就不多赘述了，下面开始写一个Hello World吧:</p><figure class="highlight python"><figcaption><span>hello/app.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> apiflask <span class="keyword">import</span> APIFlask</span><br><span class="line">app = APIFlask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello apiflask!&#x27;</span></span><br></pre></td></tr></table></figure><p>哪怕你没有开发经验，单纯的看单词也许已经猜到它是做什么了，下面就来一步步的分解这个程序。</p><h3 id="创建应用实例-application-对象"><a href="#创建应用实例-application-对象" class="headerlink" title="创建应用实例(application 对象)"></a>创建应用实例(application 对象)</h3><p>我们使用<code>pip</code>安装<strong>apiflask</strong>，其实也就是下载了一个叫<strong>apiflask</strong>的包。因此我们可以通过<strong>apiflask</strong>包的构造文件导入开发的类和函数。我们一开始从<strong>apiflask</strong>包导入<strong>APIFlask</strong>类，实例化这个类，就得到了我们的程序实例<code>app</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> apiflask <span class="keyword">import</span> APIFlask</span><br><span class="line">app = APIFlask(__name__)</span><br></pre></td></tr></table></figure><p>传入<strong>apiflask</strong>的第一个参数是模块或者包名词，这里使用Python的特殊变量<code>__name__</code>。</p><h3 id="注册路由"><a href="#注册路由" class="headerlink" title="注册路由"></a>注册路由</h3><blockquote><p>首先对于很多初学者来说都会有这么一个问题：<strong>路由是什么？</strong></p></blockquote><p>回答这个问题之前我们先来看看一个传统的Web应用，客户端和服务器上的程序是如何交互的:</p><ol><li>用户在浏览器输入URL访问某个资源</li><li>APIFlask接收用户请求并分析请求的URL</li><li>APIFlask为这个URL找到对应的处理函数</li><li>执行函数并生成响应，然后返回给浏览器</li><li>浏览器接收并解析响应</li></ol><p>而我们现在要做前后端分离，整个流程和上面是一致的，但客户端具体的对象则从浏览器变成了一段发起 http 请求的代码，以网页前后端分离为例稍微完善一下如下:</p><ol><li>前端使用AJAX向后端发起请求</li><li>APIFlask接收请求并分析请求的URL</li><li>APIFlask为这个URL找到对应的处理函数</li><li>执行函数并生成 HTTP 响应</li><li>AJAX接收响应</li><li>根据后续的业务代码进行页面的修改</li></ol><blockquote><p><em>⚠⚠注意⚠⚠</em> 这里的 <strong>AJAX</strong> 是指 <strong>Asynchronous JavaScript + XML（异步JavaScript和XML）</strong> 这是一个技术名词，读者需要注意与较多人熟知的<code>jQuery</code>库的<code>ajax</code>方法进行区分！！！<br>简单的来讲，<code>jQuery</code>的<code>ajax</code>是 <strong>AJAX</strong> 技术的一个实现，有着许多同类的替代品，比如<code>axios</code>。由于笔者见过太多的人将两者混淆，故在此着重强调。</p></blockquote><p>这些步骤中，大部分都是由APIFlask完成，我们只需要将<strong>处理函数与URL对应起来</strong>。只需在函数添加<code>app.route()</code>装饰器，并传入URL规则作为参数，就可以让URL与函数建立关系。这个过程我们称为注册路由(route)，路由复制管理URL和函数之间的映射，而这个函数则被称为视图函数(view function)。</p><h4 id="1-绑定多个URL"><a href="#1-绑定多个URL" class="headerlink" title="1. 绑定多个URL"></a>1. 绑定多个URL</h4><p>一个视图函数可以绑定多个URL，具体就像下面这段代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/hello&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello apiflask!&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="2-动态URL"><a href="#2-动态URL" class="headerlink" title="2. 动态URL"></a>2. 动态URL</h4><p>我们还可以在URL规则中添加变量部分, 使用<code>&lt;变量名&gt;</code>的形式表示。APIFlask处理请求时会把变量传入视图函数，代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/hello/&lt;name&gt;&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>(<span class="params">name:<span class="built_in">str</span></span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&#x27;Hello <span class="subst">&#123;name&#125;</span>!&#x27;</span></span><br></pre></td></tr></table></figure><p>如果URL变量中包含变量，但如果又要适配没有变量的情况，比如与多个URL配合起来使用，那么我们可以给一个默认值:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/hello&#x27;</span>, defaults=&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;farmer&#x27;</span>&#125;</span>)</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/hello/&lt;name&gt;&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say_hello</span>(<span class="params">name:<span class="built_in">str</span></span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&#x27;Hello <span class="subst">&#123;name&#125;</span>!&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="启动开发服务器"><a href="#启动开发服务器" class="headerlink" title="启动开发服务器"></a>启动开发服务器</h3><p>Flask内置了一个开发服务器(由依赖包Werkzeug)提供，足够在开发和测试阶段使用，而APIFlask是基于Flask二次开发的，因此我们一样可以使用。</p><blockquote><p>在生产环境需要使用性能够好的生产服务器，以提升安全和性能，具体更多内容移步到<a href="https://helloflask.com/book/1/">《Flask Web 开发实战 》</a></p></blockquote><p>在项目的<strong>根目录</strong>下，输入下面这条命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flask run</span><br></pre></td></tr></table></figure><p>然后我们会看到如下输出:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* Tip: There are .env or .flaskenv files present. Do &quot;pip install python-dotenv&quot; to use them.</span><br><span class="line">* Environment: production</span><br><span class="line">  WARNING: This is a development server. Do not use it in a production deployment.</span><br><span class="line">  Use a production WSGI server instead.</span><br><span class="line">* Debug mode: off</span><br><span class="line">* Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)</span><br></pre></td></tr></table></figure><p>这时候我们在浏览器访问这个URL，会看到这样显示:</p><img src="/2022/03/09/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E7%94%A8APIFlask%E5%81%9A%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94%E5%90%8E%E7%AB%AF/index.png" class="" title="hello_apiflask"><p>同理，其他URL自行替换即可得到相应的结果。但由于我们开发的是前后端分离架构，后端只负责提供API进行访问，除了基本的<code>GET</code>请求外还有大量其他请求报文。因为浏览器的调试无疑是不够的，为此<code>APIFlask</code>提供了交互式API文档(基于<strong>Swagger UI</strong> and <strong>Redoc</strong>)</p><p>要进入这个交互式API文档，默认的方式是访问<code>/docs</code>路由，为此我们重新在浏览器访问: <a href="http://127.0.0.1:5000/docs%EF%BC%8C%E5%8D%B3%E5%8F%AF%E7%9C%8B%E5%88%B0%E4%B8%8B%E9%9D%A2%E7%9A%84%E8%BF%99%E4%B8%AA%E9%A1%B5%E9%9D%A2">http://127.0.0.1:5000/docs，即可看到下面的这个页面</a>:</p><img src="/2022/03/09/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E7%94%A8APIFlask%E5%81%9A%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94%E5%90%8E%E7%AB%AF/swagger.png" class="" title="api_docs"><p>后续都会基于该API文档进行演示，当然你也可以访问: <a href="http://127.0.0.1:5000/redoc">http://127.0.0.1:5000/redoc</a> 查看基于Redoc生成的API文档。</p><blockquote><p>需要注意，网上许多教程都是通过<code>app.run()</code>形式来运行开发服务器的，这种方式其实是旧的启动方式，已经过时了目前已不推荐使用(deprecated)。</p></blockquote><p>Flask通过依赖包Click内置了一个CLI(Command Line Interface, 命令行交互界面)系统。当我们安装Flask后，会自动添加一个flask命令脚本，我们可以通过flask命令执行内置命令、扩展插件的命令与我们自定义的命令。其中，<code>flask run</code>命令用来启动开发服务器。</p><p>此外，你还可以执行<code>flask --help</code>查看所有命令，这些命令都需要在项目的根目录执行。</p><h3 id="自动发现程序实例"><a href="#自动发现程序实例" class="headerlink" title="自动发现程序实例"></a>自动发现程序实例</h3><p>上面启动开发服务器我们使用了<code>flask run</code>来启动，这就不禁让人好奇，<strong>Flask</strong>是如何找到程序的？</p><p>其实这个问题是因为<strong>Flask</strong>会自动探测程序实例，一般来说，在执行<code>flask run</code>命令运行程序前，我们需要提供程序实例所在模块的位置，而自动探测是按照下面这些规则:</p><ol><li>从当前目录寻找<code>app.py</code>和<code>wsgi.py</code>模块，并从中寻找名为<code>app</code>或<code>application</code>的程序实例</li><li>从环境变量<strong>FLASK_APP</strong>对应的模块名&#x2F;导入路径寻找名为<code>app</code>或<code>application</code>的程序实例</li></ol><p>因为我们上面的程序代码文件名为<code>app.py</code>，所以<code>flask run</code>命令会自动在其中寻找应用实例。如果你的程序文件名是其他名称，比如<code>hello_apiflask.py</code>，那么需要设置环境变量<strong>FLASK_APP</strong>，将包含程序实例的模块名赋值给这个变量。命令如下:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> <span class="attribute">FLASK_APP</span>=hello_apiflask</span><br></pre></td></tr></table></figure><p>Linux或macOS系统使用<code>export</code>命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export FLASK_APP=hello_apiflask</span><br></pre></td></tr></table></figure><h3 id="管理环境变量"><a href="#管理环境变量" class="headerlink" title="管理环境变量"></a>管理环境变量</h3><p><strong>FLASK</strong>的自动发现程序实例机制还有第三条规则: 如果安装了<strong>python-dotenv</strong>，那么在使用<code>flask run</code>或其他命令时会自动使用它从<code>.flaskenv</code>文件和<code>.env</code>文件中加载环境变量。</p><p>安装<strong>python-dotenv</strong>包命令如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install python-dotenv # Linux环境用pip3</span><br></pre></td></tr></table></figure><p>除了管理自动发现程序实例外，我们还可以用来管理程序需要的环境变量。我们在项目根目录下分别创建两个文件:<code>.env</code>和<code>.flaskenv</code>，其中<code>.flaskenv</code>用来管理和<strong>Flask</strong>相关的公开环境变量。而<code>.env</code>文件则用来管理包含敏感信息的环境变量。</p><blockquote><p><code>.env</code>包含敏感信息，除非是私有项目，否则绝对不能提交到Git仓库中</p></blockquote><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><blockquote><p>为什么写扩展阅读，扩展阅读的作用?</p></blockquote><p>扩展阅读模块主要是对上面的内容进行补充，内容并非必读内容并不会影响程序的运行，更多是补充开发相关各方面的知识内容。</p><h3 id="配置热更新-重载器"><a href="#配置热更新-重载器" class="headerlink" title="配置热更新(重载器)"></a>配置热更新(重载器)</h3><p>开发环境(development environment)和生产环境(production environment)。根据运行环境的不同，<strong>Flask</strong>程序、扩展以及其他程序会改变相应的行为和设置。为了区分运行环境，<strong>Flask</strong>提供了一个<strong>FLASK_ENV</strong>环境变量用来设置环境，默认为<code>production</code>(生产)。在开发时我们可以将其设置为<code>development</code>，这会开启所有支持开发的特性，为了方便管理我们还可以将其写入到<code>.flaskenv</code>文件中:</p><figure class="highlight shell"><figcaption><span>./.flaskenv</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLASK_ENV=development</span><br></pre></td></tr></table></figure><p>现在启动程序，你会看到下面的输出提示:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(env) E:\Github\HelloAPIFlask\demos\hello&gt;flask run</span><br><span class="line"> * Environment: development</span><br><span class="line"> * Debug mode: on</span><br><span class="line"> * Restarting with stat</span><br><span class="line"> * Debugger is active!</span><br><span class="line"> * Debugger PIN: 500-487-380</span><br><span class="line"> * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)</span><br></pre></td></tr></table></figure><p>在开发环境下，调试模式(Debug Mode)将被开启，这时执行<code>flask run</code>启动程序会自动激活<strong>Werkzeug</strong>内置的调试器(debugger)和重载器(reloader)，他们会为开发带来很大的帮助。</p><p><strong>如果你想单独控制调试模式开关，可以通过FLASK_DEBUG环境变量来设置，设为1为开启，设为0则关闭，不过通常不推荐手动设置这个值</strong></p><h3 id="创建虚拟环境"><a href="#创建虚拟环境" class="headerlink" title="创建虚拟环境"></a>创建虚拟环境</h3><blockquote><p>在 Python 中，虚拟环境(virtual enviroment)就是隔离的 Python 解释器环境。通过创建虚拟环境，你可以拥有一个独立的 Python 解释器环境。这样做的好处是可以为每一个项目创建独立的 Python 解释器环境，因为不同的项目经常会依赖不同版本的库或Python版本。使用虚拟环境可以保持全局 Python 解释器环境的干净，避免包和版本的混乱，并且可以方便地区分和记录每个项目的依赖，以便在新环境下复现依赖环境。</p></blockquote><p>虚拟环境通常使用<strong>Virtualenv</strong>来创建，除此之外还有<strong>Pipenv</strong>、<strong>PDM</strong>等诸多环境管理工具。简单起见，我们使用<strong>Python3</strong>自带的工具来创建虚拟环境，首先确保我们当前工作目录在项目的根目录，然后使用<code>python3 -m venv env</code>命令为当前项目创建虚拟环境:</p><figure class="highlight shell"><figcaption><span>Windows</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m venv env</span><br></pre></td></tr></table></figure><figure class="highlight shell"><figcaption><span>Linux</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m venv env</span><br></pre></td></tr></table></figure><p><strong>提示: Windows用户可直接复制，但Linux系统大多存在python2与python3，Linux用户需要注意这点</strong></p><p>这会在当前目录创建一个名为<strong>env</strong>的文件夹(命令最后一个选项为文件夹名)，其中包含隔离的Python解释器环境。</p><h3 id="激活虚拟环境"><a href="#激活虚拟环境" class="headerlink" title="激活虚拟环境"></a>激活虚拟环境</h3><p>在创建虚拟环境后，我们还需要载入(激活)这个环境，接下来使用<code>.\env\Script\active</code>来激活虚拟环境:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">E:\Github\HelloAPIFlask&gt;.\env\Scripts\activate</span><br><span class="line"></span><br><span class="line">(env) E:\Github\HelloAPIFlask&gt;</span><br></pre></td></tr></table></figure><p>Linux环境使用<code>source</code>命令来激活:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">farmer@farmer-ubuntu:~/HelloAPIFlask$ source ./env/bin/activate</span><br><span class="line"></span><br><span class="line">(env) farmer@farmer-ubuntu:~/HelloAPIFlask$ source ./env/bin/activate</span><br></pre></td></tr></table></figure><p>可以看到虚拟环境激活后命令行前面多了一个虚拟环境的标识，这就表示虚拟环境激活啦！使用<code>pip list</code>我们可以看到该环境是一个全新的环境。</p><h3 id="更多启动项"><a href="#更多启动项" class="headerlink" title="更多启动项"></a>更多启动项</h3><ol><li>使服务器外部可见<br>我们上面启动的Web服务器默认是对外不可见的，我们可以通过<code>--host</code>选项将主机地址改为<code>0.0.0.0</code>使其对外部可见:<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flask run --host=0.0.0.0</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>需要注意这里的外部是指你计算机外部，并不是指公网。一般个人的电脑是没有公网IP(公有地址)，所以此时你的程序只能被局域网内的其他用户通过你电脑的IP(内网)进行访问。</p></blockquote><ol start="2"><li>改变默认端口</li></ol><p><strong>Flask</strong>提供的Web服务器默认监听5000端口，你可以通过<code>--port</code>选项进行更改:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flask run --port=2333</span><br></pre></td></tr></table></figure><p>此时会监听来自2333端口的请求，对应的程序网址也变成了 <a href="http://127.0.0.1:2333/%E3%80%82">http://127.0.0.1:2333/。</a></p><h2 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h2><blockquote><p>这一切开始于2010年4月1日，<strong>Armin Ronacher</strong>在网上发布了一篇关于”下一代 Python 微框架”的介绍文章，文章里称这个 Denied 框架不依赖 Python 标准库，只需要复制一份 <code>deny.py</code> 放到你的项目文件夹就可以开始编程。随着一本正经的介绍、名人推荐语、示例代码和演示视频，这个”虚假“的项目让不少人信以为真。5天后 <strong>Flask</strong> 就从这么一个愚人节玩笑诞生了。</p></blockquote><p>同样的，<strong>APIFlask</strong>这个框架开始于 2021年4月1日，不知道是机缘巧合还是<a href="https://greyli.com/">Grey Li</a>有意为之的一个小玩笑，<strong>APIFlask</strong>与<strong>Flask</strong>均诞生于4月1日这一天。🎉🚀✨</p><p>在与<a href="https://greyli.com/">Grey Li</a>求证后得知两者选择同一天发布是有意为之的！！😄</p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- **『注：本文更新于2022年3月15日』** --&gt;


&lt;blockquote&gt;
&lt;p&gt;本文项目对应地存储库: &lt;a href=&quot;https://github.com/Farmer-chong/HelloAPIFlask&quot;&gt;https://github.com/Fa</summary>
      
    
    
    
    <category term="学了些什么" scheme="https://blog.farmer233.top/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="python" scheme="https://blog.farmer233.top/tags/python/"/>
    
    <category term="笔记" scheme="https://blog.farmer233.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="web" scheme="https://blog.farmer233.top/tags/web/"/>
    
    <category term="Flask/APIFlask" scheme="https://blog.farmer233.top/tags/Flask-APIFlask/"/>
    
  </entry>
  
  <entry>
    <title>用Rust为Python加双翅膀</title>
    <link href="https://blog.farmer233.top/2022/01/15/%E7%94%A8Rust%E4%B8%BAPython%E5%8A%A0%E5%8F%8C%E7%BF%85%E8%86%80/"/>
    <id>https://blog.farmer233.top/2022/01/15/%E7%94%A8Rust%E4%B8%BAPython%E5%8A%A0%E5%8F%8C%E7%BF%85%E8%86%80/</id>
    <published>2022-01-15T14:22:42.000Z</published>
    <updated>2023-11-12T17:26:19.950Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学习<code>Rust</code>，这是一门系统级语言。保证安全的同时摆脱了<code>GC</code>, 它很香同时也很难上手, 刚学完一点皮毛知识决定做个小玩意儿玩玩，是骡子是马总要拉出来溜溜~</p><p>目前个人认为<code>Rust</code>在性能上是可以和<code>C++</code>媲美的一门语言，既然如此那就用它来为<code>Python</code>加个速吧！😊</p><h2 id="起步准备"><a href="#起步准备" class="headerlink" title="起步准备"></a>起步准备</h2><p>为<code>Python</code>加速与写<code>C语言</code>扩展类似，最终通过<code>pyd</code>来调用。在此之前我们用到<code>Rust</code>的<code>pyo3</code>库，另外我们编写的是一个<code>lib</code>而不是应用程序，因此我们要创建<code>lib</code>项目。</p><p>创建<code>lib</code>库项目: </p><p><code>$ cargo new &lt;project name&gt; --lib</code></p><p>在 <strong>Cargo.toml</strong> 文件添加<code>pyo3</code>依赖: </p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[lib]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;string_sum&quot;</span></span><br><span class="line"><span class="attr">crate-type</span> = [<span class="string">&quot;cdylib&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies.pyo3]</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.15.1&quot;</span></span><br><span class="line"><span class="attr">features</span> = [<span class="string">&quot;extension-module&quot;</span>]</span><br></pre></td></tr></table></figure><h2 id="一个小Demo"><a href="#一个小Demo" class="headerlink" title="一个小Demo"></a>一个小Demo</h2><p>使用文档的例子，编写一个<code>Hello World</code>试试，代码如下: </p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> pyo3::prelude::*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Formats the sum of two numbers as string.</span></span><br><span class="line"><span class="meta">#[pyfunction]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">sum_as_string</span>(a: <span class="type">usize</span>, b: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> PyResult&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>((a + b).<span class="title function_ invoke__">to_string</span>())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// A Python module implemented in Rust.</span></span><br><span class="line"><span class="meta">#[pymodule]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">string_sum</span>(py: Python, m: &amp;PyModule) <span class="punctuation">-&gt;</span> PyResult&lt;()&gt; &#123;</span><br><span class="line">    m.<span class="title function_ invoke__">add_function</span>(wrap_pyfunction!(sum_as_string, m)?)?;</span><br><span class="line">    m.<span class="title function_ invoke__">add_function</span>(wrap_pyfunction!(test_func, m)?)?;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后用打包命令将这个项目build一下:<br><code>$ cargo build --release</code></p><p>这时候应该能看到项目的结构如下: </p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├─src</span><br><span class="line">└─target</span><br><span class="line">    ├─release</span><br><span class="line">    │  ├─.fingerprint</span><br><span class="line">    │  ├─build</span><br><span class="line">    │  ├─deps</span><br><span class="line">    │  ├─examples</span><br><span class="line">    <span class="string">|  ├─string_sum.dll</span></span><br><span class="line">    <span class="string">|  ├─string_sum.d</span></span><br><span class="line">    <span class="string">|  ├─libstring_sum.dll.a</span></span><br><span class="line">    │  └─incremental</span><br><span class="line">    └─rls</span><br></pre></td></tr></table></figure><p>这里的<strong>string_sum.dll</strong>就是我们需要的，我们将文件的扩展名改成<code>pyd</code>即可得到我们的<code>python</code>扩展文件 -&gt; <code>string_sum.pyd</code></p><p>完成之后尝试一下调用这个文件，新建一个<code>test</code>文件夹并将其复制进去, 最后调用一下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> string_sum</span><br><span class="line"><span class="built_in">print</span>(string_sum.sum_as_string(<span class="number">200</span>, <span class="number">33</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># export: 233</span></span><br></pre></td></tr></table></figure><h2 id="CPU运算性能Demo"><a href="#CPU运算性能Demo" class="headerlink" title="CPU运算性能Demo"></a>CPU运算性能Demo</h2><p>继续在刚刚的文件中添加一个需要大量计算的函数:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">#[pyfunction]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test_func</span>() <span class="punctuation">-&gt;</span> PyResult&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">a</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">b</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> <span class="variable">c</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> <span class="variable">d</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> <span class="variable">e</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">                        <span class="keyword">for</span> <span class="variable">f</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> <span class="title function_ invoke__">m</span>(a) + <span class="title function_ invoke__">m</span>(b) + <span class="title function_ invoke__">m</span>(c) + <span class="title function_ invoke__">m</span>(d) + <span class="title function_ invoke__">m</span>(e) + <span class="title function_ invoke__">m</span>(f)</span><br><span class="line">                                == a * <span class="number">10_0000</span> + b * <span class="number">1_0000</span> + c * <span class="number">1000</span> + d * <span class="number">100</span> + e * <span class="number">10</span> + f</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&quot;</span>, a, b, c, d, e, f);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">Ok</span>(<span class="type">String</span>::<span class="title function_ invoke__">new</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// A Python module implemented in Rust.</span></span><br><span class="line"><span class="meta">#[pymodule]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">string_sum</span>(py: Python, m: &amp;PyModule) <span class="punctuation">-&gt;</span> PyResult&lt;()&gt; &#123;</span><br><span class="line">    m.<span class="title function_ invoke__">add_function</span>(wrap_pyfunction!(test_func, m)?)?;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>后续的步骤与上面一致，编译重命名后拷贝到<code>python</code>目录下，修改一下刚才的<code>python</code>代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> string_sum</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">target_func</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">m</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> x * x * x * x * x</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">10</span>): </span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">10</span>): </span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">10</span>): </span><br><span class="line">                <span class="keyword">for</span> d <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">10</span>): </span><br><span class="line">                    <span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">10</span>): </span><br><span class="line">                        <span class="keyword">for</span> f <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">10</span>): </span><br><span class="line">                            <span class="keyword">if</span> m(a) + m(b) + m(c) + m(d) + m(e) + m(f) == a * <span class="number">10_0000</span> + b * <span class="number">1_0000</span> + c * <span class="number">1000</span> + d * <span class="number">100</span> + e * <span class="number">10</span> + f:</span><br><span class="line">                                <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;a&#125;</span><span class="subst">&#123;b&#125;</span><span class="subst">&#123;c&#125;</span><span class="subst">&#123;d&#125;</span><span class="subst">&#123;e&#125;</span><span class="subst">&#123;f&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_fun</span>(<span class="params">func, flage:<span class="built_in">str</span> = <span class="string">&quot;Python&quot;</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;计时函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        func (function): 回调函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    start = time.time()</span><br><span class="line">    func()</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;flage&#125;</span> time: &quot;</span>,end - start)</span><br><span class="line">    <span class="keyword">return</span> start - end</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始计时 -&gt; Rust</span></span><br><span class="line">rust_time = test_fun(string_sum.test_func, flage=<span class="string">&quot;Rust&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试纯Python</span></span><br><span class="line">python_time = test_fun(target_func)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Rate: <span class="subst">&#123;python_time/rust_time&#125;</span>&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行看一下结果，从结果看到<code>Rust</code>比<code>Python</code>足足快了<strong>125倍</strong>多！！！</p><img src="/2022/01/15/%E7%94%A8Rust%E4%B8%BAPython%E5%8A%A0%E5%8F%8C%E7%BF%85%E8%86%80/rust2python.png" class="" title="result">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在学习&lt;code&gt;Rust&lt;/code&gt;，这是一门系统级语言。保证安全的同时摆脱了&lt;code&gt;GC&lt;/code&gt;, 它很香同时也很难上手, 刚学完一点皮毛知识决定做个小玩意儿玩玩，是骡子是马总要拉出来溜溜~&lt;/p&gt;
&lt;p&gt;目前个人认为&lt;code&gt;Rust&lt;/code&gt;在</summary>
      
    
    
    
    <category term="学了些什么" scheme="https://blog.farmer233.top/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="python" scheme="https://blog.farmer233.top/tags/python/"/>
    
    <category term="笔记" scheme="https://blog.farmer233.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Rust" scheme="https://blog.farmer233.top/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>校招杂谈</title>
    <link href="https://blog.farmer233.top/2021/12/08/%E7%A7%8B%E6%8B%9B%E6%9D%82%E8%B0%88/"/>
    <id>https://blog.farmer233.top/2021/12/08/%E7%A7%8B%E6%8B%9B%E6%9D%82%E8%B0%88/</id>
    <published>2021-12-08T12:09:49.000Z</published>
    <updated>2023-11-12T17:26:19.950Z</updated>
    
    <content type="html"><![CDATA[<p>秋招结束后就一直想写一篇总结，但个人比较懒躺平了好久:D。最近老师给我布置了个任务写一下秋招这段时间的面试经验总结, 就不继续鸽了吧😄 继回顾完大学生涯后再来看看近段时间的校招悲剧吧 :(</p><p>如果不读研，校招可以说每个人一生只有一次，当你毕业了也就失去应届生这个身份了也就不能参与校招了。因此校招这个机会是十分重要且难得的，一定要尽早准备参加，重视重视再重视！！！⚠️ </p><p>切记 <strong>春招找实习，秋招拿offer</strong></p><p>虽然应届生身份法规上是两年内，但又有几个公司这么看尼～</p><h2 id="重要的东西写在前头"><a href="#重要的东西写在前头" class="headerlink" title="重要的东西写在前头"></a>重要的东西写在前头</h2><p>首先说一个思想上的几个误区：</p><ol><li>许多人认为没毕业就不能去应聘</li><li>我才大三，校招离我还远</li><li>学校大四还有课，找到了也去不了不如不去面试</li><li>我是前端，后端的那些就不复习了</li></ol><p>据我观察我们学校很多人都有这个误区，但其实并非这样。校招可以说当你踏入大三，就要开始准备了！另外对于面试官来说，应届生只有CS专业与非CS专业的两种情况，你前端还是后端只是决定了考察的重点或者问题方向罢了。下面就来详细的展开说说校招的这些事吧～</p><p>开始之前先介绍一下个人情况吧，看官还请结合自身实际参考阅读：</p><ol><li><code>Python</code>、<code>JavaScript</code>、<code>golang</code>这三门语言为我的主技术栈, 当然别的语言也会点。</li><li>框架方面：<code>Flask</code>、<code>APIflask</code>、<code>gin</code>、<code>Vue</code>等常见的web开发框架我都能熟练的使用</li><li>裸考软考网络工程师</li><li>有一颗热爱计算机、热爱折腾的心</li></ol><p>我秋招拿到还不错的offer有：</p><ol><li>明源云-base深圳</li><li>信也科技-base上海</li><li>美团-base北京</li></ol><p>在编程方面，你应该有以下的基本素养：</p><ol><li>会写注释、会写文档</li><li>变量名清晰明了</li><li>函数功能划分清楚、职责单一（❌冗长的函数）</li><li>习惯看官方文档，拒绝看垃圾博客（如csdn）</li><li>接口协议设计合理、规范清晰</li><li>添加功能的时候多一点思考（如扩展性）</li><li>习惯写测试用例、单元测试（正所谓一行代码千行测试）</li><li>代码问题输出使用规范化的log记录</li><li>提交代码要规范</li></ol><h2 id="一个比较常规的应届生校招流程"><a href="#一个比较常规的应届生校招流程" class="headerlink" title="一个比较常规的应届生校招流程"></a>一个比较常规的应届生校招流程</h2><img src="/2021/12/08/%E7%A7%8B%E6%8B%9B%E6%9D%82%E8%B0%88/school-recruit.png" class="" title="recruit"><p>上图可以说是大学生应该知道的招聘流程，我以一个刚步入大三的学生身份来remake整个流程。是的，大三开学就需要开始准备校招事宜了！</p><h3 id="大三开学首先要做这几件事："><a href="#大三开学首先要做这几件事：" class="headerlink" title="大三开学首先要做这几件事："></a>大三开学首先要做这几件事：</h3><ol><li>制作简历</li><li>浏览意向的岗位资讯</li><li>开始复习八股文</li><li>开始刷题、刷算法</li></ol><p>在学期末的时候开始投递简历，应聘大厂的实习岗位。实习可以说是我们三本学生进入大厂为数不多的机会了，切记要把握好！</p><h3 id="大三第二个学期"><a href="#大三第二个学期" class="headerlink" title="大三第二个学期"></a>大三第二个学期</h3><p>常言道：春招找实习、秋招拿offer。这个学期开学一般都是3月份了，这时候你应该已经在寒假就完成简历的投递了。这个学期的主要任务就是：</p><ol><li>找到实习</li><li>继续八股文、算法的复习</li><li>了解提前批动态</li></ol><p>每年的提前批时间都不一样，需要自行上牛客网浏览相关资讯。关注大厂提前批的动态。</p><h3 id="大三与大四中间的暑假"><a href="#大三与大四中间的暑假" class="headerlink" title="大三与大四中间的暑假"></a>大三与大四中间的暑假</h3><p>这个暑假一般而言是在秋招应聘的实习公司与面试中度过的，争取拿到正式offer是这个时间段唯一目标！有实习经历与没有实习经历是有很大差距的！具体原因下文会讲到。</p><h3 id="大四"><a href="#大四" class="headerlink" title="大四"></a>大四</h3><p>大四开学就是9月了，也是正式的校招与秋招的开始。是厮杀的最火热的时间段。    </p><p>在这个时间段往往会遇到<strong>卡简历</strong>、<strong>卡学历</strong>等等的不公平待遇，这也是为什么说提前批争取上岸的原因。<br>这个时间段的笔试，除非你能答到基本满分，否则你可能连面试官都见不到。</p><p>至于笔试题的难度，按ACM标准来看就好了。至于秋招结束还没上岸或者拿不到保底，那只能希望来年的春招了。</p><h2 id="个人简历"><a href="#个人简历" class="headerlink" title="个人简历"></a>个人简历</h2><p>简历是十分重要的，最重要的是一个“真”字。内容一定要真实会就会，不会就不会。其次是“精”，切忌杂七杂八的东西往上丢，比如项目部分写学校的课程实训就很掉分。</p><p>最后需要注意里面的内容需要突出重点而不是一股脑的全丢上面。尽可能控制在一页内，主要包含你会的技术栈、能拿得出手的项目、经历与技能证书、自我评价这几个部分，下面详细展开来说。</p><h3 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h3><p>在技术栈上，经可能的突出与求职岗位所匹配的技术。另外需要注意描述技能掌握程度时的词语<strong>了解</strong>，<strong>熟悉</strong>和<strong>精通</strong>的区别。<br>“了解”指对某项技术只是全面学习过或看过书，但并没有做过实际的项目。一般不建议在简历中写只是肤浅地了解一点的技能，如：只是在我校Java课程中学过java，那就只能算了解。</p><p>在简历描述中的掌握程度大部分应该是“熟悉”，一般毕业生是使用不到“精通”的。“熟悉”意味着你对这门技术有着深入的使用且已经有较长的时间，通过查阅相关文档可以独立解决大部分问题，那么我们就能熟悉它了。</p><p>⚠️需要注意，学习的课程实训并不能算数！举几个例子，熟悉 MySQL 你应该能清楚的知道<strong>事务隔离级别</strong>、<strong>sql调优</strong>、处理过数据库事物并发带来的相关问题等许多细节；熟悉 Python 你应该知道<strong>GIL(全局解释锁s)<strong>、</strong>元编程</strong>、<strong>魔法方法(magic function)<strong>、</strong>迭代器生成器装饰器(iterator, generator, decorator)<strong>等等（如果你刚好也是Python技术栈，那我推荐你看一下《流畅的Python》这本书）；最后再以人数最多Java来举例子，Java你应该知道</strong>JVM内存区域布局</strong>、<strong>基本的垃圾回收机制和原理</strong>、各种集合类的底层原理、各种<code>InputStream/OutputStream</code>的区别，特别是HashMap中的<strong>桶结构的进化与退化</strong>以及接口，抽象类区别，应用场景。</p><p>还有一些计算机通用的底层原理（八股文）就不过多赘述了。</p><h3 id="项目与经历部分"><a href="#项目与经历部分" class="headerlink" title="项目与经历部分"></a>项目与经历部分</h3><p>项目与经历最好就是写你实习负责的项目与实习经历⚠️<strong>切忌将学校课程实训的项目也往上写</strong>⚠️因为这类项目根本无法吸引面试官眼球！甚至让面试官感觉你技术就那样儿～ 因此宁可只有一个也不写多，宁愿刚八股文也不要让面试官对你没兴趣！</p><p>项目这部分是简历中最重要的，因为它直接关系到面试官与你谈的内容。以我这几次面试来看面试官对你的项目问的越多，了解的越深入越感兴趣你就越有戏，我有几次甚至因为和面试官聊项目聊到timeout了😂面试官也对这个项目给出了好多有用有意思的建议！如果项目面试官不感兴趣的话，那就只能问你八股文了，这样除了要有扎实的基本功外还要看你能否答到面试官想听的点了，这难度就可想而知了～ 总的来说你的项目就是要让面试官感兴趣，因此项目部分提炼出来的要点如下：</p><ol><li>最好是实习的项目</li><li>项目比较有趣、新颖、吸引眼球</li><li>切忌把烂大街的项目放到简历上</li></ol><h3 id="技能证书与自我评价"><a href="#技能证书与自我评价" class="headerlink" title="技能证书与自我评价"></a>技能证书与自我评价</h3><p>自我评价想不到说啥，就来说说技能证书吧～ 技能证书其实也是按照精而不多原则来填写（这不是废话），当然真实的情况往往是没有几个能拿得出手的证书😄 这时候就有要按公司、按职位来写了。</p><p>以英语证书为例，如果你投的岗位与公司对英语水平没有太大要求而你又只有四级证书，那最好还是不要填写四级证书为好。因为在整个应届生群体中雅思托福的不在少数，你的简历上的四级反而是一个掉分项！</p><h2 id="面试八股文"><a href="#面试八股文" class="headerlink" title="面试八股文"></a>面试八股文</h2><ol><li>数据结构与算法</li><li>操作系统原理</li><li>计算机网络</li><li>数据库</li></ol><p>在复习上面的内容时，切记不要按学校教的来复习! 因为学校教的不够深入，前三部分建议参考考研408的真题。按考研的难度来复习就对了。八股文与考研这些东西，网上资料十分详细（特别是GitHub上面）这里就不展开细说了，列几个我认为秋招一定要会的基本功吧：（后面想起来会动态补充）</p><h3 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h3><p>这部分按考研标准来就好了，几种常见排序、数据结构是一定要会的～ 这里推荐《小灰算法》这本书，里面所讲的都是面试的基础。</p><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><ol><li>OSI 七层模型分别是？各自的功能是什么？</li><li>一次完整的http请求过程包括那些内容</li><li>http本质上是什么？ get和post的区别有哪些？从底层原理上回答</li><li>http与https的区别？https如何保证数据传输安全</li><li>什么是SSL&#x2F;TLS？</li><li>一个tcp链接可以对应几个http request？</li><li>浏览器对同一个Host建立tcp链接的数量有没有限制？</li><li>DNS是什么？两种查询方法了解过吗？工作原理是什么？</li><li>http长链接与短链接的区别</li><li>get方法的长度限制是怎么回事？</li><li>Cookie与Session的区别？session的工作原理是什么？不同框架对session的实现有什么不同？</li><li>SQL注入了解吗？ 简单的注入会不会？</li><li>CSRF攻击、CSS攻击是什么？</li><li>TCP包头结构，各字段的功能与作用</li><li>TCP的粘包&#x2F;拆包问题，发生的原因？</li><li>常见的tcp攻击了解吗？会复现吗？</li><li>tcp的三次握手四次挥手</li><li>tcp四大拥塞控制算法，tcp的滑动窗口</li><li>流量控制原理会吗？tcp如何保证可靠性传输？</li><li>udp是什么？tcp与udp的区别</li><li>服务器出现大量close_wait的原因是什么？怎么解决？</li></ol><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>这一part本人不熟，以 MySQL 与 Redis 为主：</p><ol><li>事务是什么？</li><li>MySQL事务隔离级别</li><li>并发问题？脏读、幻读与不可重复读？</li><li>MySQL对repeat table read做了什么？</li><li>索引原理</li><li>B+树是什么？并且对比红黑树与其他数据结构</li><li>死锁怎么造成的？怎么处理？</li><li>什么是MVCC？</li><li>MyISAM与Innodb</li><li>表结构优化、sql调优</li><li>跳表(SkipList)</li><li>Redis的两种存储是什么？</li><li>服务器宕机后数据怎么恢复</li></ol><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><ol><li>进程、线程与协程的区别</li><li>线程进程到底是什么？</li><li>一个进程可以创建几个线程？</li><li>进程线程模型</li><li>Linux下进程间通信方式</li><li>Linux下同步机制</li><li>内存交换与覆盖的区别</li><li>虚拟技术了解吗？容器技术了解吗？</li><li>进程状态的切换知道多少？</li><li>一个程序从开始到结束整个生命周期的过程</li><li>进程同步的四种方法？</li><li>两个经典问题：哲学家与消费者</li><li>说说几种典型的锁？</li><li>死锁相关</li><li>malloc申请内存时候，操作系统做了什么？</li><li>说说new、malloc、del与free</li><li>说说守护进程与僵尸进程和孤儿进程</li><li>服务器高并发的解决方案有哪几个？</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;秋招结束后就一直想写一篇总结，但个人比较懒躺平了好久:D。最近老师给我布置了个任务写一下秋招这段时间的面试经验总结, 就不继续鸽了吧😄 继回顾完大学生涯后再来看看近段时间的校招悲剧吧 :(&lt;/p&gt;
&lt;p&gt;如果不读研，校招可以说每个人一生只有一次，当你毕业了也就失去应届生这</summary>
      
    
    
    
    <category term="胡思乱语" scheme="https://blog.farmer233.top/categories/%E8%83%A1%E6%80%9D%E4%B9%B1%E8%AF%AD/"/>
    
    
    <category term="胡言乱语" scheme="https://blog.farmer233.top/tags/%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>Review of life in university ✔</title>
    <link href="https://blog.farmer233.top/2021/11/07/Review-of-life-in-university/"/>
    <id>https://blog.farmer233.top/2021/11/07/Review-of-life-in-university/</id>
    <published>2021-11-06T17:05:52.000Z</published>
    <updated>2023-11-12T17:26:19.926Z</updated>
    
    <content type="html"><![CDATA[<p>最近秋招尾声，对于职场小白的我来说有许许多多不懂、迷茫得地方。<strong>幸运的</strong>是我有着几个愿意听我埋怨，在我面试紧张时听我话痨，在我迷茫时给予我中肯建议的朋友，万分感谢！</p><p>过去的已无法改变，总结一下过去四年发生的点滴无论好坏，也叫作给自己一个交待吧。毕竟我们不也天天code-review么</p><p>不知不觉四年就过去了，最近经历了秋招见识到了找工作的艰辛，也有收获到了offer的喜悦，同时也有着选offer的纠结。找工作的艰辛源于自身实力不足，收获的offer是对我四年努力的肯定，选offer的纠结是出于对自身现状的不满。Anyway, dont stop learning.</p><h2 id="过去"><a href="#过去" class="headerlink" title="过去"></a>过去</h2><p>回顾过去，一个小白从网络入坑计算机到逐步转型web狗🐕再到现在慢慢靠近云原生、微服务相关领域。经历的点点滴滴，让人不禁感叹如果能remake该多好😶。</p><p>如果将大学四年放到整个计算机生涯中，那我会比作从婴儿蹒跚学步到一个学徒入门的水平。还记得刚入学的时候怀揣着一颗敬畏的心去面试部门，希望在这里能找到志同道合的人。现在看来这个决定是十分正确的。还记得大一下学期的时候，忐忑的去面试当时垄断校园公众号的小喵团队。二面时那“艰巨”的任务让许多人望而却步，庆幸的是我没有放弃。</p><ol><li>掌握python语法</li><li>学会使用git进行版本管理、提pr</li><li>学会flask框架，并开发一个简单的应用</li><li>一个星期内完成上述任务</li></ol><p>虽然这一个星期我活得很狼狈，但也正是这一个星期让我正式的踏上了开发这条路。大一如果说是跌跌撞撞的入门，那么大二可以说是渐入佳境、步入了快车道了。</p><p>大二一年可以说是完成了web前后端的一个蜕变。从与同学打闹的一个爬虫小程序到为了偷懒不跑<code>i广科</code>而写的一个定时爬虫小jio本，从<code>flask框架</code>与<code>Jinja2</code>模板的传统web开发到<code>flask</code>与<code>Vue</code>的前后端分离，以及不知何时学会的<code>JavaScript</code>。</p><p>大三是一个比较<em>卷</em>的一段时间，从<strong>手撸http协议</strong>到<strong>手撸玩具分布式</strong>再到前端Vue的一些底层api、原理的学习。也是从大三这个阶段，开始有了考研的想法，虽然这个想法动摇的十分厉害，就像大海上的小舟一样随波漂流。经过思考后我决定两个都要(小孩子才做选择)🤣不过此时的我还纯纯的不知道春招、秋招、提前批这些东西是啥，回过头来看真的挺呆的。</p><h2 id="现在"><a href="#现在" class="headerlink" title="现在"></a>现在</h2><p>到了大四了，无论是不是想找工作。在周围人的影响下我了解到了秋招、春招等信息，一开始还不是很上心，毕竟学校还有课程，考研408也还没看多少，八股文就更不用说了比408有过之而无不及。</p><p>大四是一个毕业的季节，同时也是考研的冲刺阶段。无论如何我都应该做出一个抉择了，要么考研要么秋招。对于一个末流三本的菜狗来说无论哪一条路都不好走，对于一个选择困难症晚期患者来说这是十分折磨人的。在一众吃瓜群友的吐苦水后，我选择了秋招这条路，现在看来这个决定还不错。秋招拿到了5份offer，选offer也不是件省心的事儿。因为无论是<strong>北上广深</strong>于我而言都是离家，别人也给不了太多的意见终归还是要自己做决定。从公司的待遇与职位的匹配度到所在城市的风俗习惯再到相关的入户政策等等诸多细枝末节的考虑，真让人头昏脑胀。</p><p>秋招也结束了，就等三方的流程走完就尘埃落定。虽然明年春招或许会再尝试，不过躺平又未尝不是一种选择？</p><h2 id="Remake"><a href="#Remake" class="headerlink" title="Remake"></a>Remake</h2><p>如果让我现在回到大一，我有什么是比较后悔的？我会怎么重新选择学习路线？我又会怎么弥补这些遗憾？</p><p>后悔事值得总结的大概就两件吧。其一是没有好好准备求职，比如没有参与春招实习、秋招导致错过了求职的黄金时间。另一件则是知乎上的热门话题了：<strong>为什么大学生都喜欢翘课</strong>，大一大二的公共课浪费了许许多多的精力与时间。如果给我现在回到大一，我会勇敢的翘了。如果你问我学校的课程有没有用？答案是不太有用。真实的情况往往是学校教学的内容早已掌握甚至比老师还会，这不是狂而是三本无奈的现状。教学的老师往往是开学前的一个星期临时自学然后就参与教学活动中来，上课讲错基础概念更是常有的事，这就是我为什么说<strong>上课浪费了我大量的精力与时间</strong>。第二个原因则是因为我已掌握的知识能反哺课程。以web开发为例，不外乎就是操作<code>http协议</code>与<code>数据库的CRUD</code>。熟悉了这个其实换框架只需几个小时，或者通过代码提示甚至可以直接上手完成实训、考试。往往裸考的成绩都能排到全班前三，真是讽刺啊~</p><h2 id="the-end"><a href="#the-end" class="headerlink" title="the end"></a>the end</h2><p>骂骂咧咧的写了篇流水账，过段时间再看回来或许会直接社死了吧。 Anyway, lifelong learning. 学习永远不晚，别停下学习的步伐就好啦。</p><h3 id="关于学校3-1-创新班"><a href="#关于学校3-1-创新班" class="headerlink" title="关于学校3+1(创新班)"></a>关于学校3+1(创新班)</h3><p>很多人都问过我3+1是否能去，废话不多说结论放在前头：</p><ol><li><strong>不要去3+1</strong></li><li><strong>不要去创新班!</strong></li></ol><p>当然事无绝对，觉得合适就好~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近秋招尾声，对于职场小白的我来说有许许多多不懂、迷茫得地方。&lt;strong&gt;幸运的&lt;/strong&gt;是我有着几个愿意听我埋怨，在我面试紧张时听我话痨，在我迷茫时给予我中肯建议的朋友，万分感谢！&lt;/p&gt;
&lt;p&gt;过去的已无法改变，总结一下过去四年发生的点滴无论好坏，也叫作给自</summary>
      
    
    
    
    <category term="胡思乱语" scheme="https://blog.farmer233.top/categories/%E8%83%A1%E6%80%9D%E4%B9%B1%E8%AF%AD/"/>
    
    
    <category term="胡言乱语" scheme="https://blog.farmer233.top/tags/%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>A distributed system with Go</title>
    <link href="https://blog.farmer233.top/2021/09/05/A-distributed-with-Go/"/>
    <id>https://blog.farmer233.top/2021/09/05/A-distributed-with-Go/</id>
    <published>2021-09-04T16:21:43.000Z</published>
    <updated>2023-11-12T17:26:19.874Z</updated>
    
    <content type="html"><![CDATA[<p>从上学期开始，学校的教务系统更新了。新版的正方多了一个负载均衡的功能，但无奈实在做的太差了！为什么这么说尼？<br>因为在上学期抢课的时候入口网关依旧拉闸，而真正的后端服务器访问速度比德芙还丝滑。因此暂将锅甩给负载均衡服务器。既然学校的负载均衡拉闸，那么就有了 <strong>“帮学校做负载均衡”</strong> 的想法。<br>大体的思路就是，通过扫描内网网段发现隐藏的地址，然后负载均衡这些隐藏的地址。<br>既然是负载均衡，第一时间想到的就是<code>Nginx</code>了，通过资料搜集，大致确定了基本的流程，因此有了这么的这个流程图:</p><img src="/2021/09/05/A-distributed-with-Go/floatChart.dio.png" class="" title="floatChart"><span id="more"></span><h2 id="需要解决的问题"><a href="#需要解决的问题" class="headerlink" title="需要解决的问题"></a>需要解决的问题</h2><p>由于非官方的代理，因此我们无法知道教务系统部署在内网的哪些机器上，而校园网一般使用B类网，因此需要扫描大量的ip地址。<br>但这样无疑会触发学校网管的报警，正常情况下会导致ip短时间内被封。导致扫描质量低（由于被禁网，导致程序误认为扫描超时从而导致目标未被发现）。<br>基于这个问题，随之而生的想法就是分布式扫描，将扫描的工作打散到用户中，服务器只负责扫描几个主干网段。<br>一句话概括就是: <strong>将扫描工作分散到多台机器上</strong>，流程图如下：</p><img src="/2021/09/05/A-distributed-with-Go/microService.dio.png" class="" title="microService"><h2 id="Todo"><a href="#Todo" class="headerlink" title="Todo"></a>Todo</h2><blockquote><p>前情提示: 本文通信均采用HTTP、代码部分存在伪代码<br>代码仓库: (暂不开源)</p></blockquote><ol><li>注册中心 -&gt; <strong>服务注册</strong>与<strong>服务发现</strong></li><li>日志服务 -&gt; 记录日志</li><li>数据库服务 -&gt; 数据库操作(CRUD)</li><li>扫描器服务 -&gt; 发现教务系统地址</li><li>测试器服务 -&gt; 测试数据库中地址的<strong>健康度</strong></li><li>Api服务 -&gt; 向<code>consul</code>发送负载信息</li></ol><p>大致结构如下：</p><img src="/2021/09/05/A-distributed-with-Go/scanner.dio.png" class="" title="scanner"><h2 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h2><p>作为一个分布式系统，不可避免地需要<strong>服务注册</strong>与<strong>服务发现</strong>。因此需要一个<code>注册中心</code>来处理各个<code>服务</code>之间的依赖关系，在服务上线后通知依赖这个服务的服务(这里有点绕)<br><strong>举个例子</strong>:<br><code>数据库</code>的每个操作都需要记录日志，日志为了统一管理所以有一个<code>日志服务</code>专门处理日志信息。此时，<code>日志服务</code>因某些原因(可能是人为、也可能是网络掉线等)在<code>数据库服务</code>注册之后才注册，这是<code>注册中心</code>就需要通知<code>数据库</code>，让<code>数据库</code>的日志记录转成使用<code>日志服务</code>。</p><h3 id="功能与实现"><a href="#功能与实现" class="headerlink" title="功能与实现"></a>功能与实现</h3><p>作为一个注册中心，首先我们需要一个web服务来接收服务发送的信息(注册、依赖更新、注销等等)，但在这之前我们先来定义一下我们要用到的结构(在面向对象中为类)</p><ol><li><code>registry</code>来表示注册操作<ul><li><code>registrations</code>来存放注册的服务</li><li><code>add</code> 注册服务</li><li><code>notify</code> 事件通知</li><li><code>sendRequiredServices</code> 发送依赖的服务</li><li><code>sendPatch</code> 发送依赖项</li><li><code>remove</code> 移除(注销)服务</li><li><code>Heartbeat</code> 心跳包</li></ul></li><li><code>Registration</code>表示服务注册结构体<ul><li><code>ServiceName</code> 服务名</li><li><code>ServiceURL</code> 服务地址</li><li><code>RequiredServices</code>[数组]服务依赖项</li><li><code>ServiceUpdateURL</code> 服务与注册中心沟通的URL</li><li><code>HeartbeatURL</code> 心跳检测地址</li></ul></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> registry <span class="keyword">struct</span> &#123;</span><br><span class="line">registrations []Registration</span><br><span class="line">mutex         *sync.RWMutex</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 服务注册结构体</span></span><br><span class="line"><span class="keyword">type</span> Registration <span class="keyword">struct</span> &#123;</span><br><span class="line">ServiceName ServiceName</span><br><span class="line">ServiceURL  <span class="type">string</span></span><br><span class="line">RequiredServices []ServiceName</span><br><span class="line">ServiceUpdateURL <span class="type">string</span></span><br><span class="line">HeartbeatURL     <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ServiceName <span class="type">string</span></span><br><span class="line"><span class="comment">// 添加注册</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *registry)</span></span> add(reg Registration) <span class="type">error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当依赖服务运行时，通知依赖者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r registry)</span></span> notify(fullpatch patch) </span><br><span class="line"><span class="comment">// 注册中心向服务发送依赖相关内容</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r registry)</span></span> sendRequiredServices(reg Registration) <span class="type">error</span></span><br><span class="line"><span class="comment">// 发送依赖项</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r registry)</span></span> sendPatch(p patch, url <span class="type">string</span>) <span class="type">error</span></span><br><span class="line"><span class="comment">// 移除注册（注销）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *registry)</span></span> remove(url <span class="type">string</span>) <span class="type">error</span></span><br><span class="line"><span class="comment">// 心跳包</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *registry)</span></span> Heartbeat(freq time.Duration) </span><br></pre></td></tr></table></figure><p>既然注册中心是作为一个web服务实现的，那么肯定是需要一个<code>web server</code>的，由于项目属于玩票性质，也不算大因此使用Go内置的<code>net/http</code>来实现，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RegistryService <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s RegistryService)</span></span> ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Request received&quot;</span>)</span><br><span class="line"><span class="keyword">switch</span> r.Method &#123;</span><br><span class="line"><span class="keyword">case</span> http.MethodPost:</span><br><span class="line">decoder := json.NewDecoder(r.Body)</span><br><span class="line"><span class="keyword">var</span> r Registration</span><br><span class="line">err := decoder.Decode(&amp;r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusBadRequest)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">&quot;Adding service: %v with URL: %s\n&quot;</span>, r.ServiceName, r.ServiceURL)</span><br><span class="line">err = reg.add(r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusBadRequest)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> http.MethodDelete:</span><br><span class="line">payload, err := ioutil.ReadAll(r.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">url := <span class="type">string</span>(payload)</span><br><span class="line">log.Printf(<span class="string">&quot;Removing service at URL: %s&quot;</span>, url)</span><br><span class="line">err = reg.remove(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">w.WriteHeader(http.StatusMethodNotAllowed)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务组件"><a href="#服务组件" class="headerlink" title="服务组件"></a>服务组件</h2><p>对服务来说，就是根据注册中心定好的规则来注册服务，然后根据自身的依赖来处理对应的功能。<br>因为要处理相应的依赖，因此除了<code>Registration</code>外，再定义一个处理服务依赖的结构体及方法: <code>providers</code>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> providers <span class="keyword">struct</span> &#123;</span><br><span class="line">services <span class="keyword">map</span>[ServiceName][]<span class="type">string</span>   <span class="comment">// 服务名-&gt;服务url</span></span><br><span class="line">mutex    *sync.RWMutex</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更新依赖</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *providers)</span></span> Update(pat patch)</span><br><span class="line"><span class="comment">// // 通过服务名称，找到依赖的urls，从依赖项里面随机返回一个url</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p providers)</span></span> get(name ServiceName) (<span class="type">string</span>, <span class="type">error</span>)</span><br><span class="line"><span class="comment">// 导出给外部使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetProvide</span><span class="params">(name ServiceName)</span></span> (<span class="type">string</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure><h3 id="组件的web服务"><a href="#组件的web服务" class="headerlink" title="组件的web服务"></a>组件的web服务</h3><p>因为每个服务都需要使用<strong>注册</strong>这些通用的功能，且这部分的工作都是重复的，因此将web抽出来公用.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Start</span><span class="params">(ctx context.Context, host, port <span class="type">string</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">reg registry.Registration,</span></span></span><br><span class="line"><span class="params"><span class="function">RegisterHandlersFunc <span class="keyword">func</span>()</span></span>) (context.Context, <span class="type">error</span>) &#123;</span><br><span class="line"></span><br><span class="line">RegisterHandlersFunc()</span><br><span class="line">ctx = startService(ctx, reg.ServiceName, host, port)</span><br><span class="line">err := registry.RegisterService(reg)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ctx, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ctx, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startService</span><span class="params">(ctx context.Context, ServiceName registry.ServiceName,</span></span></span><br><span class="line"><span class="params"><span class="function">host, port <span class="type">string</span>)</span></span> context.Context &#123;</span><br><span class="line">ctx, cancel := context.WithCancel(ctx)</span><br><span class="line"><span class="keyword">var</span> srv http.Server</span><br><span class="line">srv.Addr = <span class="string">&quot;:&quot;</span> + port</span><br><span class="line">address := fmt.Sprintf(<span class="string">&quot;http://%s:%s&quot;</span>, host, port)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">log.Println(srv.ListenAndServe())</span><br><span class="line"><span class="comment">// 关闭的时候要取消注册</span></span><br><span class="line"><span class="comment">// ... todo</span></span><br><span class="line">err := registry.ShutdownService(address)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">cancel()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Service is running in %v\n&quot;</span>, address)</span><br><span class="line">fmt.Println(<span class="string">&quot;Registry service started. Press any key to stop.&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> s <span class="type">string</span></span><br><span class="line">fmt.Scanln(&amp;s)</span><br><span class="line">srv.Shutdown(ctx)</span><br><span class="line">err := registry.ShutdownService(address)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">cancel()</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> ctx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>至此，可以开始专心的写业务了</p></blockquote><h3 id="扫描器"><a href="#扫描器" class="headerlink" title="扫描器"></a>扫描器</h3><p>得益于Go高并发的优势，开启数百万个的<code>goroutine</code>的开销也不会很大，非常的轻量！🛫<br>因此代码实现起来很轻松，大体思路和<strong>端口扫描器</strong>类似，在此基础上根据目标特征添加判断条件即可<br>端口扫描器代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(ports <span class="keyword">chan</span> <span class="type">int</span>, results <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> p := <span class="keyword">range</span> ports &#123;</span><br><span class="line">address := fmt.Sprintf(<span class="string">&quot;192.168.2.122:%d&quot;</span>, p)</span><br><span class="line">fmt.Printf(<span class="string">&quot;start %s\n&quot;</span>, address)</span><br><span class="line">conn, err := net.DialTimeout(<span class="string">&quot;tcp&quot;</span>, address, time.Second*<span class="number">5</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">results &lt;- <span class="number">0</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">conn.Close()</span><br><span class="line">results &lt;- p</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ports := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">30000</span>)</span><br><span class="line">results := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>)</span><br><span class="line">scanEndPort := <span class="number">65535</span></span><br><span class="line"><span class="keyword">var</span> openPorts []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">cap</span>(ports); i++ &#123;</span><br><span class="line"><span class="keyword">go</span> worker(ports, results)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// push port to channel</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= scanEndPort; i++ &#123;</span><br><span class="line">ports &lt;- i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(ports)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= scanEndPort; i++ &#123;</span><br><span class="line">res := &lt;-results</span><br><span class="line"><span class="keyword">if</span> res != <span class="number">0</span> &#123;</span><br><span class="line">openPorts = <span class="built_in">append</span>(openPorts, res)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(results)</span><br><span class="line">sort.Ints(openPorts)</span><br><span class="line"><span class="keyword">for</span> _, port := <span class="keyword">range</span> openPorts &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%d opend\n&quot;</span>, port)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试器"><a href="#测试器" class="headerlink" title="测试器"></a>测试器</h3><p>测试器主要功能是从数据库中取出教务系统地址，然后测试。与扫描器不同仅在于扫描器是写，测试器是读。因此这部分内容和扫描器实际上是在同个包内的，只是逻辑上将它分离了出来。   </p><p>这部分其实和<code>consul</code>的功能是重复的，因此代码不过多赘述</p><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>由于校园网中，教务系统的地址不会太多，因此数据库的选择十分的随意(不存在性能方面的要求),所以这里使用自己熟悉的<code>redis</code>作为数据库。<br><strong>由于本系统是和官方的负载均衡并行的</strong> 因此存在某些结点用于两者共同访问导致压力上涨，响应不及时，因此利用<code>redis</code>的<code>sorted-set</code>在测试的时候，将响应快的地址设置高分数，使用<code>sorted-sets</code>的好处还有一个就是，集合的元素都是不重复的！，对于代理池来说，这个分数代表着教务系统地址稳定性的重要标准，因此设置分数的规则如下：</p><ul><li>基本分：10分，最高分：20</li><li>测试器设置一个更严格的超时时间来判断结点是否流畅</li><li>分数<strong>基本分</strong>为可用，检测器会定时循环检测每个代理可用情况，一旦检测到有可用的代理则立即置为<strong>最高分</strong></li><li>新获取的代理分数设置为<strong>基本分</strong>，如果测试可行(流畅)则置为满分，不可行(超时)则分数减一</li><li>分数减到0后代理移除</li></ul><p>由于是内网环境，分数与超时时间可以根据实际情况设置更严格</p><p>主要功能就是简单的CRUD啦，本文只讲逻辑与伪代码，实现部分就不多说了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set jwglxt to max score</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(addr discover.Addr)</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line">member, err := addr.MarshalBinary()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">err = rdb.ZAdd(ctx, redisConfig.Key, &amp;redis.Z&#123;</span><br><span class="line">Score:  SCORE_MAX,</span><br><span class="line">Member: member,</span><br><span class="line">&#125;).Err()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// decrease proxy score</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decrease</span><span class="params">(addr discover.Addr)</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line">member, err := addr.MarshalBinary()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">err = rdb.ZIncrBy(ctx, redisConfig.Key, <span class="number">-1</span>, <span class="type">string</span>(member)).Err()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">score := rdb.ZScore(ctx, redisConfig.Key, <span class="type">string</span>(member))</span><br><span class="line"><span class="keyword">if</span> score.Val() &lt;= <span class="number">0.00</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;%v current score %v, remove.\n&quot;</span>, addr, score.Val())</span><br><span class="line">err := rdb.ZRem(ctx, redisConfig.Key, member).Err()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// add new proxy to redis</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(addrs discover.Addrs)</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> _, addr := <span class="keyword">range</span> addrs &#123;</span><br><span class="line">buf, err := addr.MarshalBinary()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">err = rdb.ZAdd(ctx, redisConfig.Key, &amp;redis.Z&#123;</span><br><span class="line">Score:  SCORE_DEFAULT,</span><br><span class="line">Member: buf,</span><br><span class="line">&#125;).Err()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="consul-upsync-nginx实现动态负载均衡"><a href="#consul-upsync-nginx实现动态负载均衡" class="headerlink" title="consul-upsync-nginx实现动态负载均衡"></a>consul-upsync-nginx实现动态负载均衡</h2><p>该部分可以说是系统实现的关键了，因为<code>nginx</code>自带的负载均衡是写死的，不能根据后端情况动态调整，通过一番搜索对比，最终决定了<code>consul</code> + <code>upsync</code>方案。   </p><ol><li><code>upsync</code> 一个Nginx的模块(扩展)</li><li><code>consul</code> 一个分布式高可用的系统</li></ol><p>这部分仅限于“能用”阶段，笔者也不太懂，就不乱说啦！<br>主要就是<strong>Api服务</strong>定时的获取数据库内容(分数作为权重)，然后推送到<strong>consul</strong>中</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>该项目是学习Go时的一个练手项目，很多地方都不太好，因此仓库就不开源了🐕</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;从上学期开始，学校的教务系统更新了。新版的正方多了一个负载均衡的功能，但无奈实在做的太差了！为什么这么说尼？&lt;br&gt;因为在上学期抢课的时候入口网关依旧拉闸，而真正的后端服务器访问速度比德芙还丝滑。因此暂将锅甩给负载均衡服务器。既然学校的负载均衡拉闸，那么就有了 &lt;strong&gt;“帮学校做负载均衡”&lt;/strong&gt; 的想法。&lt;br&gt;大体的思路就是，通过扫描内网网段发现隐藏的地址，然后负载均衡这些隐藏的地址。&lt;br&gt;既然是负载均衡，第一时间想到的就是&lt;code&gt;Nginx&lt;/code&gt;了，通过资料搜集，大致确定了基本的流程，因此有了这么的这个流程图:&lt;/p&gt;
&lt;img src=&quot;/2021/09/05/A-distributed-with-Go/floatChart.dio.png&quot; class=&quot;&quot; title=&quot;floatChart&quot;&gt;</summary>
    
    
    
    <category term="搞事情" scheme="https://blog.farmer233.top/categories/%E6%90%9E%E4%BA%8B%E6%83%85/"/>
    
    
    <category term="Golang" scheme="https://blog.farmer233.top/tags/Golang/"/>
    
    <category term="爬虫" scheme="https://blog.farmer233.top/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="正方教务系统" scheme="https://blog.farmer233.top/tags/%E6%AD%A3%E6%96%B9%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="nginx" scheme="https://blog.farmer233.top/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>新版正方教务系统登录实现</title>
    <link href="https://blog.farmer233.top/2021/09/03/%E6%96%B0%E7%89%88%E6%AD%A3%E6%96%B9%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%E7%99%BB%E5%BD%95%E5%AE%9E%E7%8E%B0/"/>
    <id>https://blog.farmer233.top/2021/09/03/%E6%96%B0%E7%89%88%E6%AD%A3%E6%96%B9%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%E7%99%BB%E5%BD%95%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-09-03T04:38:19.000Z</published>
    <updated>2023-11-12T17:26:19.946Z</updated>
    
    <content type="html"><![CDATA[<p>最近开学后相信很多同学都发现课表小程序等无法使用了，这是因为学校更新了正方教务系统，导致了大批基于旧版正方系统的校园小程序无法继续爬取课表。</p><p>之前曾在GitHub上看到过本校师兄开发的<code>school-api</code>–一个基于旧版正方的python SDK，但新版无法使用。因此花了两天时间研究了下新版正方的登录(能登录后续的就EZ啦~) </p><p>既然都弄了，因此计划开发一个新的SDK。我比较懒 暂命名为<code>new-school-sdk</code>，项目目前还在开发中，先将登录的流程、验证码识别的思路罗列出来。(拿到了cookies 还有啥不能干嘛)</p><p>项目Github地址: <a href="https://github.com/Farmer-chong/new-school-sdk">https://github.com/Farmer-chong/new-school-sdk</a> </p><h2 id="登录前期准备"><a href="#登录前期准备" class="headerlink" title="登录前期准备"></a>登录前期准备</h2><img src="/2021/09/03/%E6%96%B0%E7%89%88%E6%AD%A3%E6%96%B9%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%E7%99%BB%E5%BD%95%E5%AE%9E%E7%8E%B0/zf-index.png" class="" title="zf-index"><p>通过观察发现，有以下几个难点：</p><ol><li>新版正方使用Java进行开发且并非前后端分离，因此只要我们能拿到<code>cookie</code>即能完成登录。</li><li>验证码的识别</li><li>正方使用了Rsa对数据进行加密</li></ol><p>针对上述问题，开始一一解决</p><h2 id="验证码部分"><a href="#验证码部分" class="headerlink" title="验证码部分"></a>验证码部分</h2><p>前置工作准备好后，开始从服务器获取验证码并进行验证</p><h3 id="获取验证码"><a href="#获取验证码" class="headerlink" title="获取验证码"></a>获取验证码</h3><p>网络抓包发现，验证码是异步获取的，每次刷新都会发送一个请求到<code>/zfcaptchaLogin</code></p><img src="/2021/09/03/%E6%96%B0%E7%89%88%E6%AD%A3%E6%96%B9%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%E7%99%BB%E5%BD%95%E5%AE%9E%E7%8E%B0/network-captcha.png" class="" title="captcha"><p>请求报文内容有：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;type&quot;: &quot;refresh&quot;</span><br><span class="line">&quot;rtk&quot;: &quot;56f88546-d402-4afd-88b5-82a203258da8&quot;</span><br><span class="line">&quot;time&quot;: &quot;1630645045207&quot;</span><br><span class="line">&quot;instanceId&quot;: &quot;zfcaptchaLogin&quot;</span><br></pre></td></tr></table></figure><p>响应报文内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">imtk: &quot;29730cb5-d7ff-4fc9-aa9d-e3efc0a07f55&quot;</span><br><span class="line">mi: &quot;a8f191af-f267-4681-881a-54558298db09.png&quot;</span><br><span class="line">msg: &quot;&quot;</span><br><span class="line">si: &quot;1ccd27c6-6208-41f9-adfb-13beafa6d954.png&quot;</span><br><span class="line">status: &quot;success&quot;</span><br><span class="line">t: 1630645937179</span><br><span class="line">vs: &quot;not_verify&quot;</span><br></pre></td></tr></table></figure><p>观察请求报文发现需要<code>type</code>、<code>rtk</code>、<code>time</code>和<code>instanceId</code>这几个字段。</p><p>其中<code>rtk</code>未知，因此开始寻找其出现的地方。通过查找发现rtk出现在一个js文件中，初步猜测<code>rtk</code>是一个令牌，由服务器随机生成的。<br>因此我们要先获取<code>rtk</code>令牌，然后利用正则表达式将其值提取出来。</p><img src="/2021/09/03/%E6%96%B0%E7%89%88%E6%AD%A3%E6%96%B9%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%E7%99%BB%E5%BD%95%E5%AE%9E%E7%8E%B0/network-find-rtk.png" class="" title="rtk"><h3 id="下载验证图片"><a href="#下载验证图片" class="headerlink" title="下载验证图片"></a>下载验证图片</h3><p>但现在仍然无法获取验证图片的原始数据，再观察<code>img</code>的<code>src</code>属性，得知响应报文中的<code>mi</code>和<code>si</code>分别别是<code>验证码</code>和<code>滑块</code>。并且需要的url参数我们也已经获取了。</p><p>向<code>/zfcaptchaLogin</code>发送一个<code>GET</code>请求，请求参数如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type: image</span><br><span class="line">id: 上一步响应体中的si</span><br><span class="line">imtk: 上一步响应体中的imtk</span><br><span class="line">t: 时间戳</span><br><span class="line">instanceId: zfcaptchaLogin</span><br></pre></td></tr></table></figure><h3 id="滑动验证码识别"><a href="#滑动验证码识别" class="headerlink" title="滑动验证码识别"></a>滑动验证码识别</h3><p>上文中有提到，参考这篇文章: <a href="https://blog.dairoot.cn/2021/06/26/zf-sliding-captcha/">https://blog.dairoot.cn/2021/06/26/zf-sliding-captcha/</a></p><p>大致流程如下：</p><ol><li>将图片灰度化</li><li>识别出一段颜色差小于阈值的线(竖的)</li><li>识别出来的这段线不能太短(要和缺口差不多高)</li></ol><p>因此即可计算出该线的x轴坐标，因此得到滑块偏移量。  </p><h3 id="模拟人手拖动-amp-发起验证请求"><a href="#模拟人手拖动-amp-发起验证请求" class="headerlink" title="模拟人手拖动&amp;发起验证请求"></a>模拟人手拖动&amp;发起验证请求</h3><p>从上一步中，我们得到了偏移量<code>X</code>和<code>Y</code>，接下来就要开始模拟人手拖动滑块的过程了。人手滑动验证码时，一般都是先快后慢的一个速度曲线，因此利用物理学公式分段设置加速度<code>a</code>，前半段<code>a &gt; 0</code>，后半段<code>a &lt; 0</code>。<br>当前速度用<code>v</code>表示，初速度用<code>v0</code>，位移用<code>x</code>，时间用<code>t</code>，它们之间满足如下关系：<br><code>x = v0 * t + 0.5 * a * t^2</code><br><code>v = v0 + a * t</code><br>移动算法的代码实现如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_get_track</span>(<span class="params">self, distance, y</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;模拟人手滑动</span></span><br><span class="line"><span class="string">    通过设置前快后慢的加速度，模拟人手滑动</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        distance ([int]): [移动距离]</span></span><br><span class="line"><span class="string">        y ([int]): [滑块Y值]</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        [list]: [坐标数组]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    start = <span class="number">1200</span></span><br><span class="line">    current = <span class="number">0</span></span><br><span class="line">    track = []</span><br><span class="line">    <span class="comment"># 减速阈值</span></span><br><span class="line">    mid = distance * <span class="number">4</span> / <span class="number">5</span></span><br><span class="line">    <span class="comment"># 计算间隔</span></span><br><span class="line">    t = <span class="number">0.2</span></span><br><span class="line">    <span class="comment"># 初速度</span></span><br><span class="line">    v = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> current &lt; distance:</span><br><span class="line">        <span class="comment"># 加速-&gt;加速度为 2; 减速-&gt;加速度为-3</span></span><br><span class="line">        a = <span class="number">2</span> <span class="keyword">if</span> current &lt; mid <span class="keyword">else</span> -<span class="number">3</span></span><br><span class="line">        v0 = v</span><br><span class="line">        <span class="comment"># 当前速度 v = v0 + at</span></span><br><span class="line">        v = v0 + a * t</span><br><span class="line">        <span class="comment"># 移动距离 x = v0t + 1/2 * a * t^2</span></span><br><span class="line">        move = v0 * t + <span class="number">1</span> / <span class="number">2</span> * a * t * t</span><br><span class="line">        <span class="comment"># 当前位移量</span></span><br><span class="line">        current += move</span><br><span class="line">        <span class="comment"># 加入轨迹</span></span><br><span class="line">        track.append(&#123;<span class="string">&quot;x&quot;</span>: start + <span class="built_in">int</span>(current), <span class="string">&quot;y&quot;</span>: y, <span class="string">&quot;t&quot;</span>: <span class="built_in">int</span>(time.time() * <span class="number">1000</span>)&#125;)</span><br><span class="line">        time.sleep(<span class="number">0.01</span>)</span><br><span class="line">    <span class="keyword">return</span> track</span><br></pre></td></tr></table></figure><p>至此，我们得到了发起请求的所有数据，因此向<code>/zfcaptchaLogin</code>发送一个<code>POST</code>请求，请求体如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type: verify</span><br><span class="line">rtk: 56f88546-d402-4afd-88b5-82a203258da8</span><br><span class="line">time: 1630650071446</span><br><span class="line">mt: 将模拟滑动的内容通过base64编码</span><br><span class="line">instanceId: zfcaptchaLogin</span><br><span class="line">extend: 将UA进行编码</span><br></pre></td></tr></table></figure><p>当验证通过时，得到如下的响应体:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">msg: &quot;&quot;</span><br><span class="line">status: &quot;success&quot;</span><br><span class="line">vs: &quot;verified&quot;</span><br></pre></td></tr></table></figure><h2 id="登录部分"><a href="#登录部分" class="headerlink" title="登录部分"></a>登录部分</h2><h3 id="获取RSA公钥"><a href="#获取RSA公钥" class="headerlink" title="获取RSA公钥"></a>获取RSA公钥</h3><p>通过查看页面源码和点击登录后抓包，登录发送一个请求到<code>/xtgl/login_slogin.html</code>，然后返回一个302的跳转。<br>其中请求报文内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">csrftoken: csrftoken</span><br><span class="line">language: zh_CN</span><br><span class="line">yhm: 登录账号</span><br><span class="line">mm: 加密后的密码</span><br><span class="line">mm: 加密后的密码</span><br></pre></td></tr></table></figure><p>此处<code>csrftoken</code>和<code>mm</code>两个字段是未知的。其中<code>csrf</code>令牌是为了防止攻击的，一般包含在<code>form</code>表单中，由后端生成。因此我们可以直接从页面中提取。如下图：</p><img src="/2021/09/03/%E6%96%B0%E7%89%88%E6%AD%A3%E6%96%B9%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%E7%99%BB%E5%BD%95%E5%AE%9E%E7%8E%B0/csrftoken.png" class="" title="csrftoken"><p>而<code>mm</code>字段，通过对前端异步请求部分的代码进行分析后，发现是利用<code>RSA</code>进行加密，从抓包中可以发现一个发送到<code>/login_getPublicKey.html</code>地址的<code>GET</code>请求。其响应体内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exponent: &quot;AQAB&quot;</span><br><span class="line">modulus: &quot;AIdzVtHXJLlh5vOlWFiRnWHc1xaChgqY1u4LNpaMjVUByVHwdvMMmlw4np8u/B3esIS2hsdQ7nRkrzWYYbkTWo8bm2LGS0H3/h1GVjLWaMrn1uj6lMYz0Y0O0AMUc19y23XRnSM7Q/d9V7tk6oS1HwyUKJwA7aSTgyenhNj26XrL&quot;</span><br></pre></td></tr></table></figure><p>因此得到了<code>RSA</code>的<code>指数</code>和<code>模</code>，但这里的<code>modulus</code>长度为 172。大概率是正方修改过加密，在<code>JavaScript</code>文件的注释中也可以看到。<br>本来是打算自己重写一个python版的实现，后来在<code>GitHub</code>上发现已有前人栽树，我乘凉就好啦！ </p><blockquote><p>PyRsa仓库: <a href="https://github.com/hibiscustoyou/pyrsa">https://github.com/hibiscustoyou/pyrsa</a></p></blockquote><p>到现在为止，整个登录流程的未知项就全解决了！🛫🍯</p><h3 id="开始登录"><a href="#开始登录" class="headerlink" title="开始登录"></a>开始登录</h3><p>再次观察数据包的流程，得知登录各项的顺序并做优化：</p><p><strong>! 注意，在登录发生302跳转的时候，cookie会发生改变 !</strong></p><ol><li>访问登录页面，获取<code>csrf</code>和原始的<code>cookies</code></li><li>获取<code>rsa</code>公钥</li><li>处理滑块验证</li><li>发起登录，得到登录后的<code>cookie</code></li></ol><p>成功截图：</p><img src="/2021/09/03/%E6%96%B0%E7%89%88%E6%AD%A3%E6%96%B9%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%E7%99%BB%E5%BD%95%E5%AE%9E%E7%8E%B0/login.png" class="" title="login"><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>sdk开发中，希望大佬们多多给意见或者一起开发哈！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近开学后相信很多同学都发现课表小程序等无法使用了，这是因为学校更新了正方教务系统，导致了大批基于旧版正方系统的校园小程序无法继续爬取课表。&lt;/p&gt;
&lt;p&gt;之前曾在GitHub上看到过本校师兄开发的&lt;code&gt;school-api&lt;/code&gt;–一个基于旧版正方的pytho</summary>
      
    
    
    
    <category term="搞事情" scheme="https://blog.farmer233.top/categories/%E6%90%9E%E4%BA%8B%E6%83%85/"/>
    
    
    <category term="爬虫" scheme="https://blog.farmer233.top/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="正方教务系统" scheme="https://blog.farmer233.top/tags/%E6%AD%A3%E6%96%B9%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="python" scheme="https://blog.farmer233.top/tags/python/"/>
    
    <category term="web" scheme="https://blog.farmer233.top/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>Golang基础语法笔记 | 数组、切片&amp;映射</title>
    <link href="https://blog.farmer233.top/2021/08/20/Golang%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    <id>https://blog.farmer233.top/2021/08/20/Golang%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0/</id>
    <published>2021-08-19T16:30:25.000Z</published>
    <updated>2023-11-12T17:26:19.890Z</updated>
    
    <content type="html"><![CDATA[<p>Go入门和《Go语言实战》的笔记，本篇总结了基础的数组、切片和哈希表的内容。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是切片和映射的基础数据结构，因此了解数组的工作原理有助于理解切片和映射。<br>和C语言一样，在go中数组也是一段<strong>连续</strong>、<strong>长度固定</strong>用于存储<strong>同一类型</strong>元素的连续块。</p><h3 id="声明和初始化"><a href="#声明和初始化" class="headerlink" title="声明和初始化"></a>声明和初始化</h3><p>数组的声明和初始化，和其他类型差不多。声明的原则是：</p><ol><li>指明存储数据的类型。</li><li>存储元素的数量，也就是数组长度。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array [<span class="number">5</span>]<span class="type">int</span></span><br></pre></td></tr></table></figure></li></ol><p>声明变量时，总会使用对应类型的灵芝累对变量进行初始化，如上面的代码声明了一个数组<code>array</code>，但我们还没有对他进行初始化，此时这个数组内的值，就是对应类型的零值&#x3D;&gt; 这里的对应类型时<code>int</code>，因此改数组目前为5个0 <code>[0,0,0,0,0]</code><br>由于数组初始化后长度是固定的，如果需要存储更多的元素则需要进行扩容。也就是需要再创建一个更长的数组，再把原来的数组复制到新数组里面。    </p><p>上面的数组仅仅只是<strong>声明</strong>，go还可以很方便的<strong>初始化并声明</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><p>上面的这段代码相当于下面:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array [<span class="number">5</span>]<span class="type">int</span></span><br><span class="line">array = [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><p>除此之外，go语言还能自动计算声明数组的长度，也就是根据内容，自动分配长度</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array := [...]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br></pre></td></tr></table></figure><p>有的时候我们已知数组的长度，但内容只知道个别几个，我们可以用下面这种方式:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>: <span class="number">10</span>, <span class="number">3</span>: <span class="number">30</span>&#125;</span><br></pre></td></tr></table></figure><p>这样我们声明了一个长度为<code>5</code>的数组，并且初始化索引为<code>1</code>和<code>3</code>的元素</p><h3 id="使用数组"><a href="#使用数组" class="headerlink" title="使用数组"></a>使用数组</h3><p>数组使用上和别的语言没有太大的差异，主要就是通过下标访问。值得关心的是，Go语言的指针数组十分的好用<br><strong>将一个指针数组赋值给另一个</strong>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 [<span class="number">3</span>]*<span class="type">string</span></span><br><span class="line"></span><br><span class="line">arr2 := [<span class="number">3</span>]*<span class="type">string</span>&#123;<span class="built_in">new</span>(<span class="type">string</span>), <span class="built_in">new</span>(<span class="type">string</span>), <span class="built_in">new</span>(<span class="type">string</span>)&#125;</span><br><span class="line"></span><br><span class="line">*arr2[<span class="number">0</span>] = <span class="string">&quot;Red&quot;</span></span><br><span class="line">*arr2[<span class="number">1</span>] = <span class="string">&quot;Blue&quot;</span></span><br><span class="line">*arr2[<span class="number">2</span>] = <span class="string">&quot;Green&quot;</span></span><br><span class="line"><span class="comment">// 复制</span></span><br><span class="line">arr1 = arr2</span><br></pre></td></tr></table></figure><p>此时复制后的两个数组则指向同一组字符串了。</p><h3 id="函数间传递数组"><a href="#函数间传递数组" class="headerlink" title="函数间传递数组"></a>函数间传递数组</h3><p>在函数间传递变量时，总是以值的方式传递（也就是值传递）。因此在函数间传递数组是一个开销很大的操作–比如有个占用<code>8M</code>内存的数组，那么每次调用这个函数的时候go都会在栈上分配8MB的内存，试想一下同时调用100次这个函数，占用的内存会多么的惊人。<br>虽然Go自己会处理复制的这个操作，但还有一种更优雅的方法来处理这个操作，这个方法在C中十分的常见-&gt;<strong>传入指向数组的指针</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配一个8MB的数组</span></span><br><span class="line"><span class="keyword">var</span> arr [le6]<span class="type">int</span></span><br><span class="line"></span><br><span class="line">foo(&amp;arr)</span><br><span class="line"></span><br><span class="line">fun foo(arr *[le6]<span class="type">int</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是传递数组的指针的例子，会发现数组被修改了。所以这种情况虽然节省了复制的内存，但是要谨慎使用，因为一不小心，就会修改原数组，导致不必要的问题。</p><blockquote><p>这里注意，数组的指针和指针数组是两个概念，数组的指针是<code>*[5]int</code>,指针数组是<code>[5]*int</code>，注意<code>*</code>的位置。</p></blockquote><p>针对函数间传递数组的问题，比如复制问题，比如大小僵化问题，都有更好的解决办法，这个就是切片，它更灵活。</p><h2 id="切片-Slice"><a href="#切片-Slice" class="headerlink" title="切片(Slice)"></a>切片(Slice)</h2><p>切片是一种数组结构，它是围绕动态数组的概念构建的（⚠<strong>和python的切片不完全相同</strong>）。切片可以按需自动增长和缩小，因为切片底层内存也是在连续的块中分配的，所以切片还有索引、迭代以及垃圾回收等好处</p><h3 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h3><p>切片的底层是数组，切片本身非常的小，它是对底层数组进行了抽象。切片有3个字段的数据结构，包含了Go需要操作数组的元数据。<br>这三个字段分别是<code>指向底层数组的指针</code>、<code>长度(切片能访问元素的个数)</code>和<code>切片总体的容量(真实容量)</code></p><blockquote><p>为了解决数组长度不可变，切片实际上就是提前声明了一个更长的数组(即切片的容量)，而切片的长度表示当前切片内能访问的元素的数量。</p></blockquote><p><strong>因此切片有这样一条公式：</strong><code>长度&lt;=容量</code></p><h3 id="声明-amp-初始化-amp-使用"><a href="#声明-amp-初始化-amp-使用" class="headerlink" title="声明&amp;初始化&amp;使用"></a>声明&amp;初始化&amp;使用</h3><p><strong>1. make和切片字面量</strong></p><p>使用<code>make</code>函数时，需要传入一个参数，指定切片的长度</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个长度和容量都是5的字符串切片</span></span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>前面说到，切片的长度和容量是两个不一样的概念，因此创建的时候也可以指定<code>长度</code>和<code>容量</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 长度为3，容量为5</span></span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>除了使用<code>make</code>函数，我们还可以使用切片<strong>字面量</strong>来声明切片–指定初始化的值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><p>可以发现切片和创建数组非常像，只不过不用指定<code>[]</code>中的值。  <strong>注意</strong>此时切片的长度和容量是相等的，并且会根据我们指定额字面量推到出来，当然我们也可以只初始化某个索引的值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice := []<span class="type">int</span>&#123;<span class="number">2</span>: <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 空切片和nil切片</strong><br>有的时候我们需要声明一个值为<code>nil</code>的切片(nil切片)。只要在声明式不做初始化就可以了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice []<span class="type">int</span></span><br></pre></td></tr></table></figure><p>空切片和nil切片不同的地方在于，空切片的底层数组包含0个元素，也就是说没有分配任何存储空间。<br>但切片里面的<strong>指向底层数组的指针</strong>是有内容的，而nil切片<strong>指向底层数组的指针</strong>则为nil</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><strong>3. 使用切片</strong><br>go的切片用法上和python的类似，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">slice := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">newSlice := slice[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"><span class="comment">// newSlice -&gt; 2,3</span></span><br></pre></td></tr></table></figure><p>需要注意，第一个切片因为使用字面量的方式，因此它的长度和容量都为5。不过之后的<code>newSlice</code>就不一样了，对于<code>newSlice</code>来说其底层数组的容量只有4个元素，切片长度为2。根据下面的公式，可以计算任意切片的长度和容量:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对于底层数组容量为K的切片 slice[i:j] </span><br><span class="line">长度: j - i</span><br><span class="line">容量: k - i</span><br></pre></td></tr></table></figure><blockquote><p>由于切片是在元切片的基础上的抽象，因此新的切片和旧切片实际上指向的是同一个数组，故修改同一个索引的内容时会导致原切片的内容发生改变</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">array := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">newSlice := array[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"><span class="comment">// array -&gt; 1,2,3,4,5</span></span><br><span class="line"><span class="comment">// newSlice -&gt; 2, 3</span></span><br><span class="line">newSlice[<span class="number">1</span>] = <span class="number">233</span></span><br><span class="line"><span class="comment">//  array -&gt; 1,2,233,4,5</span></span><br><span class="line"><span class="comment">//  newSlice -&gt; 2, 233</span></span><br></pre></td></tr></table></figure><p><strong>三个索引的切片</strong><br>创建切片时，第三个索引选项可以用来<strong>控制新切片的容量</strong>。⚠其目的并不是增加容量，而时限制容量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">source := []<span class="type">string</span>&#123;<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Plum&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Grape&quot;</span>&#125;</span><br><span class="line"><span class="comment">// 数组: [2:3)  ; 容量: [2, 4)</span></span><br><span class="line"><span class="comment">// 因此长度: 1; 容量: 2</span></span><br><span class="line">slice := source[<span class="number">2</span>:<span class="number">3</span>:<span class="number">4</span>]</span><br></pre></td></tr></table></figure><p><strong>第三个选项也不可以超出索引范围!!!</strong></p><h3 id="切片增长"><a href="#切片增长" class="headerlink" title="切片增长"></a>切片增长</h3><p>按需增长可以说是切片的一个重要的特性。Go内置的<code>append</code>函数会处理增长长度时所有的操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slice := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">newSlice := slice[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">newSlice = <span class="built_in">append</span>(newSlice, <span class="number">60</span>)</span><br></pre></td></tr></table></figure><p>因为<code>newSlice</code>在底层数组里还有额外的容量可用，append会将可用的元素合并到切片的长度，并对其进行赋值。由于和原始的<code>slice</code>共享同一个底层数组，slice中索引为3的元素的值也被改动了。<br>如果底层数组没有足够的可用容量，append会创建一个新的底层数组，将被引用的现有值复制到新数组里，再追加新的值。</p><blockquote><p>append会智能地处理底层数组地容量增长，当切片容量小于1000个元素时总会成倍地增加容量，超过1000后容量的增长因子设为1.25(增长算法不恒定)</p></blockquote><p>此外，通过<code>...</code>操作符，把一个切片追加到另一个切片里。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slice := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">newSlice := slice[<span class="number">1</span>:<span class="number">2</span>:<span class="number">3</span>]</span><br><span class="line">newSlice = <span class="built_in">append</span>(newSlice, slice...)</span><br></pre></td></tr></table></figure><h3 id="迭代切片"><a href="#迭代切片" class="headerlink" title="迭代切片"></a>迭代切片</h3><p>切片是一个集合，我们就可以迭代其中的元素。与python类似，Go有个特殊的关键字<code>range</code>，它可以配合<code>for</code>来迭代切片里的元素。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">slice := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i,v:=<span class="keyword">range</span> slice&#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;index:%d, value:%d\n&quot;</span>,i,v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中可以看到，迭代的时候会返回两个值: <code>index</code>和<code>value</code>，这里的<code>value</code>是一个副本。<br>需要强调的是，range创建了每个元素的<strong>副本</strong>，而不是直接返回该元素的引用。<br>很多时候，我们使用迭代都不需要索引<code>index</code>，此时可以使用占位符<code>_</code>来忽略这个值:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">slice := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">for</span> _,v:=<span class="keyword">range</span> slice&#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;value:%d\n&quot;</span>, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>range</code>总是从头开始迭代。如果需要更多的控制，依旧可以使用传统的for循环：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">slice := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="keyword">for</span> index := <span class="number">2</span>; index &lt; <span class="built_in">len</span>(slice); index++&#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Index: %d Value: %d\n&quot;</span>, index, slice[index])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output</span></span><br><span class="line">Index: <span class="number">2</span> Value: <span class="number">3</span></span><br><span class="line">Index: <span class="number">3</span> Value: <span class="number">4</span></span><br></pre></td></tr></table></figure><p>有两个特殊的内置函数<code>len</code>可以用于处理数组、切片和通道。对于切片来说，<code>len</code>返回切片的长度，<code>cap</code>返回切片的容量。</p><h3 id="函数间传递"><a href="#函数间传递" class="headerlink" title="函数间传递"></a>函数间传递</h3><p>在函数间传递切片的时候，就是要以值的方式传递切片，因为切片的尺寸很小，在函数间复制和传递切片成本也很低。（因为切片的数据结构只是一个指向数组的指针、长度和容量，不是把整个数组复制）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>, le6)</span><br><span class="line">slice = foo(slice)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(slice []<span class="type">int</span>)</span></span> []<span class="type">int</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> slice</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="映射-Map"><a href="#映射-Map" class="headerlink" title="映射(Map)"></a>映射(Map)</h2><p>正如标题所示，在《Go语言实战》中Map翻译成映射，相比于翻译相信Map更广为人知。<br>Map是一种数据结构(哈希表 or 散列表)，用来存储一系列的<strong>键值对</strong>，如果你学习过别的语言相信看到这你就明白Map是什么了。在<code>python</code>中这样的数据结构称为<code>dict(字典)</code>、<code>JavaScript</code>中称为<code>json(JavaScript Object Notation)</code></p><h3 id="内部实现-1"><a href="#内部实现-1" class="headerlink" title="内部实现"></a>内部实现</h3><p>Map是Go语言中哈希表的实现，因此我们每次迭代Map时打印的Key和Value时无序的，每次迭代都是不一样的。   </p><p>Map的散列表中包含一组桶，在存储、删除或查找键值对的时候，所有操作都要线选择一个桶，如何选择桶？就是先把要查找的<code>key</code>传给哈希函数，从而<strong>生成一个索引</strong>，进而找到对应的桶。</p><p>因此随着<em>映射</em>的增加，索引会分布的越来越均匀，因此访问键值对的速度就越快。（参考哈希表相关内容）由于本文主要是学习Go基础，因此不再继续深入，只要记住<strong>Map是无序的</strong></p><h3 id="声明-amp-初始化"><a href="#声明-amp-初始化" class="headerlink" title="声明&amp;初始化"></a>声明&amp;初始化</h3><p>Map的创建有如下几种方式：</p><ol><li><code>make</code>函数声明<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br></pre></td></tr></table></figure></li><li><code>map</code>字面量<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不指定任何键值对-&gt;也就是一个空map</span></span><br><span class="line">dict := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line"><span class="comment">// 赋予内容</span></span><br><span class="line">dict := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;张三&quot;</span>:<span class="number">43</span>&#125;</span><br><span class="line"><span class="comment">// 多个内容</span></span><br><span class="line">dict := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;张三&quot;</span>:<span class="number">43</span>,<span class="string">&quot;李四&quot;</span>:<span class="number">50</span>&#125;</span><br></pre></td></tr></table></figure></li></ol><p>Map的键可以是任何值，键的类型可以是内置的类型，也可以是结构类型，但是不管怎么样，这个键可以使用<code>==</code>运算符进行比较，所以像切片、函数以及含有切片的结构类型就不能用于Map的键了，因为他们具有引用的语义，不可比较。</p><blockquote><p>总结: 对于Map的值来说没有什么限制，但切片这种类型在键里不能用的，可以用在值里</p></blockquote><h3 id="使用Map"><a href="#使用Map" class="headerlink" title="使用Map"></a>使用Map</h3><p>Go语言的Map和别的语言都大同小异，使用非常简单和数组切片差不多   </p><p>如果键张三存在，则对其值修改，如果不存在，则新增这个键值对</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dict := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">dict[<span class="string">&quot;张三&quot;</span>] = <span class="number">43</span></span><br><span class="line">age := dict[<span class="string">&quot;张三&quot;</span>]</span><br></pre></td></tr></table></figure><p>很多时候我们都要判断Map中是否存在某个键值对.在Go Map中，如果我们获取一个不存在的键的值，也是可以的，返回的是<em>值类型</em>的零值，这样就会导致我们不知道是真的存在一个为零值的键值对呢，还是说这个键值对就不存在。对此，Map为我们提供了检测一个键值对是否存在的方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">age, exist := dict[<span class="string">&quot;李四&quot;</span>]</span><br><span class="line"><span class="keyword">if</span> exist &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看这个例子，和获取键的值没有太大区别，只是多了一个返回值。第一个返回值是键的值；第二个返回值标记这个键是否存在，这是一个boolean类型的变量，我们判断它就知道该键是否存在了。这也是Go多值返回的好处。</p><p>如果我们想删除一个键值对，可以使用内置的<code>delete</code>函数, <code>delete</code>函数接受两个参数，第一个是要操作的Map，第二个是要删除的Map的键。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(dict,<span class="string">&quot;张三&quot;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>delete函数删除不存在的键也是可以的，只是没有任何作用。</p></blockquote><p>在Go中，我们可以使用<code>range</code>迭代Map，这和遍历切片是一样的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dict := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;张三&quot;</span>: <span class="number">43</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> dict &#123;</span><br><span class="line">fmt.Println(key, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>rang</code>返回两个值，这和python是类似的，第一个是键，第二个是值。</p><h3 id="在函数间传递Map"><a href="#在函数间传递Map" class="headerlink" title="在函数间传递Map"></a>在函数间传递Map</h3><p>函数间传递Map是不会制造副本的，也就是说如果一个Map传递给一个函数，该函数对这个Map做了修改，那么这个Map的所有引用都会被修改。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">dict := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;王五&quot;</span>: <span class="number">60</span>, <span class="string">&quot;张三&quot;</span>: <span class="number">43</span>&#125;</span><br><span class="line">modify(dict)</span><br><span class="line">fmt.Println(dict[<span class="string">&quot;张三&quot;</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(dict <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">dict[<span class="string">&quot;张三&quot;</span>] = <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Go入门和《Go语言实战》的笔记，本篇总结了基础的数组、切片和哈希表的内容。&lt;/p&gt;
&lt;h2 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h2&gt;&lt;p&gt;数组是切片和映射的基础数据结构，因此了解数组的工</summary>
      
    
    
    
    <category term="学了些什么" scheme="https://blog.farmer233.top/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="Golang" scheme="https://blog.farmer233.top/tags/Golang/"/>
    
    <category term="笔记" scheme="https://blog.farmer233.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>提问中需要避免的一些行为</title>
    <link href="https://blog.farmer233.top/2021/08/07/%E6%8F%90%E9%97%AE%E4%B8%AD%E9%9C%80%E8%A6%81%E9%81%BF%E5%85%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%8C%E4%B8%BA/"/>
    <id>https://blog.farmer233.top/2021/08/07/%E6%8F%90%E9%97%AE%E4%B8%AD%E9%9C%80%E8%A6%81%E9%81%BF%E5%85%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%8C%E4%B8%BA/</id>
    <published>2021-08-06T18:10:23.000Z</published>
    <updated>2023-11-12T17:26:19.946Z</updated>
    
    <content type="html"><![CDATA[<img src="/2021/08/07/%E6%8F%90%E9%97%AE%E4%B8%AD%E9%9C%80%E8%A6%81%E9%81%BF%E5%85%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%8C%E4%B8%BA/question.jpg" class="" title="img"><blockquote><p>本文灵感源于F大的这篇文章–<a href="https://frostming.com/2019/12-26/qa-no-action/">社区问答中需要避免的行为</a>  </p></blockquote><p>长年混迹于QQ群、微信群和各大论坛，给人的印象和态度都属于是态度不友好类型。这并不是因为我鄙视菜鸟，我也曾是菜鸟（现在也是）。我这么做的原因也是我希望<strong>提问者能自己意识到问题所在</strong> -&gt; 为什么错了？应该怎么解决？这比我直接告诉他一个答案有帮助得多。逛社区这么久，我发现很多问题都提问的不是很好，不吐不快。<br>ps: 除了提问者应该学会提问外，回答者也有不好的回答。</p><h2 id="How-To-Ask-Questions"><a href="#How-To-Ask-Questions" class="headerlink" title="How To Ask Questions"></a>How To Ask Questions</h2><p>这个问题已经是听得耳朵起茧了，故不再赘述。但必须强调的是问问题是一门高深的学问，问的好不好直接影响到你是否能得到高效、直接、有效的回答。<br><strong>关于提问总结出有一下两个比较主要的问题：</strong></p><ol><li>不会提问</li><li>X-Y问题</li></ol><p>如果不会提问，<strong>一定要阅读下面的链接</strong>：</p><ul><li><a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md">提问的智慧</a></li><li><a href="https://coolshell.cn/articles/10804.html">X-Y问题</a></li></ul><h3 id="X-Y问题"><a href="#X-Y问题" class="headerlink" title="X-Y问题"></a>X-Y问题</h3><p>相比于不会提问，更让人恼火的是<code>X-Y问题</code>。概况起来如下：</p><ol><li>提问者想解决问题X</li><li>然后觉得Y可能是解决X问题的方法</li><li>但他不知道Y应该怎么做</li><li>于是他去问别人Y应该怎么做</li></ol><p>于是很多人都会热心的告诉这个人Y应该怎么处理，但大家都觉得Y这个方案比较怪异。经过大量的讨论浪费了大量的实践后人们终于明白了原始问题X，于是发现Y根本就不是用来解决X最合适的方案。<br>这个问题最大的问题在于：<strong>在一个根本错误的方向上浪费他人大量的时间和精力！！！</strong>十分的让人高血压！<br>关于X-Y问题，有许多的变种。不能说他们没有自己尝试动手解决问题，但这样的问题往往更浪费时间。</p><h2 id="用XXX干嘛，为什么不用XXX"><a href="#用XXX干嘛，为什么不用XXX" class="headerlink" title="用XXX干嘛，为什么不用XXX"></a>用XXX干嘛，为什么不用XXX</h2><blockquote><p>Q: 用Flask怎么做XXX？<br>A: 用Django吧</p></blockquote><p>某小白终于鼓起勇气，开始学某一框架，碰到了瓶颈，结果上来一提问，被安利了另一个框架，好嘛，白学了。这也很不负责任，我觉得要说服人用一个新的框架，接触新的知识，你得对两者都有相当的熟悉度，并且清楚两者的优劣。<br>如果你只是对其中一个比较熟悉，除非你确信已有方案确实做不到，或者要付出极大的代价才能实现，否则我会尽量沿用提问者已选择的方案。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/2021/08/07/%E6%8F%90%E9%97%AE%E4%B8%AD%E9%9C%80%E8%A6%81%E9%81%BF%E5%85%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%8C%E4%B8%BA/question.</summary>
      
    
    
    
    <category term="胡思乱语" scheme="https://blog.farmer233.top/categories/%E8%83%A1%E6%80%9D%E4%B9%B1%E8%AF%AD/"/>
    
    
    <category term="胡言乱语" scheme="https://blog.farmer233.top/tags/%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD/"/>
    
    <category term="吐槽" scheme="https://blog.farmer233.top/tags/%E5%90%90%E6%A7%BD/"/>
    
  </entry>
  
  <entry>
    <title>初探Typescript-使用http模块的简易爬虫</title>
    <link href="https://blog.farmer233.top/2021/03/12/%E5%88%9D%E6%8E%A2Typescript-%E4%BD%BF%E7%94%A8http%E6%A8%A1%E5%9D%97%E7%9A%84%E7%AE%80%E6%98%93%E7%88%AC%E8%99%AB/"/>
    <id>https://blog.farmer233.top/2021/03/12/%E5%88%9D%E6%8E%A2Typescript-%E4%BD%BF%E7%94%A8http%E6%A8%A1%E5%9D%97%E7%9A%84%E7%AE%80%E6%98%93%E7%88%AC%E8%99%AB/</id>
    <published>2021-03-12T11:45:30.000Z</published>
    <updated>2023-11-12T17:26:19.930Z</updated>
    
    <content type="html"><![CDATA[<p>这两天hxd找我写一道面试题，要求使用typescript<br>typescript是JavaScript的一个超集，它具有<strong>类型系统</strong>并且可以编译成普通的JavaScript代码。   </p><h2 id="1-从多个网页爬取内容，然后进行解析"><a href="#1-从多个网页爬取内容，然后进行解析" class="headerlink" title="1. 从多个网页爬取内容，然后进行解析"></a>1. 从多个网页爬取内容，然后进行解析</h2><p>有10个网页，1.txt 到 10.txt</p><p><a href="http://dy-public.oss-cn-shenzhen.aliyuncs.com/interviewTestData/1.txt">http://dy-public.oss-cn-shenzhen.aliyuncs.com/interviewTestData/1.txt</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">abc</span>&gt;</span> <span class="tag">&lt;<span class="name">de</span></span></span><br><span class="line"><span class="tag"><span class="attr">f</span>&gt;</span>data : 1992; name : agent 1 <span class="tag">&lt;/<span class="name">def</span>&gt;</span><span class="tag">&lt;/<span class="name">abc</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="0"><li>格式有可能有区别</li><li>用 promise, async, await 分别实现并发、串行爬取</li><li>网页下载使用nodejs的http即可</li><li>使用正则表达式获取data后面的字段，将10个文件的data值全部获取，并相加</li></ol><h2 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h2><p>Node.js 有大量的网络请求模块，题目这里要求用node的http模块<br>http模块是node自带的，使用起来十分简单，代码如下:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">http.<span class="title function_">get</span>(url, <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">setEncoding</span>(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">    res.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(data)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(e.<span class="property">message</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>http模块还可以指定options，但这里只需要下载网页，因此使用简单的get请求足以。  </p><h2 id="爬虫主体"><a href="#爬虫主体" class="headerlink" title="爬虫主体"></a>爬虫主体</h2><p>爬虫大致分为两部分-&gt; <strong>网络请求</strong>和 <strong>数据清理</strong>, 网络请求已经实现了，剩下就是把请求回来的数据进行清理了。这里也没啥多的选择，题目要求使用正则表达式，简单的构建整理一下就得到了下面的代码:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> http <span class="keyword">from</span> <span class="string">&#x27;http&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Spider</span> &#123;</span><br><span class="line">    <span class="attr">sum</span>: <span class="title class_">Number</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">sum</span> = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">httpGet</span>(<span class="params">url</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            http.<span class="title function_">get</span>(url, <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                res.<span class="title function_">setEncoding</span>(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">                res.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="title function_">resolve</span>(data)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;).<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="title function_">reject</span>(e.<span class="property">message</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params">urls</span>) &#123;</span><br><span class="line">        urls.<span class="title function_">reduce</span>(<span class="function">(<span class="params">promise, url</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> promise.<span class="title function_">then</span>(<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">httpGet</span>(url)</span><br><span class="line">            &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">flush</span>(node)</span><br><span class="line">            &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">sum</span> += res</span><br><span class="line">            &#125;)</span><br><span class="line">                .<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(e))</span><br><span class="line">        &#125;, <span class="title class_">Promise</span>.<span class="title function_">resolve</span>())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">flush</span>(<span class="params">data</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> re = <span class="regexp">/:\s(\d+?);/gi</span></span><br><span class="line">            <span class="keyword">const</span> <span class="built_in">number</span> = <span class="title class_">Number</span>(re.<span class="title function_">exec</span>(<span class="title class_">String</span>(data))[<span class="number">1</span>])</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="built_in">number</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> baseUrl = <span class="string">&#x27;http://dy-public.oss-cn-shenzhen.aliyuncs.com/interviewTestData/&#x27;</span></span><br><span class="line"><span class="keyword">let</span> urlList = []</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">1</span>; index &lt;= <span class="number">10</span>; index++) &#123;</span><br><span class="line">    urlList.<span class="title function_">push</span>(<span class="string">`<span class="subst">$&#123;baseUrl&#125;</span><span class="subst">$&#123;index&#125;</span>.txt`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> spider = <span class="keyword">new</span> <span class="title class_">Spider</span>()</span><br><span class="line">spider.<span class="title function_">render</span>(urlList)</span><br><span class="line"><span class="comment">// 模拟等待微队列运行完成， 可以用await语法糖</span></span><br><span class="line"><span class="comment">// 这里只是写个大题的框架罢了，后面根据具体的要求改动</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(spider.<span class="property">sum</span>)</span><br><span class="line">&#125;, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure><h2 id="The-End"><a href="#The-End" class="headerlink" title="The End"></a>The End</h2><p>到此为止，整个爬虫就写完了，总结一下体验。typescript是具有类型系统，这对于我这写多了python和JavaScript的人来说太好上手了！ </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这两天hxd找我写一道面试题，要求使用typescript&lt;br&gt;typescript是JavaScript的一个超集，它具有&lt;strong&gt;类型系统&lt;/strong&gt;并且可以编译成普通的JavaScript代码。   &lt;/p&gt;
&lt;h2 id=&quot;1-从多个网页爬取内容，然后</summary>
      
    
    
    
    <category term="学了些什么" scheme="https://blog.farmer233.top/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="笔记" scheme="https://blog.farmer233.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="前端" scheme="https://blog.farmer233.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="web" scheme="https://blog.farmer233.top/tags/web/"/>
    
    <category term="TypeScript" scheme="https://blog.farmer233.top/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>简单看看JavaScript中的Promise</title>
    <link href="https://blog.farmer233.top/2021/02/08/%E7%AE%80%E5%8D%95%E7%9C%8B%E7%9C%8BJavaScript%E4%B8%AD%E7%9A%84Promise/"/>
    <id>https://blog.farmer233.top/2021/02/08/%E7%AE%80%E5%8D%95%E7%9C%8B%E7%9C%8BJavaScript%E4%B8%AD%E7%9A%84Promise/</id>
    <published>2021-02-08T07:49:23.000Z</published>
    <updated>2023-11-12T17:26:19.950Z</updated>
    
    <content type="html"><![CDATA[<p>谈到JavaScript相信它的事件回调大家肯定都听过。即使只有一个执行线程，它也能处理异步高并发。<br>同样很多人回调写多了都不可避免的会变成**Callback Hell(回调地狱)**，这样的代码会非常复杂难懂，因为回调不像同步代码，它的执行顺序不是从上至下的，读回调代码必须反复横跳，思考什么情况下回跳到什么地方。<br>Promise就是一种异步编程，很早就有了随着ES6的发布Promise也成了JavaScript原生支持的对象,但学校这学期的课程并没有相关章节。因此顺便学习下Promise对象的使用。</p><p>以JavaScript原生的AJAX为栗子，AJAX的请求形式如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ajax</span>(<span class="params">url, callback</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">    xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, url)</span><br><span class="line">    xhr.<span class="title function_">send</span>()</span><br><span class="line">    xhr.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> == <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="title function_">callback</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="variable language_">this</span>.<span class="property">response</span>))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;加载失败&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们就以此方式依次请求三个接口(地址)，假设响应体的JSON格式是<code>&#123;id: 1, name: &quot;farmer&quot;&#125;</code>, JS代码如下:  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">ajax</span>(<span class="string">&#x27;http://127.0.0.1:5003/?name=farmer&#x27;</span>, <span class="function">(<span class="params">user</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 先拿到一个东西，再用这个东西去查别的，比如通过用户名查该用户的资料</span></span><br><span class="line">    <span class="title function_">ajax</span>(<span class="string">&#x27;http://127.0.0.1:5003/?name=&#x27;</span> + user.<span class="property">name</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">ajax</span>(<span class="string">&#x27;http://127.0.0.1:5003/?name=&#x27;</span> + user.<span class="property">name</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(e)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>是不是觉得嵌套很多？ 如果连续请求更多的地址，那嵌套就要看傻了。 接下来我们试试用Promise对象对ajax进行封装，看看效果怎么样。 代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ajax</span>(<span class="params">url</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">        xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, url)</span><br><span class="line">        xhr.<span class="title function_">send</span>()</span><br><span class="line">        xhr.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> == <span class="number">200</span>) &#123;</span><br><span class="line">                <span class="title function_">resolve</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="variable language_">this</span>.<span class="property">response</span>))</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="title function_">reject</span>(<span class="string">&quot;加载失败&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(<span class="variable language_">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中，我们自己封装的AJAX会返回一个“Promise”对象，初始化该对象时我们要传入一个函数，这个函数又接受两个回调函数作为参数，分别是<code>resolve</code>和<code>reject</code>。<code>resolve</code>就是你操作成功时调用的方法，<code>reject</code>就是失败时调用的。接下来让我们同样实现前面三个接口的功能:  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> url = <span class="string">&quot;http://127.0.0.1:5003/&quot;</span></span><br><span class="line"><span class="title function_">ajax</span>(<span class="string">`<span class="subst">$&#123;url&#125;</span>?name=xiaotao`</span>).<span class="title function_">then</span>(</span><br><span class="line">    <span class="function"><span class="params">value</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 这里可以通过第一个数据再发送请求</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">ajax</span>(<span class="string">`<span class="subst">$&#123;url&#125;</span>?name=`</span> + value.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">ajax</span>(<span class="string">`<span class="subst">$&#123;url&#125;</span>?name=`</span> + value.<span class="property">name</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(</span><br><span class="line">    <span class="function"><span class="params">value</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(value),</span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(reason)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>大家是不是发现，本来长长的嵌套，变成了顺序执行的代码了？ 到此就是Promise的简单探讨了。 如果你对上面的栗子还不太清楚，那下面是一些Promise对象更基础、详细的解释or栗子。希望能帮到你~😃</p><h2 id="Promise怎么用？"><a href="#Promise怎么用？" class="headerlink" title="Promise怎么用？"></a>Promise怎么用？</h2><p>相信刚接触Promise的童鞋都比较迷惑，到底应该怎么用Promise。其实上面有提到过，初始化该对象时我们要传入一个函数(我这里使用的是匿名函数)，这个函数又接受两个回调函数作为参数(这里读起来比较拗口，可以和下面的栗子结合起来看)，分别是<code>resolve</code>和<code>reject</code>。<code>resolve</code>就是你操作成功时调用的方法，<code>reject</code>就是失败时调用的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// resolved 成功</span></span><br><span class="line"><span class="comment">// rejected 拒绝</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 工作流程</span></span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&quot;成功状态&quot;</span>)</span><br><span class="line">    <span class="comment">// reject(&quot;失败状态&quot;)</span></span><br><span class="line">&#125;).<span class="title function_">then</span>( <span class="comment">// then -&gt; 微任务列表</span></span><br><span class="line">    <span class="comment">// 工作后的处理</span></span><br><span class="line">    <span class="comment">// then方法有两个参数，第一个是成功的回调函数，第二个是失败的</span></span><br><span class="line">    <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 成功</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;成功业务处理-1&quot;</span>)</span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 失败</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;失败(拒绝)的业务处理-1&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">).<span class="title function_">then</span>(</span><br><span class="line">    <span class="function"><span class="params">value</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;成功业务处理-2&quot;</span>),</span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;失败(拒绝)的业务处理-2&#x27;</span>)</span><br><span class="line">    <span class="comment">// 上面一个Then可能不太清晰，这里和上面的逻辑是一样的。</span></span><br><span class="line">    <span class="comment">// then有两个参数，这两个参数是两个回调函数。</span></span><br><span class="line">    <span class="comment">// 一个是成功状态的回调函数，对应这里的value。 而这个成功状态则是上面的resolve</span></span><br><span class="line">    <span class="comment">// 一个是失败状态的回调函数，对应这里的reason。而这个失败状态则是上面的reject</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="Then的更多用法"><a href="#Then的更多用法" class="headerlink" title="Then的更多用法"></a>Then的更多用法</h2><p>我们从上面的栗子可以看到，then函数也有两个参数，也是一个成功一个失败。其实then也是一个Promise。<br>但从上面的栗子也可以发现，第二个then无论前一个then是哪个参数处理的，都只会出发成功状态。如果我们想让第二个then的失败处理也能生效，我们应该将代码改成下面这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;fulfilled&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = p1.<span class="title function_">then</span>(</span><br><span class="line">    <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">        <span class="comment">// 第一个Then return的内容, Then默认返回成功(resolve)</span></span><br><span class="line">        <span class="comment">// return &#x27;Farmer&#x27;</span></span><br><span class="line">        <span class="comment">// 返回一个Promise</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// resolve(&quot;解决&quot;)</span></span><br><span class="line">            <span class="title function_">reject</span>(<span class="string">&quot;Then 解决失败&quot;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(reason)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">// resolve(&quot;解决&quot;)</span></span><br><span class="line">                    <span class="title function_">reject</span>(<span class="string">&quot;Then 解决失败&quot;</span>)</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">).<span class="title function_">then</span>(</span><br><span class="line">    <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="params">reason</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(reason)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>当第一个then返回一个Promise对象后，第二个then就能根据前一个then返回的Promise的状态进行处理。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于Promise一些更深层次的理论这里就不探讨了，网上资料很多，大家可以去搜索下。本文中的示例代码可以在<a href="https://gitee.com/Farmer-chong/my-codes/tree/master/PromiseLearn">这里下载</a>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;谈到JavaScript相信它的事件回调大家肯定都听过。即使只有一个执行线程，它也能处理异步高并发。&lt;br&gt;同样很多人回调写多了都不可避免的会变成**Callback Hell(回调地狱)**，这样的代码会非常复杂难懂，因为回调不像同步代码，它的执行顺序不是从上至下的，读回</summary>
      
    
    
    
    <category term="学了些什么" scheme="https://blog.farmer233.top/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="笔记" scheme="https://blog.farmer233.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JavaScript" scheme="https://blog.farmer233.top/tags/JavaScript/"/>
    
    <category term="前端" scheme="https://blog.farmer233.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="web" scheme="https://blog.farmer233.top/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>前端 | Skeleton骨架屏</title>
    <link href="https://blog.farmer233.top/2021/01/12/%E5%89%8D%E7%AB%AF-Skeleton%E9%AA%A8%E6%9E%B6%E5%B1%8F/"/>
    <id>https://blog.farmer233.top/2021/01/12/%E5%89%8D%E7%AB%AF-Skeleton%E9%AA%A8%E6%9E%B6%E5%B1%8F/</id>
    <published>2021-01-12T09:56:43.000Z</published>
    <updated>2023-11-12T17:26:19.934Z</updated>
    
    <content type="html"><![CDATA[<p>之前在众多App上看到过骨架屏，不过今天才知道这个效果叫骨架屏hhh.<br>这个效果体验上比焦虑圈要好很多🚀<br>基础栗子: <a href="/demo/Skeleton/index.html">Base_demo</a><br>加载栗子: <a href="/demo/Skeleton/apiLoading/index.html">loading_demo</a></p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天刷视频的时候看到骨架屏对用户体验有显著的提升，边学边敲-&gt;<a href="/demo/Skeleton/index.html">Base_demo</a><br>后面对代码进行了少量的修改 -&gt; <a href="/demo/Skeleton/apiLoading/index.html">loading_demo</a>, 将代码和请求相结合。后期可以和懒加载配合使用。🚀🌙    </p><h2 id="基础栗子"><a href="#基础栗子" class="headerlink" title="基础栗子"></a>基础栗子</h2><h3 id="HTML结构"><a href="#HTML结构" class="headerlink" title="HTML结构"></a>HTML结构</h3><p>这里有两个div, 一个表示加载后的, 一个表示加载中的. </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;image&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://www.imagesource.com/wp-contentuploads/2019/06/Rio.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h4</span>&gt;</span>Skeleton Demo<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;description&quot;</span>&gt;</span></span><br><span class="line">            骨架框效果测试样例，这是一段测试使用噶文字This is a test text.</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card loading&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;image&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h4</span>&gt;</span><span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;description&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><p>观察栗子可以发现，加载的时候背景有一道白色光影划过。这里利用了<code>background</code>的 <code>linear-gradient</code>函数，这是一种特别的image。表示渐变轴为100°, 从<code>rgba(255, 255, 255, 0) 40%</code> 渐变到 <code>rgba(255, 255, 255, .5) 50%</code>.<br>然后用<code>background-size</code> 将 <code>linear-gradient</code>图片宽拉伸一倍.<br>最后通过改变<code>position</code>来移动白色反光区域，造成光影特效.  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span>&#123;</span><br><span class="line">    <span class="attr">--loading-grey</span>: <span class="number">#ededed</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#fefefe</span>;</span><br><span class="line">    <span class="attribute">font-family</span>: Arial, Helvetica, sans-serif;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: space-evenly;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">100vh</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.card</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">320px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">6px</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0px</span> <span class="number">4px</span> <span class="number">6px</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, .<span class="number">12</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.image</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.image</span> <span class="selector-tag">img</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: inherit;</span><br><span class="line">    <span class="attribute">object-fit</span>: cover;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.content</span>&#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">2rem</span> <span class="number">1.8rem</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h4</span>&#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">1rem</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1.5rem</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1.5rem</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.description</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1rem</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1.4rem</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.loading</span> <span class="selector-class">.image</span>,</span><br><span class="line"><span class="selector-class">.loading</span> <span class="selector-tag">h4</span>,</span><br><span class="line"><span class="selector-class">.loading</span> <span class="selector-class">.description</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">var</span>(--loading-grey);</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(</span><br><span class="line">        <span class="number">100deg</span>,</span><br><span class="line">        <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>) <span class="number">40%</span>,</span><br><span class="line">        <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, .<span class="number">5</span>) <span class="number">50%</span>,</span><br><span class="line">        <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>) <span class="number">60%</span></span><br><span class="line">    ) <span class="built_in">var</span>(--loading-grey);</span><br><span class="line">    <span class="attribute">background-size</span>: <span class="number">200%</span> <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background-position</span>-x: <span class="number">120%</span>;</span><br><span class="line">    <span class="attribute">animation</span>: <span class="number">1s</span> loading ease-in-out infinite;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> loading&#123;</span><br><span class="line">    <span class="selector-tag">to</span>&#123;</span><br><span class="line">        <span class="attribute">background-position</span>-x: -<span class="number">20%</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.loading</span> <span class="selector-tag">h4</span>&#123;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">1.6rem</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">    <span class="attribute">animation-delay</span>: .<span class="number">05s</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.loading</span> <span class="selector-class">.description</span>&#123;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">4rem</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">    <span class="attribute">animation-delay</span>: .<span class="number">06s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初步结束"><a href="#初步结束" class="headerlink" title="初步结束"></a>初步结束</h3><p>到此为止，基本的效果已经实现了。-&gt; <a href="/demo/Skeleton/index.html">Base_demo</a></p><h2 id="稍微修改一下"><a href="#稍微修改一下" class="headerlink" title="稍微修改一下"></a>稍微修改一下</h2><p>修改了一下，将加载和加载后相结合.  </p><h3 id="HTML结构-1"><a href="#HTML结构-1" class="headerlink" title="HTML结构"></a>HTML结构</h3><p>因为将加载和加载后结合起来, 这里取消了第二个<code>div</code>.   </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;Skeleton&quot;</span> <span class="attr">class</span>=<span class="string">&quot;card loading&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;image&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">&quot;img&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://www.imagesource.com/wp-content/uploads/2019/06/Rio.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h4</span>&gt;</span>Skeleton Demo<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;description&quot;</span>&gt;</span></span><br><span class="line">                骨架框效果测试样例，这是一段测试使用噶文字。This is a test text.</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="CSS-1"><a href="#CSS-1" class="headerlink" title="CSS"></a>CSS</h3><p>沿用上面的css, 这里不再重复.   </p><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><p>这里用了<code>onreadystatechange</code>, 当页面加载完时<code>readyState</code>属性会是 <code>complete</code>来判断是否加载完资源,后期可以灵活更改。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">onreadystatechange</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title class_">Skeleton</span> = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#Skeleton&quot;</span>)</span><br><span class="line">    <span class="title class_">Skeleton</span>.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&quot;loading&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> text = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;.content h4&quot;</span>)</span><br><span class="line">    text.<span class="title function_">forEach</span>(<span class="function"><span class="params">e</span> =&gt;</span> &#123; e.<span class="property">innerText</span> = <span class="string">&quot;&quot;</span> &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> description = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;.description&quot;</span>)</span><br><span class="line">    description.<span class="title function_">forEach</span>(<span class="function"><span class="params">e</span> =&gt;</span> &#123; e.<span class="property">innerText</span> = <span class="string">&quot;&quot;</span> &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">readyState</span> == <span class="string">&quot;complete&quot;</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Skeleton</span>.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&quot;loading&quot;</span>))</span><br><span class="line">        text.<span class="title function_">forEach</span>(<span class="function"><span class="params">e</span> =&gt;</span> &#123; e.<span class="property">innerText</span> = <span class="string">&quot;Skeleton Demo&quot;</span> &#125;)</span><br><span class="line">        description.<span class="title function_">forEach</span>(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">            e.<span class="property">innerText</span> = <span class="string">&quot;骨架框效果测试样例，这是一段测试使用噶文字。This is a test text.&quot;</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前在众多App上看到过骨架屏，不过今天才知道这个效果叫骨架屏hhh.&lt;br&gt;这个效果体验上比焦虑圈要好很多🚀&lt;br&gt;基础栗子: &lt;a href=&quot;/demo/Skeleton/index.html&quot;&gt;Base_demo&lt;/a&gt;&lt;br&gt;加载栗子: &lt;a href=&quot;/demo/Skeleton/apiLoading/index.html&quot;&gt;loading_demo&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="学了些什么" scheme="https://blog.farmer233.top/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="笔记" scheme="https://blog.farmer233.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JavaScript" scheme="https://blog.farmer233.top/tags/JavaScript/"/>
    
    <category term="前端" scheme="https://blog.farmer233.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="web" scheme="https://blog.farmer233.top/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript小游戏——2048Game</title>
    <link href="https://blog.farmer233.top/2020/12/29/JavaScript%E5%B0%8F%E6%B8%B8%E6%88%8F-2048Game/"/>
    <id>https://blog.farmer233.top/2020/12/29/JavaScript%E5%B0%8F%E6%B8%B8%E6%88%8F-2048Game/</id>
    <published>2020-12-29T15:17:31.000Z</published>
    <updated>2023-11-12T17:26:19.918Z</updated>
    
    <content type="html"><![CDATA[<p>这几天学校JavaScript课程实训，项目是做一个2048小游戏<br>好久没玩这个游戏了，感觉偶尔玩玩还是不错的.<br>预览、案例、栗子: <a href="/demo/2048Game/index.html">Demo</a><br>ps: 纯粹方便自己日后玩2333.   </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这几天学校JavaScript课程实训，项目是做一个2048小游戏&lt;br&gt;好久没玩这个游戏了，感觉偶尔玩玩还是不错的.&lt;br&gt;预览、案例、栗子: &lt;a href=&quot;/demo/2048Game/index.html&quot;&gt;Demo&lt;/a&gt;&lt;br&gt;ps: 纯粹方便自己日后玩233</summary>
      
    
    
    
    <category term="学了些什么" scheme="https://blog.farmer233.top/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="笔记" scheme="https://blog.farmer233.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JavaScript" scheme="https://blog.farmer233.top/tags/JavaScript/"/>
    
    <category term="前端" scheme="https://blog.farmer233.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="web" scheme="https://blog.farmer233.top/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>蓝桥杯校内选拔WP</title>
    <link href="https://blog.farmer233.top/2020/12/23/%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%A0%A1%E5%86%85%E9%80%89%E6%8B%94WP/"/>
    <id>https://blog.farmer233.top/2020/12/23/%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%A0%A1%E5%86%85%E9%80%89%E6%8B%94WP/</id>
    <published>2020-12-23T03:38:29.000Z</published>
    <updated>2023-11-12T17:26:19.954Z</updated>
    
    <content type="html"><![CDATA[<p>上周五参加了蓝桥杯的校内选拔，给虐的惨目忍睹。<br>啪的一下很快啊，欺负我这个大三的老同志&#x2F;(ㄒoㄒ)&#x2F;~<br>这次我选的是python组，有点后悔没选C&#x2F;C++, python一上来就图论就离谱😟<br>试卷就没有了，仅写一下当时考试时脑子短路没想到的几道题  </p><span id="more"></span><h2 id="第一题-细胞分裂"><a href="#第一题-细胞分裂" class="headerlink" title="第一题-细胞分裂"></a>第一题-细胞分裂</h2><p>题目描述：现在有一个细胞，每一个小时分裂一次，第三个小时时细胞自然死亡<br>问：第N个小时后还有几个细胞存活    </p><p>输入：<br><code>5</code><br>输出:<br><code>24</code></p><p>这道题看上去就想斐波那契数列的变形，考场上第一想法就是用数组来解但一直解决不了细胞死亡问题导致第一道程序设计题就卡壳了。<br>最气的是一出考场就想到了解法….我….<br>题解：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line">temp_list = [</span><br><span class="line">    &#123;<span class="string">&quot;old&quot;</span>: <span class="number">1</span>,<span class="string">&quot;new&quot;</span>: <span class="number">0</span>, <span class="string">&quot;all&quot;</span>: <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;old&quot;</span>: <span class="number">1</span>,<span class="string">&quot;new&quot;</span>: <span class="number">1</span>, <span class="string">&quot;all&quot;</span>: <span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;old&quot;</span>: <span class="number">2</span>,<span class="string">&quot;new&quot;</span>: <span class="number">2</span>, <span class="string">&quot;all&quot;</span>: <span class="number">4</span>&#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):</span><br><span class="line">    old = temp_list[-<span class="number">1</span>][<span class="string">&quot;all&quot;</span>]</span><br><span class="line">    die = temp_list[-<span class="number">3</span>][<span class="string">&quot;old&quot;</span>]</span><br><span class="line">    temp_dict = &#123;</span><br><span class="line">        <span class="string">&quot;old&quot;</span>: old,</span><br><span class="line">        <span class="string">&quot;new&quot;</span>: old,</span><br><span class="line">        <span class="string">&quot;all&quot;</span>: old * <span class="number">2</span> - die</span><br><span class="line">    &#125;</span><br><span class="line">    temp_list.append(temp_dict)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(temp_list[-<span class="number">1</span>][<span class="string">&quot;all&quot;</span>])</span><br></pre></td></tr></table></figure><h2 id="第二题-猴子选大王"><a href="#第二题-猴子选大王" class="headerlink" title="第二题-猴子选大王"></a>第二题-猴子选大王</h2><p>题目描述：一群猴子要选新猴王。新猴王的选择方法是：让N只候选猴子围成一圈，从某位置起顺序编号为1~N号。从第1号开始报数，每轮从1报到3，凡报到3的猴子即退出圈子，接着又从紧邻的下一只猴子开始同样的报数。如此不断循环，最后剩下的一只猴子就选为猴王。请问是原来第几号猴子当选猴王？</p><p><strong>输入格式：</strong><br>输入在一行中给一个正整数N（≤1000）。<br>example:    </p><blockquote><p>11</p></blockquote><p><strong>输出格式：</strong><br>在一行中输出当选猴王的编号。<br>example:   </p><blockquote><p>7</p></blockquote><p>题解:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">temp_list = <span class="built_in">list</span>(<span class="built_in">range</span>(n))</span><br><span class="line">target = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">len</span>(temp_list) &gt; <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> temp_list[:]:</span><br><span class="line">        <span class="keyword">if</span> target == <span class="number">3</span>:</span><br><span class="line">            temp_list.remove(value)</span><br><span class="line">            target = <span class="number">0</span></span><br><span class="line">        target += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(temp_list[-<span class="number">1</span>] + <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>很多题目以前都在PTA上自己解答过，但一上考场就凉了，还是自己太菜了~</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上周五参加了蓝桥杯的校内选拔，给虐的惨目忍睹。&lt;br&gt;啪的一下很快啊，欺负我这个大三的老同志&amp;#x2F;(ㄒoㄒ)&amp;#x2F;~&lt;br&gt;这次我选的是python组，有点后悔没选C&amp;#x2F;C++, python一上来就图论就离谱😟&lt;br&gt;试卷就没有了，仅写一下当时考试时脑子短路没想到的几道题  &lt;/p&gt;</summary>
    
    
    
    <category term="胡思乱语" scheme="https://blog.farmer233.top/categories/%E8%83%A1%E6%80%9D%E4%B9%B1%E8%AF%AD/"/>
    
    
    <category term="python" scheme="https://blog.farmer233.top/tags/python/"/>
    
    <category term="蓝桥杯" scheme="https://blog.farmer233.top/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    <category term="算法和数据结构" scheme="https://blog.farmer233.top/tags/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>软考网络攻城狮学习笔记</title>
    <link href="https://blog.farmer233.top/2020/11/10/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%9F%8E%E7%8B%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://blog.farmer233.top/2020/11/10/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%9F%8E%E7%8B%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-11-10T09:27:09.000Z</published>
    <updated>2023-11-12T17:26:19.950Z</updated>
    
    <content type="html"><![CDATA[<p>前天考完软考-网络攻城狮，写一下笔记趴✌🙌<br>随便记录一下，写的不算好，单纯只是做个笔记以后复习用(自己能看懂就行)</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>互联网可以划分为多个自治系统(autonomous system, AS) ，每个AS内部可以和别的 AS 使用不同的路由选择协议，根据使用的范围差异可以将路由选择协议划分为自治系统内部的协议和自治系统外的协议    </p><h2 id="Web安全"><a href="#Web安全" class="headerlink" title="Web安全"></a>Web安全</h2><p>这次软考下午卷考了一手web安全，常见的sql注入、XSS、一句话木马、Excel宏病毒等等，不过都说些简单问题稍有了解就能答出来。写在前面是因为这东西比较好玩并且有了解过所以在前面记录一下。<br>常见的类型: </p><ul><li>sql注入</li><li>XSS</li><li>一句话木马</li><li>Excel宏病毒</li><li>APT</li><li>DDos</li><li>蠕虫病毒</li></ul><h2 id="RIP-amp-OSPF-路由-Hot"><a href="#RIP-amp-OSPF-路由-Hot" class="headerlink" title="RIP &amp; OSPF 路由(Hot)"></a>RIP &amp; OSPF 路由(Hot)</h2><p><strong>这两个协议都是自治系统内的协议</strong>，只能用于内部网络或者说小型网络    </p><h3 id="rip"><a href="#rip" class="headerlink" title="rip"></a>rip</h3><p>通过邻居获取网络路由，再与自己的路由表合并</p><h3 id="ospf"><a href="#ospf" class="headerlink" title="ospf"></a>ospf</h3><ul><li>寻找邻居</li><li>建立邻接关系</li><li>链路状态信息传递</li><li>计算路由</li></ul><h3 id="两者对比"><a href="#两者对比" class="headerlink" title="两者对比"></a>两者对比</h3><table><thead><tr><th align="center">对比</th><th align="center">rip</th><th align="center">ospf</th></tr></thead><tbody><tr><td align="center">协议对比</td><td align="center">距离矢量协议</td><td align="center">链路状态协议</td></tr><tr><td align="center">传输成本</td><td align="center">开销低</td><td align="center">传输成本好</td></tr><tr><td align="center">实现方式</td><td align="center">计算路由跳数</td><td align="center">洪泛法(向自治系统中的所有路由发送信息)</td></tr><tr><td align="center">时间</td><td align="center">每30s发送一次</td><td align="center">当网络拓扑改变的时候</td></tr><tr><td align="center">跳数限制</td><td align="center">最多15跳(16则不可达)</td><td align="center">没限制</td></tr><tr><td align="center">使用的算法</td><td align="center">距离向量算法</td><td align="center">最短路径算法(Dijkstra)</td></tr><tr><td align="center">适用网络</td><td align="center">小型网络</td><td align="center">大型网络</td></tr><tr><td align="center">ospf的优势</td><td align="center"></td><td align="center">没有跳数限制、可变子网掩码(VESM)、网络规模大、收敛速度快</td></tr><tr><td align="center">ospf中DR的作用范围</td><td align="center"></td><td align="center">一个网段</td></tr></tbody></table><h2 id="广播域-amp-amp-冲突域-Hot"><a href="#广播域-amp-amp-冲突域-Hot" class="headerlink" title="广播域 &amp;&amp; 冲突域(Hot)"></a>广播域 &amp;&amp; 冲突域(Hot)</h2><p>区别:  </p><ul><li>广播域可以跨网段，而冲突域只是发生的同一个网段的。</li><li>冲突域：在同一个冲突域中的每一个节点都能收到所有被发送的帧;</li><li>广播域：网络中能接收任一设备发出的广播帧的所有设备的集合;</li><li>冲突域：基于第一层（物理层）;</li><li>广播域：基于第二层（数据链路层）;</li><li>一个局域网就是一个广播域（往往是指一个IP段内），广播域中的机器可以收到域中其他任何一台机器的播，而不能收到域外机器的广播，域外机器也不能收到域内机器发的广播；</li><li>冲突域：一个站点向另一个站点发出信号。能收到信号的站点就构成一个冲突域。</li><li>集线器（HUB） 所有端口都在同一个广播域，冲突域内。</li></ul><h2 id="DNSの两种查询-Hot"><a href="#DNSの两种查询-Hot" class="headerlink" title="DNSの两种查询(Hot)"></a>DNSの两种查询(Hot)</h2><h3 id="迭代查询-主机向本地域名服务器查询"><a href="#迭代查询-主机向本地域名服务器查询" class="headerlink" title="迭代查询 (主机向本地域名服务器查询)"></a>迭代查询 (主机向本地域名服务器查询)</h3><p>如果主机所询问的本地域名服务器不知道被查询域名的ip, 那么本地域名服务器就以DNS客户的身份，向其他根域名服务器继续发出查询请求报文(即替该主机继续查询)，而不是让该主机自己进行下一步的查询.因此，递归擦汗寻返回的查询结果或者是所要查询的ip地址，或者是报错，表示无法查询到所需的IP地址。</p><h3 id="递归查询-本地域名服务器向根域名服务器查询"><a href="#递归查询-本地域名服务器向根域名服务器查询" class="headerlink" title="递归查询 (本地域名服务器向根域名服务器查询)"></a>递归查询 (本地域名服务器向根域名服务器查询)</h3><p>当根域名服务器收到本地域名服务器发出的迭代查询请求报文是，要么给出所要查询的IP地址，要么告诉本地域名服务器进行后续的查询(而不是替本地域名服务器进行后续的查询)。</p><img src="/2020/11/10/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%9F%8E%E7%8B%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/query.jpg" class="" title="query"><center>图片来源->bing搜索</center><h2 id="Tcp-amp-Udp-Hot"><a href="#Tcp-amp-Udp-Hot" class="headerlink" title="Tcp &amp; Udp(Hot)"></a>Tcp &amp; Udp(Hot)</h2><h3 id="Tcp"><a href="#Tcp" class="headerlink" title="Tcp"></a>Tcp</h3><ul><li>握手&amp;挥手</li><li>滑窗控制 –&gt; 动态规划</li></ul><h3 id="udp"><a href="#udp" class="headerlink" title="udp"></a>udp</h3><ul><li>头部大小: 8字节</li></ul><p>这部分内容太多了甚至还能引申出算法内容，以后单独拿出来讲吧~<br>(绝对不是挖坑！🕊)</p><h2 id="电子邮件协议-IMAP-amp-POP3-Hot"><a href="#电子邮件协议-IMAP-amp-POP3-Hot" class="headerlink" title="电子邮件协议(IMAP &amp; POP3)(Hot)"></a>电子邮件协议(IMAP &amp; POP3)(Hot)</h2><p>区别: </p><ol><li>pop3协议允许电子邮件客户端下载服务器上的邮件，但是在客户端的操作(移动、标记已读等)，不会反馈到服务器上。</li><li>IMAP客户端的操作都会反馈到服务器上</li></ol><h2 id="DES加密算法-Hot-None"><a href="#DES加密算法-Hot-None" class="headerlink" title="DES加密算法(Hot)(None)"></a>DES加密算法(Hot)(None)</h2><p>做了5年的软考题，DES加密算法可以说是必考题了，每年都考。</p><h2 id="卫星通信中的差错控制"><a href="#卫星通信中的差错控制" class="headerlink" title="卫星通信中的差错控制"></a>卫星通信中的差错控制</h2><ol><li>选择重传ARQ</li><li>前项差错控制FEC</li><li>多站分集的自动反馈重发</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前天考完软考-网络攻城狮，写一下笔记趴✌🙌&lt;br&gt;随便记录一下，写的不算好，单纯只是做个笔记以后复习用(自己能看懂就行)&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;互</summary>
      
    
    
    
    <category term="学了些什么" scheme="https://blog.farmer233.top/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="计算机网络基础" scheme="https://blog.farmer233.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    
    <category term="笔记" scheme="https://blog.farmer233.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>前端 | 打字效果</title>
    <link href="https://blog.farmer233.top/2020/11/01/%E5%89%8D%E7%AB%AF-%E6%89%93%E5%AD%97%E6%95%88%E6%9E%9C/"/>
    <id>https://blog.farmer233.top/2020/11/01/%E5%89%8D%E7%AB%AF-%E6%89%93%E5%AD%97%E6%95%88%E6%9E%9C/</id>
    <published>2020-11-01T06:25:13.000Z</published>
    <updated>2023-11-12T17:26:19.934Z</updated>
    
    <content type="html"><![CDATA[<p>今天刷别人博客的时候，看到了一个有趣的效果-&gt;<strong>打字</strong><br>预览、案例、栗子: <a href="/demo/cursor.html">Demo</a></p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>刚看到这个效果的时候觉得很惊艳，自己撸了一遍代码-&gt;<a href="/demo/cursor.html">Demo</a><br>直到写这篇博客的时候才发现github上面有<strong>打字机</strong>的开源项目！！！<br>在这里mark下，下次直接用得了&#x2F;(ㄒoㄒ)&#x2F;~~<br>Github: <a href="https://github.com/mattboldt/typed.js/">https://github.com/mattboldt/typed.js/</a></p><h2 id="HTML结构"><a href="#HTML结构" class="headerlink" title="HTML结构"></a>HTML结构</h2><p>这部分的结构十分简单, 用两个标签一个存放文本内容、一个用来显示光标</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;text&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;cursor cursor-flash&quot;</span>&gt;</span>|<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><p>要注意, 这里光标不能用<code>display</code>属性来控制光标的显示和隐藏，因为这会使html消失导致文本错位,导致效果太核突.<br>所以这里用<code>opacity</code>属性,通过控制光标的透明度来实现.<br>首先贴出关键部分代码:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#app</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">48px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.cursor-flash</span> &#123;</span><br><span class="line">    <span class="attribute">animation</span>: flash .<span class="number">7s</span> linear infinite;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> flash &#123;</span><br><span class="line">    <span class="number">0%</span> &#123;</span><br><span class="line">        <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="number">50%</span> &#123;</span><br><span class="line">        <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="number">100%</span> &#123;</span><br><span class="line">        <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><p>此时光标已经开始闪烁了, 接下来我们只要让文本逐个的添加就好了.<br>分析了一下效果，有以下几个功能块:</p><ul><li>获取节点: <code>querySelector</code></li><li>字符串切割: <code>substr()</code></li><li>定时添加字符串-&gt;定时器: <code>setTimeout</code></li><li>打字和删除-&gt;异步操作: <code>Promise</code></li></ul><p>code:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str_input = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.text&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Text cursor Demo!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setTextPrint</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">            str_input.<span class="property">innerHTML</span> = value</span><br><span class="line">            <span class="title function_">resolve</span>()</span><br><span class="line">        &#125;, <span class="number">200</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params">flag</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= str.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">await</span> <span class="title function_">setTextPrint</span>(str.<span class="title function_">substr</span>(<span class="number">0</span>, i))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = str.<span class="property">length</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">await</span> <span class="title function_">setTextPrint</span>(str.<span class="title function_">substr</span>(<span class="number">0</span>, i))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">main</span>(!flag)</span><br><span class="line">    &#125;, <span class="number">700</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">main</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="完善Demo页面"><a href="#完善Demo页面" class="headerlink" title="完善Demo页面"></a>完善Demo页面</h2><p>目前页面太过单调, 用CSS修饰一下页面-&gt;<a href="/demo/cursor.html">Demo</a>,完整代码如下:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        * &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100vh</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">align-items</span>: center;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">justify-content</span>: center;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background</span>: <span class="built_in">radial-gradient</span>(<span class="number">#233</span>, <span class="built_in">rgb</span>(<span class="number">50</span>, <span class="number">155</span>, <span class="number">182</span>));</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        </span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#app</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-size</span>: <span class="number">48px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: <span class="number">#fff</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.cursor</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: white;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.cursor-flash</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">animation</span>: flash .<span class="number">7s</span> linear infinite;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="keyword">@keyframes</span> flash &#123;</span></span><br><span class="line"><span class="language-css">            <span class="number">0%</span> &#123;</span></span><br><span class="line"><span class="language-css">                <span class="attribute">opacity</span>: <span class="number">1</span>;</span></span><br><span class="line"><span class="language-css">            &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">            <span class="number">50%</span> &#123;</span></span><br><span class="line"><span class="language-css">                <span class="attribute">opacity</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">            &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">            <span class="number">100%</span> &#123;</span></span><br><span class="line"><span class="language-css">                <span class="attribute">opacity</span>: <span class="number">1</span>;</span></span><br><span class="line"><span class="language-css">            &#125;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;script src=&quot;./vue.min.js&quot;&gt;&lt;/script&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;text&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;cursor cursor-flash&quot;</span>&gt;</span>|<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> str_input = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.text&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> str = <span class="string">&quot;Text cursor Demo!&quot;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">setTextPrint</span>(<span class="params">value</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="built_in">setTimeout</span>(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                    str_input.<span class="property">innerHTML</span> = value</span></span><br><span class="line"><span class="language-javascript">                    <span class="title function_">resolve</span>()</span></span><br><span class="line"><span class="language-javascript">                &#125;, <span class="number">200</span>)</span></span><br><span class="line"><span class="language-javascript">            &#125;)</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params">flag</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> (flag) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= str.<span class="property">length</span>; i++) &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">await</span> <span class="title function_">setTextPrint</span>(str.<span class="title function_">substr</span>(<span class="number">0</span>, i))</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">for</span> (<span class="keyword">let</span> i = str.<span class="property">length</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">await</span> <span class="title function_">setTextPrint</span>(str.<span class="title function_">substr</span>(<span class="number">0</span>, i))</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">            </span></span><br><span class="line"><span class="language-javascript">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">main</span>(!flag)</span></span><br><span class="line"><span class="language-javascript">            &#125;, <span class="number">700</span>)</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">main</span>(<span class="number">1</span>)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天刷别人博客的时候，看到了一个有趣的效果-&amp;gt;&lt;strong&gt;打字&lt;/strong&gt;&lt;br&gt;预览、案例、栗子: &lt;a href=&quot;/demo/cursor.html&quot;&gt;Demo&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="学了些什么" scheme="https://blog.farmer233.top/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="笔记" scheme="https://blog.farmer233.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JavaScript" scheme="https://blog.farmer233.top/tags/JavaScript/"/>
    
    <category term="前端" scheme="https://blog.farmer233.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="web" scheme="https://blog.farmer233.top/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>Bilibili 2020 1024  Write Up</title>
    <link href="https://blog.farmer233.top/2020/10/26/Bilibili-2020-1024-Write-Up/"/>
    <id>https://blog.farmer233.top/2020/10/26/Bilibili-2020-1024-Write-Up/</id>
    <published>2020-10-26T09:11:23.000Z</published>
    <updated>2023-11-12T17:26:19.878Z</updated>
    
    <content type="html"><![CDATA[<p>和往常一样每天打开电脑的第一件事就是打开B站。非常Amazing啊，1024这天打开后看到header居然是1024节<br>好奇打开看了一下，发现了233娘的挑战状…emm虽然不是第一次玩ctf，但B站的首个ctf怎么也要玩一下的嘛🤭<br><del>不过做完之后感觉B站的题有点怪，群里的大佬们也在吐槽题目有点离谱</del> 不过作为一个臭弟弟，自然没有发言权，所以还是写写自己会做的wp算鸟 –(˙&lt;&gt;˙)&#x2F;–<br>这次不是🕊！</p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>感觉这次会做的题和攻防世界的入门题挺像的，都是些常规的套路(除了某些猜猜猜除外)。不会的还是不会，希望B站官方出个WP解解惑。<br>希望看到B站官网wp的时候我不会打自己一巴掌233…😄<br>这次就做了七题，做完后发现网上的答案都是7题~emmm看来和真正的大佬还是有差距啊！</p><ul><li><input checked="" disabled="" type="checkbox"> 页面的背后是什么？</li><li><input checked="" disabled="" type="checkbox"> 真正的秘密只有特殊的设备才能看到</li><li><input checked="" disabled="" type="checkbox"> 密码是啥？</li><li><input checked="" disabled="" type="checkbox"> 对不起，权限不足～</li><li><input checked="" disabled="" type="checkbox"> 别人的秘密</li><li><input disabled="" type="checkbox"> 结束亦是开始</li><li><input disabled="" type="checkbox"> 第七题</li><li><input checked="" disabled="" type="checkbox"> 第八题</li><li><input disabled="" type="checkbox"> 第九题</li><li><input checked="" disabled="" type="checkbox"> 第十题</li></ul><h2 id="页面的背后是什么？"><a href="#页面的背后是什么？" class="headerlink" title="页面的背后是什么？"></a>页面的背后是什么？</h2><p>第一题没啥好讲的，标准的第一题，另外题目<code>页面的背后是什么</code> 也在暗示。<br>正如大部分的ctf题一样，第一题一般都是在原码中找flag, 果断按下F12果然看到了flag. 直接拿下！~  </p><img src="/2020/10/26/Bilibili-2020-1024-Write-Up/T1.png" class="" title="t1"><h2 id="真正的秘密只有特殊的设备才能看到"><a href="#真正的秘密只有特殊的设备才能看到" class="headerlink" title="真正的秘密只有特殊的设备才能看到"></a>真正的秘密只有特殊的设备才能看到</h2><p>进到页面看到<strong>需要使用bilibili Security Browser浏览器访问～</strong>, 再和题目<strong>特殊的设备</strong>一结合那肯定就是要我们伪装特定的浏览器。<br>浏览器的标识那肯定就是UA嘛，所以这题就是用b站的UA来访问~<br>其实这道题在一个月前的政采云前端题中也有出现！<br>具体的方法有如下几种(我个人能想到的):</p><ol><li>直接浏览器改UA(最佳答案)</li><li>用<strong>POSTMAN</strong>发送http请求</li><li>用python解决</li></ol><p>我这里挑最简单的方法-&gt;浏览器直接来，如图：  </p><img src="/2020/10/26/Bilibili-2020-1024-Write-Up/T2.png" class="" title="T2"><p><strong>答案</strong></p><img src="/2020/10/26/Bilibili-2020-1024-Write-Up/T2_1.png" class="" title="T2_1"><h2 id="密码是啥？"><a href="#密码是啥？" class="headerlink" title="密码是啥？"></a>密码是啥？</h2><p>这题就两个字：<strong>离谱</strong> ！！！！<br>这题我一开始还在看是不是sql注入，然后爆出账号密码，结果是弱密码… 非常的无语😶<br>讲白了就是猜，硬猜！  </p><img src="/2020/10/26/Bilibili-2020-1024-Write-Up/T3.png" class="" title="T3"><h2 id="对不起，权限不足～"><a href="#对不起，权限不足～" class="headerlink" title="对不起，权限不足～"></a>对不起，权限不足～</h2><p>第四题一来，看到的是<strong>欢迎超级管理员登录</strong><br>我一开始的想法是结合第三题的登录，把第三题登录后的cookie弄过来，结果尝试后发现不行。<br>一开始的思路不对，导致我在这里卡了半个小时，后来看到<strong>超级管理员</strong>这个词感觉不太对劲，然后再看了cookie一眼，发现多了一个key <code>role</code><br>再看了一下代码:  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&quot;api/ctf/4&quot;</span>,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;get&quot;</span>,</span><br><span class="line">    <span class="attr">success</span>:<span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">        <span class="keyword">if</span> (data.<span class="property">code</span> == <span class="number">200</span>)&#123;</span><br><span class="line">            <span class="comment">// 如果有值：前端跳转</span></span><br><span class="line">            $(<span class="string">&#x27;#flag&#x27;</span>).<span class="title function_">html</span>(<span class="string">&quot;欢迎超级管理员登陆～答案是 : &#123;&#123; &quot;</span> + data.<span class="property">data</span> + <span class="string">&quot; &#125;&#125;&quot;</span>.<span class="title function_">toLowerCase</span>() )</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果没值</span></span><br><span class="line">            $(<span class="string">&#x27;#flag&#x27;</span>).<span class="title function_">html</span>(<span class="string">&quot;有些秘密只有超级管理员才能看见哦~&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>又是 API 返回 flag，用手指头想都知道鉴权是 Cookie 做的, 再联合<strong>超级管理员</strong>，接触过ctf的都清楚<code>user</code>和<code>MD5</code>都是粘在一起的<br>然后我差了一下<code>role</code>这里的md5，真的查到了-&gt;<code>user</code>: </p><img src="/2020/10/26/Bilibili-2020-1024-Write-Up/T4_md5_user.png" class="" title="md5_user"><p>这里解出来的是user,那么不用多说了吧，肯定是把管理员的md5换进去囖！</p><p>通过查<strong>超级管理员</strong>的md5,芜湖得到答案！<br><code>role=7b7bc2512ee1fedcd76bdc68926d4f7b</code></p><img src="/2020/10/26/Bilibili-2020-1024-Write-Up/T4.png" class="" title="T4"><h2 id="别人的秘密"><a href="#别人的秘密" class="headerlink" title="别人的秘密"></a>别人的秘密</h2><p>这题和第三题一样，就离谱的过分！！又是JQ这道题更离谱，上来先在 jQuery 的 <code>$</code>对象下挂了一个 <code>getUrlParam</code> 方法用来获取 uid、然后还有一个当 uid 不存在时给予默认值的方法（默认值取 100336889），接下来就是 <code>GET /api/ctf/5?uid=$&#123;uid&#125;。</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    (<span class="keyword">function</span> (<span class="params">$</span>) &#123;</span><br><span class="line">        $.getUrlParam = <span class="keyword">function</span> (<span class="params">name</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;(^|&amp;)&quot;</span> + name + <span class="string">&quot;=([^&amp;]*)(&amp;|$)&quot;</span>);</span><br><span class="line">            <span class="keyword">var</span> r = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">search</span>.<span class="title function_">substr</span>(<span class="number">1</span>).<span class="title function_">match</span>(reg);</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="literal">null</span>) <span class="keyword">return</span> <span class="built_in">unescape</span>(r[<span class="number">2</span>]); <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)(jQuery);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> uid = $.<span class="title function_">getUrlParam</span>(<span class="string">&#x27;uid&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (uid == <span class="literal">null</span>) &#123;</span><br><span class="line">        uid = <span class="number">100336889</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    $.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&quot;api/ctf/5?uid=&quot;</span> + uid,</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&quot;get&quot;</span>,</span><br><span class="line">        <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">            <span class="keyword">if</span> (data.<span class="property">code</span> == <span class="number">200</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果有值：前端跳转</span></span><br><span class="line">                $(<span class="string">&#x27;#flag&#x27;</span>).<span class="title function_">html</span>(<span class="string">&quot;欢迎超级管理员登陆～flag : &quot;</span> + data.<span class="property">data</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果没值</span></span><br><span class="line">                $(<span class="string">&#x27;#flag&#x27;</span>).<span class="title function_">html</span>(<span class="string">&quot;这里没有你想要的答案～&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>没什么好说的，直接暴力遍历就vans了。<br>Node.js解法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    (<span class="keyword">function</span> (<span class="params">$</span>) &#123;</span><br><span class="line">        $.getUrlParam = <span class="keyword">function</span> (<span class="params">name</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;(^|&amp;)&quot;</span> + name + <span class="string">&quot;=([^&amp;]*)(&amp;|$)&quot;</span>);</span><br><span class="line">            <span class="keyword">var</span> r = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">search</span>.<span class="title function_">substr</span>(<span class="number">1</span>).<span class="title function_">match</span>(reg);</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="literal">null</span>) <span class="keyword">return</span> <span class="built_in">unescape</span>(r[<span class="number">2</span>]); <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)(jQuery);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> uid = $.<span class="title function_">getUrlParam</span>(<span class="string">&#x27;uid&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (uid == <span class="literal">null</span>) &#123;</span><br><span class="line">        uid = <span class="number">100336889</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    $.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&quot;api/ctf/5?uid=&quot;</span> + uid,</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&quot;get&quot;</span>,</span><br><span class="line">        <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">            <span class="keyword">if</span> (data.<span class="property">code</span> == <span class="number">200</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果有值：前端跳转</span></span><br><span class="line">                $(<span class="string">&#x27;#flag&#x27;</span>).<span class="title function_">html</span>(<span class="string">&quot;欢迎超级管理员登陆～flag : &quot;</span> + data.<span class="property">data</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果没值</span></span><br><span class="line">                $(<span class="string">&#x27;#flag&#x27;</span>).<span class="title function_">html</span>(<span class="string">&quot;这里没有你想要的答案～&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>python3解法: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import urllib.request</span><br><span class="line">from urllib.request import DataHandler</span><br><span class="line"></span><br><span class="line">url = &#x27;http://45.113.201.36/api/ctf/5?uid=&#x27;</span><br><span class="line">headers = &#123;</span><br><span class="line">    &#x27;User-Agent&#x27;: &#x27;bilibili Security Browser&#x27;,</span><br><span class="line">    &#x27;cookie&#x27;: &#x27;session=233333333333333333333333333333333333; Path=/; Domain=45.113.201.36; &#x27;</span><br><span class="line">              &#x27;Expires=Sun, 24 Oct 2021 06:24:58 GMT;role=7b7bc2512ee1fedcd76bdc68926d4f7b; Path=/; &#x27;</span><br><span class="line">              &#x27;Domain=45.113.201.36; &#x27;</span><br><span class="line">&#125;</span><br><span class="line">for i in range(100336889, 100337889):</span><br><span class="line">    request = urllib.request.Request(url + str(i), headers=headers)</span><br><span class="line">    response = urllib.request.urlopen(request)</span><br><span class="line">    print(response.read())</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="结束亦是开始"><a href="#结束亦是开始" class="headerlink" title="结束亦是开始"></a>结束亦是开始</h2><blockquote><p>从第六题开始，所有题目都说「接下来的旅程，需要少年自己去探索啦～」，也就是说接下来所有的题目都是 Web 盲题。</p></blockquote><p>看源码每一个地方能提交的，找了半天也没找到可以下手的地方，URL 的格式是 <code>/blog/single.php?id=1</code><br>做这题的时候已是下午6点多了，想不出来怎么弄只能挂个<a href="https://github.com/maurosoria/dirsearch">dirsearch</a>来爆破目录然后去恰饭了。<br>爆破得到了一个路径，该路径是指向第十题的<br>然后用端口扫描发现了第八题的flag，然后就没有然后了~….我好菜啊！！！！</p><h2 id="第八题"><a href="#第八题" class="headerlink" title="第八题"></a>第八题</h2><p>这题要靠端口扫描，对常规端口扫描后发现6379端口开发，然后就是有手就行的未设防Redis服务器啦。<br>直接用终端连接靶机，直接拿下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">redis-cli -h [靶机 IP] -p 6379</span></span><br><span class="line">45.113.201.36:6379&gt; keys</span><br><span class="line">flag8</span><br><span class="line">45.113.201.36:6379&gt; get flag8</span><br></pre></td></tr></table></figure><img src="/2020/10/26/Bilibili-2020-1024-Write-Up/T8.png" class="" title="redis"><blockquote><p>吐槽一下我前面的大佬，把很多无关的flag都丢进来，搞的我白开心了一场~&#x2F;(ㄒoㄒ)&#x2F;~~</p></blockquote><h2 id="第十题"><a href="#第十题" class="headerlink" title="第十题"></a>第十题</h2><p>这题的入口是从爆出来的，爆破得到了一个目录<code>test.php</code><br>进入后看到是一个<code>jsFuck</code>，直接丢到控制台运行一下~<br>得到了两句话</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str1 = <span class="string">&quot;\u7a0b\u5e8f\u5458\u6700\u591a\u7684\u5730\u65b9&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> str2 = <span class="string">&quot;bilibili1024havefun&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>()</span><br></pre></td></tr></table></figure><img src="/2020/10/26/Bilibili-2020-1024-Write-Up/T10_1.png" class="" title="T10_jsFuck"><p>作为老web狗，一看这个编码反手就是丢控制台，得到:<code>程序员最多的地方</code>，那么程序猿最多的地方是哪？都懂吧？<br>然后搜索<code>bilibili1024havefun</code>,果然找到了！</p><img src="/2020/10/26/Bilibili-2020-1024-Write-Up/T10_github.png" class="" title="github"><p>接着把仓库clone下来，或者直接在github上看~<br>那么现在我们知道了文件名<code>end.php</code>，也知道了对应的后端代码，所以这题目就在<code>/blog/end.php</code>里面了。再看看代码<code>is_numeric</code>，因此这题就是<code>is_numeric</code>和<code>intval</code>绕过囖，所以最终的url是：<br><code>/blog/end.php?id[]=2&amp;id[]=2&amp;url=./flag.txt</code></p><p>这里我一开始绕过后还是得不到<code>flag</code>,最后看群里的大佬吐槽才发现原来是flag.txt…..🤮<br>然后我们会看到一张图片，用编辑器打开后在最后面就能找到flag了,end!</p><img src="/2020/10/26/Bilibili-2020-1024-Write-Up/bilibili_havefun.jpg" class="" title="bilibili"><blockquote><p>最后再吐槽一下，当时可能做的人太多了。估计很多大佬都在玩靶机，活活拖死靶机~233</p></blockquote><h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>也没啥好说的了，该会的做了，除了第九题题目都没看到外，第6题、第7题我是确实不会~无fucker说…</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;和往常一样每天打开电脑的第一件事就是打开B站。非常Amazing啊，1024这天打开后看到header居然是1024节&lt;br&gt;好奇打开看了一下，发现了233娘的挑战状…emm虽然不是第一次玩ctf，但B站的首个ctf怎么也要玩一下的嘛🤭&lt;br&gt;&lt;del&gt;不过做完之后感觉B站的题有点怪，群里的大佬们也在吐槽题目有点离谱&lt;/del&gt; 不过作为一个臭弟弟，自然没有发言权，所以还是写写自己会做的wp算鸟 –(˙&amp;lt;&amp;gt;˙)&amp;#x2F;–&lt;br&gt;这次不是🕊！&lt;/p&gt;</summary>
    
    
    
    <category term="胡思乱语" scheme="https://blog.farmer233.top/categories/%E8%83%A1%E6%80%9D%E4%B9%B1%E8%AF%AD/"/>
    
    
    <category term="python" scheme="https://blog.farmer233.top/tags/python/"/>
    
    <category term="CTF" scheme="https://blog.farmer233.top/tags/CTF/"/>
    
    <category term="JavaScript" scheme="https://blog.farmer233.top/tags/JavaScript/"/>
    
  </entry>
  
</feed>
