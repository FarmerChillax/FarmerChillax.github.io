<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Farmer</title>
  <icon>https://blog.farmer233.top/favicon.png</icon>
  <subtitle>-Farmer的自习室</subtitle>
  <link href="https://blog.farmer233.top/atom.xml" rel="self"/>
  
  <link href="https://blog.farmer233.top/"/>
  <updated>2021-09-06T14:56:24.741Z</updated>
  <id>https://blog.farmer233.top/</id>
  
  <author>
    <name>-Farmer</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>A distributed system with Go</title>
    <link href="https://blog.farmer233.top/2021/09/05/A-distributed-with-Go/"/>
    <id>https://blog.farmer233.top/2021/09/05/A-distributed-with-Go/</id>
    <published>2021-09-04T16:21:43.000Z</published>
    <updated>2021-09-06T14:56:24.741Z</updated>
    
    <content type="html"><![CDATA[<p>从上学期开始，学校的教务系统更新了。新版的正方多了一个负载均衡的功能，但无奈实在做的太差了！为什么这么说尼？<br>因为在上学期抢课的时候入口网关依旧拉闸，而真正的后端服务器访问速度比德芙还丝滑。因此暂将锅甩给负载均衡服务器。既然学校的负载均衡拉闸，那么就有了 <strong>“帮学校做负载均衡”</strong> 的想法。<br>大体的思路就是，通过扫描内网网段发现隐藏的地址，然后负载均衡这些隐藏的地址。<br>既然是负载均衡，第一时间想到的就是<code>Nginx</code>了，通过资料搜集，大致确定了基本的流程，因此有了这么的这个流程图:</p><img src="/2021/09/05/A-distributed-with-Go/floatChart.dio.png" class="" title="floatChart"><a id="more"></a><h2 id="需要解决的问题"><a href="#需要解决的问题" class="headerlink" title="需要解决的问题"></a>需要解决的问题</h2><p>由于非官方的代理，因此我们无法知道教务系统部署在内网的哪些机器上，而校园网一般使用B类网，因此需要扫描大量的ip地址。<br>但这样无疑会触发学校网管的报警，正常情况下会导致ip短时间内被封。导致扫描质量低（由于被禁网，导致程序误认为扫描超时从而导致目标未被发现）。<br>基于这个问题，随之而生的想法就是分布式扫描，将扫描的工作打散到用户中，服务器只负责扫描几个主干网段。<br>一句话概括就是: <strong>将扫描工作分散到多台机器上</strong>，流程图如下：</p><img src="/2021/09/05/A-distributed-with-Go/microService.dio.png" class="" title="microService"><h2 id="Todo"><a href="#Todo" class="headerlink" title="Todo"></a>Todo</h2><blockquote><p>前情提示: 本文通信均采用HTTP、代码部分存在伪代码<br>代码仓库: (暂不开源)</p></blockquote><ol><li>注册中心 -&gt; <strong>服务注册</strong>与<strong>服务发现</strong></li><li>日志服务 -&gt; 记录日志</li><li>数据库服务 -&gt; 数据库操作(CRUD)</li><li>扫描器服务 -&gt; 发现教务系统地址</li><li>测试器服务 -&gt; 测试数据库中地址的<strong>健康度</strong></li><li>Api服务 -&gt; 向<code>consul</code>发送负载信息</li></ol><p>大致结构如下：</p><img src="/2021/09/05/A-distributed-with-Go/scanner.dio.png" class="" title="scanner"><h2 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h2><p>作为一个分布式系统，不可避免地需要<strong>服务注册</strong>与<strong>服务发现</strong>。因此需要一个<code>注册中心</code>来处理各个<code>服务</code>之间的依赖关系，在服务上线后通知依赖这个服务的服务(这里有点绕)<br><strong>举个例子</strong>:<br><code>数据库</code>的每个操作都需要记录日志，日志为了统一管理所以有一个<code>日志服务</code>专门处理日志信息。此时，<code>日志服务</code>因某些原因(可能是人为、也可能是网络掉线等)在<code>数据库服务</code>注册之后才注册，这是<code>注册中心</code>就需要通知<code>数据库</code>，让<code>数据库</code>的日志记录转成使用<code>日志服务</code>。</p><h3 id="功能与实现"><a href="#功能与实现" class="headerlink" title="功能与实现"></a>功能与实现</h3><p>作为一个注册中心，首先我们需要一个web服务来接收服务发送的信息(注册、依赖更新、注销等等)，但在这之前我们先来定义一下我们要用到的结构(在面向对象中为类)</p><ol><li><code>registry</code>来表示注册操作<ul><li><code>registrations</code>来存放注册的服务</li><li><code>add</code> 注册服务</li><li><code>notify</code> 事件通知</li><li><code>sendRequiredServices</code> 发送依赖的服务</li><li><code>sendPatch</code> 发送依赖项</li><li><code>remove</code> 移除(注销)服务</li><li><code>Heartbeat</code> 心跳包</li></ul></li><li><code>Registration</code>表示服务注册结构体<ul><li><code>ServiceName</code> 服务名</li><li><code>ServiceURL</code> 服务地址</li><li><code>RequiredServices</code>[数组]服务依赖项</li><li><code>ServiceUpdateURL</code> 服务与注册中心沟通的URL</li><li><code>HeartbeatURL</code> 心跳检测地址</li></ul></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> registry <span class="keyword">struct</span> &#123;</span><br><span class="line">registrations []Registration</span><br><span class="line">mutex         *sync.RWMutex</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 服务注册结构体</span></span><br><span class="line"><span class="keyword">type</span> Registration <span class="keyword">struct</span> &#123;</span><br><span class="line">ServiceName ServiceName</span><br><span class="line">ServiceURL  <span class="keyword">string</span></span><br><span class="line">RequiredServices []ServiceName</span><br><span class="line">ServiceUpdateURL <span class="keyword">string</span></span><br><span class="line">HeartbeatURL     <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ServiceName <span class="keyword">string</span></span><br><span class="line"><span class="comment">// 添加注册</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *registry)</span> <span class="title">add</span><span class="params">(reg Registration)</span> <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当依赖服务运行时，通知依赖者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r registry)</span> <span class="title">notify</span><span class="params">(fullpatch patch)</span></span> </span><br><span class="line"><span class="comment">// 注册中心向服务发送依赖相关内容</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r registry)</span> <span class="title">sendRequiredServices</span><span class="params">(reg Registration)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 发送依赖项</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r registry)</span> <span class="title">sendPatch</span><span class="params">(p patch, url <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 移除注册（注销）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *registry)</span> <span class="title">remove</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">// 心跳包</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *registry)</span> <span class="title">Heartbeat</span><span class="params">(freq time.Duration)</span></span></span><br></pre></td></tr></table></figure><p>既然注册中心是作为一个web服务实现的，那么肯定是需要一个<code>web server</code>的，由于项目属于玩票性质，也不算大因此使用Go内置的<code>net/http</code>来实现，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RegistryService <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s RegistryService)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">log.Printf(<span class="string">"Request received"</span>)</span><br><span class="line"><span class="keyword">switch</span> r.Method &#123;</span><br><span class="line"><span class="keyword">case</span> http.MethodPost:</span><br><span class="line">decoder := json.NewDecoder(r.Body)</span><br><span class="line"><span class="keyword">var</span> r Registration</span><br><span class="line">err := decoder.Decode(&amp;r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusBadRequest)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">"Adding service: %v with URL: %s\n"</span>, r.ServiceName, r.ServiceURL)</span><br><span class="line">err = reg.add(r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusBadRequest)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> http.MethodDelete:</span><br><span class="line">payload, err := ioutil.ReadAll(r.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">url := <span class="keyword">string</span>(payload)</span><br><span class="line">log.Printf(<span class="string">"Removing service at URL: %s"</span>, url)</span><br><span class="line">err = reg.remove(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">w.WriteHeader(http.StatusInternalServerError)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">w.WriteHeader(http.StatusMethodNotAllowed)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务组件"><a href="#服务组件" class="headerlink" title="服务组件"></a>服务组件</h2><p>对服务来说，就是根据注册中心定好的规则来注册服务，然后根据自身的依赖来处理对应的功能。<br>因为要处理相应的依赖，因此除了<code>Registration</code>外，再定义一个处理服务依赖的结构体及方法: <code>providers</code>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> providers <span class="keyword">struct</span> &#123;</span><br><span class="line">services <span class="keyword">map</span>[ServiceName][]<span class="keyword">string</span>   <span class="comment">// 服务名-&gt;服务url</span></span><br><span class="line">mutex    *sync.RWMutex</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更新依赖</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *providers)</span> <span class="title">Update</span><span class="params">(pat patch)</span></span></span><br><span class="line"><span class="comment">// // 通过服务名称，找到依赖的urls，从依赖项里面随机返回一个url</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p providers)</span> <span class="title">get</span><span class="params">(name ServiceName)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span></span><br><span class="line"><span class="comment">// 导出给外部使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetProvide</span><span class="params">(name ServiceName)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span></span><br></pre></td></tr></table></figure><h3 id="组件的web服务"><a href="#组件的web服务" class="headerlink" title="组件的web服务"></a>组件的web服务</h3><p>因为每个服务都需要使用<strong>注册</strong>这些通用的功能，且这部分的工作都是重复的，因此将web抽出来公用.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Start</span><span class="params">(ctx context.Context, host, port <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">reg registry.Registration,</span></span></span><br><span class="line"><span class="function"><span class="params">RegisterHandlersFunc <span class="keyword">func</span>()</span>) <span class="params">(context.Context, error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">RegisterHandlersFunc()</span><br><span class="line">ctx = startService(ctx, reg.ServiceName, host, port)</span><br><span class="line">err := registry.RegisterService(reg)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ctx, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ctx, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startService</span><span class="params">(ctx context.Context, ServiceName registry.ServiceName,</span></span></span><br><span class="line"><span class="function"><span class="params">host, port <span class="keyword">string</span>)</span> <span class="title">context</span>.<span class="title">Context</span></span> &#123;</span><br><span class="line">ctx, cancel := context.WithCancel(ctx)</span><br><span class="line"><span class="keyword">var</span> srv http.Server</span><br><span class="line">srv.Addr = <span class="string">":"</span> + port</span><br><span class="line">address := fmt.Sprintf(<span class="string">"http://%s:%s"</span>, host, port)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">log.Println(srv.ListenAndServe())</span><br><span class="line"><span class="comment">// 关闭的时候要取消注册</span></span><br><span class="line"><span class="comment">// ... todo</span></span><br><span class="line">err := registry.ShutdownService(address)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">cancel()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Service is running in %v\n"</span>, address)</span><br><span class="line">fmt.Println(<span class="string">"Registry service started. Press any key to stop."</span>)</span><br><span class="line"><span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line">fmt.Scanln(&amp;s)</span><br><span class="line">srv.Shutdown(ctx)</span><br><span class="line">err := registry.ShutdownService(address)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">cancel()</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> ctx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>至此，可以开始专心的写业务了</p></blockquote><h3 id="扫描器"><a href="#扫描器" class="headerlink" title="扫描器"></a>扫描器</h3><p>得益于Go高并发的优势，开启数百万个的<code>goroutine</code>的开销也不会很大，非常的轻量！🛫<br>因此代码实现起来很轻松，大体思路和<strong>端口扫描器</strong>类似，在此基础上根据目标特征添加判断条件即可<br>端口扫描器代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(ports <span class="keyword">chan</span> <span class="keyword">int</span>, results <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> p := <span class="keyword">range</span> ports &#123;</span><br><span class="line">address := fmt.Sprintf(<span class="string">"192.168.2.122:%d"</span>, p)</span><br><span class="line">fmt.Printf(<span class="string">"start %s\n"</span>, address)</span><br><span class="line">conn, err := net.DialTimeout(<span class="string">"tcp"</span>, address, time.Second*<span class="number">5</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">results &lt;- <span class="number">0</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">conn.Close()</span><br><span class="line">results &lt;- p</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ports := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">30000</span>)</span><br><span class="line">results := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br><span class="line">scanEndPort := <span class="number">65535</span></span><br><span class="line"><span class="keyword">var</span> openPorts []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">cap</span>(ports); i++ &#123;</span><br><span class="line"><span class="keyword">go</span> worker(ports, results)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// push port to channel</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= scanEndPort; i++ &#123;</span><br><span class="line">ports &lt;- i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(ports)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= scanEndPort; i++ &#123;</span><br><span class="line">res := &lt;-results</span><br><span class="line"><span class="keyword">if</span> res != <span class="number">0</span> &#123;</span><br><span class="line">openPorts = <span class="built_in">append</span>(openPorts, res)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(results)</span><br><span class="line">sort.Ints(openPorts)</span><br><span class="line"><span class="keyword">for</span> _, port := <span class="keyword">range</span> openPorts &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%d opend\n"</span>, port)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试器"><a href="#测试器" class="headerlink" title="测试器"></a>测试器</h3><p>测试器主要功能是从数据库中取出教务系统地址，然后测试。与扫描器不同仅在于扫描器是写，测试器是读。因此这部分内容和扫描器实际上是在同个包内的，只是逻辑上将它分离了出来。   </p><p>这部分其实和<code>consul</code>的功能是重复的，因此代码不过多赘述</p><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>由于校园网中，教务系统的地址不会太多，因此数据库的选择十分的随意(不存在性能方面的要求),所以这里使用自己熟悉的<code>redis</code>作为数据库。<br><strong>由于本系统是和官方的负载均衡并行的</strong> 因此存在某些结点用于两者共同访问导致压力上涨，响应不及时，因此利用<code>redis</code>的<code>sorted-set</code>在测试的时候，将响应快的地址设置高分数，使用<code>sorted-sets</code>的好处还有一个就是，集合的元素都是不重复的！，对于代理池来说，这个分数代表着教务系统地址稳定性的重要标准，因此设置分数的规则如下：</p><ul><li>基本分：10分，最高分：20</li><li>测试器设置一个更严格的超时时间来判断结点是否流畅</li><li>分数<strong>基本分</strong>为可用，检测器会定时循环检测每个代理可用情况，一旦检测到有可用的代理则立即置为<strong>最高分</strong></li><li>新获取的代理分数设置为<strong>基本分</strong>，如果测试可行(流畅)则置为满分，不可行(超时)则分数减一</li><li>分数减到0后代理移除</li></ul><p>由于是内网环境，分数与超时时间可以根据实际情况设置更严格</p><p>主要功能就是简单的CRUD啦，本文只讲逻辑与伪代码，实现部分就不多说了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set jwglxt to max score</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(addr discover.Addr)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">member, err := addr.MarshalBinary()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">err = rdb.ZAdd(ctx, redisConfig.Key, &amp;redis.Z&#123;</span><br><span class="line">Score:  SCORE_MAX,</span><br><span class="line">Member: member,</span><br><span class="line">&#125;).Err()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// decrease proxy score</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decrease</span><span class="params">(addr discover.Addr)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">member, err := addr.MarshalBinary()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">err = rdb.ZIncrBy(ctx, redisConfig.Key, <span class="number">-1</span>, <span class="keyword">string</span>(member)).Err()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">score := rdb.ZScore(ctx, redisConfig.Key, <span class="keyword">string</span>(member))</span><br><span class="line"><span class="keyword">if</span> score.Val() &lt;= <span class="number">0.00</span> &#123;</span><br><span class="line">log.Printf(<span class="string">"%v current score %v, remove.\n"</span>, addr, score.Val())</span><br><span class="line">err := rdb.ZRem(ctx, redisConfig.Key, member).Err()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// add new proxy to redis</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(addrs discover.Addrs)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, addr := <span class="keyword">range</span> addrs &#123;</span><br><span class="line">buf, err := addr.MarshalBinary()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">err = rdb.ZAdd(ctx, redisConfig.Key, &amp;redis.Z&#123;</span><br><span class="line">Score:  SCORE_DEFAULT,</span><br><span class="line">Member: buf,</span><br><span class="line">&#125;).Err()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="consul-upsync-nginx实现动态负载均衡"><a href="#consul-upsync-nginx实现动态负载均衡" class="headerlink" title="consul-upsync-nginx实现动态负载均衡"></a>consul-upsync-nginx实现动态负载均衡</h2><p>该部分可以说是系统实现的关键了，因为<code>nginx</code>自带的负载均衡是写死的，不能根据后端情况动态调整，通过一番搜索对比，最终决定了<code>consul</code> + <code>upsync</code>方案。   </p><ol><li><code>upsync</code> 一个Nginx的模块(扩展)</li><li><code>consul</code> 一个分布式高可用的系统</li></ol><p>这部分仅限于“能用”阶段，笔者也不太懂，就不乱说啦！<br>主要就是<strong>Api服务</strong>定时的获取数据库内容(分数作为权重)，然后推送到<strong>consul</strong>中</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>该项目是学习Go时的一个练手项目，很多地方都不太好，因此仓库就不开源了🐕</p><p>reference: <a href="https://mp.weixin.qq.com/s/kDd-BuDrKkV2odMoskmqzg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/kDd-BuDrKkV2odMoskmqzg</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;从上学期开始，学校的教务系统更新了。新版的正方多了一个负载均衡的功能，但无奈实在做的太差了！为什么这么说尼？&lt;br&gt;因为在上学期抢课的时候入口网关依旧拉闸，而真正的后端服务器访问速度比德芙还丝滑。因此暂将锅甩给负载均衡服务器。既然学校的负载均衡拉闸，那么就有了 &lt;strong&gt;“帮学校做负载均衡”&lt;/strong&gt; 的想法。&lt;br&gt;大体的思路就是，通过扫描内网网段发现隐藏的地址，然后负载均衡这些隐藏的地址。&lt;br&gt;既然是负载均衡，第一时间想到的就是&lt;code&gt;Nginx&lt;/code&gt;了，通过资料搜集，大致确定了基本的流程，因此有了这么的这个流程图:&lt;/p&gt;
&lt;img src=&quot;/2021/09/05/A-distributed-with-Go/floatChart.dio.png&quot; class=&quot;&quot; title=&quot;floatChart&quot;&gt;</summary>
    
    
    
    <category term="搞事情" scheme="https://blog.farmer233.top/categories/%E6%90%9E%E4%BA%8B%E6%83%85/"/>
    
    
    <category term="Golang" scheme="https://blog.farmer233.top/tags/Golang/"/>
    
    <category term="爬虫" scheme="https://blog.farmer233.top/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="正方教务系统" scheme="https://blog.farmer233.top/tags/%E6%AD%A3%E6%96%B9%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="nginx" scheme="https://blog.farmer233.top/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>新版正方教务系统登录实现</title>
    <link href="https://blog.farmer233.top/2021/09/03/%E6%96%B0%E7%89%88%E6%AD%A3%E6%96%B9%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%E7%99%BB%E5%BD%95%E5%AE%9E%E7%8E%B0/"/>
    <id>https://blog.farmer233.top/2021/09/03/%E6%96%B0%E7%89%88%E6%AD%A3%E6%96%B9%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%E7%99%BB%E5%BD%95%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-09-03T04:38:19.000Z</published>
    <updated>2021-09-03T15:42:17.737Z</updated>
    
    <content type="html"><![CDATA[<p>最近开学后相信很多同学都发现课表小程序等无法使用了，这是因为学校更新了正方教务系统，导致了大批基于旧版正方系统的校园小程序无法继续爬取课表。</p><p>之前曾在GitHub上看到过本校师兄开发的<code>school-api</code>–一个基于旧版正方的python SDK，但新版无法使用。因此花了两天时间研究了下新版正方的登录(能登录后续的就EZ啦~) </p><p>既然都弄了，因此计划开发一个新的SDK。我比较懒 暂命名为<code>new-school-sdk</code>，项目目前还在开发中，先将登录的流程、验证码识别的思路罗列出来。(拿到了cookies 还有啥不能干嘛)</p><p>项目Github地址: <a href="https://github.com/Farmer-chong/new-school-sdk" target="_blank" rel="noopener">https://github.com/Farmer-chong/new-school-sdk</a> </p><h2 id="登录前期准备"><a href="#登录前期准备" class="headerlink" title="登录前期准备"></a>登录前期准备</h2><img src="/2021/09/03/%E6%96%B0%E7%89%88%E6%AD%A3%E6%96%B9%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%E7%99%BB%E5%BD%95%E5%AE%9E%E7%8E%B0/zf-index.png" class="" title="zf-index"><p>通过观察发现，有以下几个难点：</p><ol><li>新版正方使用Java进行开发且并非前后端分离，因此只要我们能拿到<code>cookie</code>即能完成登录。</li><li>验证码的识别</li><li>正方使用了Rsa对数据进行加密</li></ol><p>针对上述问题，开始一一解决</p><h2 id="验证码部分"><a href="#验证码部分" class="headerlink" title="验证码部分"></a>验证码部分</h2><p>前置工作准备好后，开始从服务器获取验证码并进行验证</p><h3 id="获取验证码"><a href="#获取验证码" class="headerlink" title="获取验证码"></a>获取验证码</h3><p>网络抓包发现，验证码是异步获取的，每次刷新都会发送一个请求到<code>/zfcaptchaLogin</code></p><img src="/2021/09/03/%E6%96%B0%E7%89%88%E6%AD%A3%E6%96%B9%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%E7%99%BB%E5%BD%95%E5%AE%9E%E7%8E%B0/network-captcha.png" class="" title="captcha"><p>请求报文内容有：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">"type": "refresh"</span><br><span class="line">"rtk": "56f88546-d402-4afd-88b5-82a203258da8"</span><br><span class="line">"time": "1630645045207"</span><br><span class="line">"instanceId": "zfcaptchaLogin"</span><br></pre></td></tr></table></figure><p>响应报文内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">imtk: "29730cb5-d7ff-4fc9-aa9d-e3efc0a07f55"</span><br><span class="line">mi: "a8f191af-f267-4681-881a-54558298db09.png"</span><br><span class="line">msg: ""</span><br><span class="line">si: "1ccd27c6-6208-41f9-adfb-13beafa6d954.png"</span><br><span class="line">status: "success"</span><br><span class="line">t: 1630645937179</span><br><span class="line">vs: "not_verify"</span><br></pre></td></tr></table></figure><p>观察请求报文发现需要<code>type</code>、<code>rtk</code>、<code>time</code>和<code>instanceId</code>这几个字段。</p><p>其中<code>rtk</code>未知，因此开始寻找其出现的地方。通过查找发现rtk出现在一个js文件中，初步猜测<code>rtk</code>是一个令牌，由服务器随机生成的。<br>因此我们要先获取<code>rtk</code>令牌，然后利用正则表达式将其值提取出来。</p><img src="/2021/09/03/%E6%96%B0%E7%89%88%E6%AD%A3%E6%96%B9%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%E7%99%BB%E5%BD%95%E5%AE%9E%E7%8E%B0/network-find-rtk.png" class="" title="rtk"><h3 id="下载验证图片"><a href="#下载验证图片" class="headerlink" title="下载验证图片"></a>下载验证图片</h3><p>但现在仍然无法获取验证图片的原始数据，再观察<code>img</code>的<code>src</code>属性，得知响应报文中的<code>mi</code>和<code>si</code>分别别是<code>验证码</code>和<code>滑块</code>。并且需要的url参数我们也已经获取了。</p><p>向<code>/zfcaptchaLogin</code>发送一个<code>GET</code>请求，请求参数如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type: image</span><br><span class="line">id: 上一步响应体中的si</span><br><span class="line">imtk: 上一步响应体中的imtk</span><br><span class="line">t: 时间戳</span><br><span class="line">instanceId: zfcaptchaLogin</span><br></pre></td></tr></table></figure><h3 id="滑动验证码识别"><a href="#滑动验证码识别" class="headerlink" title="滑动验证码识别"></a>滑动验证码识别</h3><p>上文中有提到，参考这篇文章: <a href="https://blog.dairoot.cn/2021/06/26/zf-sliding-captcha/" target="_blank" rel="noopener">https://blog.dairoot.cn/2021/06/26/zf-sliding-captcha/</a></p><p>大致流程如下：</p><ol><li>将图片灰度化</li><li>识别出一段颜色差小于阈值的线(竖的)</li><li>识别出来的这段线不能太短(要和缺口差不多高)</li></ol><p>因此即可计算出该线的x轴坐标，因此得到滑块偏移量。  </p><h3 id="模拟人手拖动-amp-发起验证请求"><a href="#模拟人手拖动-amp-发起验证请求" class="headerlink" title="模拟人手拖动&amp;发起验证请求"></a>模拟人手拖动&amp;发起验证请求</h3><p>从上一步中，我们得到了偏移量<code>X</code>和<code>Y</code>，接下来就要开始模拟人手拖动滑块的过程了。人手滑动验证码时，一般都是先快后慢的一个速度曲线，因此利用物理学公式分段设置加速度<code>a</code>，前半段<code>a &gt; 0</code>，后半段<code>a &lt; 0</code>。<br>当前速度用<code>v</code>表示，初速度用<code>v0</code>，位移用<code>x</code>，时间用<code>t</code>，它们之间满足如下关系：<br><code>x = v0 * t + 0.5 * a * t^2</code><br><code>v = v0 + a * t</code><br>移动算法的代码实现如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_get_track</span><span class="params">(self, distance, y)</span>:</span></span><br><span class="line">    <span class="string">"""模拟人手滑动</span></span><br><span class="line"><span class="string">    通过设置前快后慢的加速度，模拟人手滑动</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        distance ([int]): [移动距离]</span></span><br><span class="line"><span class="string">        y ([int]): [滑块Y值]</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        [list]: [坐标数组]</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    start = <span class="number">1200</span></span><br><span class="line">    current = <span class="number">0</span></span><br><span class="line">    track = []</span><br><span class="line">    <span class="comment"># 减速阈值</span></span><br><span class="line">    mid = distance * <span class="number">4</span> / <span class="number">5</span></span><br><span class="line">    <span class="comment"># 计算间隔</span></span><br><span class="line">    t = <span class="number">0.2</span></span><br><span class="line">    <span class="comment"># 初速度</span></span><br><span class="line">    v = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> current &lt; distance:</span><br><span class="line">        <span class="comment"># 加速-&gt;加速度为 2; 减速-&gt;加速度为-3</span></span><br><span class="line">        a = <span class="number">2</span> <span class="keyword">if</span> current &lt; mid <span class="keyword">else</span> <span class="number">-3</span></span><br><span class="line">        v0 = v</span><br><span class="line">        <span class="comment"># 当前速度 v = v0 + at</span></span><br><span class="line">        v = v0 + a * t</span><br><span class="line">        <span class="comment"># 移动距离 x = v0t + 1/2 * a * t^2</span></span><br><span class="line">        move = v0 * t + <span class="number">1</span> / <span class="number">2</span> * a * t * t</span><br><span class="line">        <span class="comment"># 当前位移量</span></span><br><span class="line">        current += move</span><br><span class="line">        <span class="comment"># 加入轨迹</span></span><br><span class="line">        track.append(&#123;<span class="string">"x"</span>: start + int(current), <span class="string">"y"</span>: y, <span class="string">"t"</span>: int(time.time() * <span class="number">1000</span>)&#125;)</span><br><span class="line">        time.sleep(<span class="number">0.01</span>)</span><br><span class="line">    <span class="keyword">return</span> track</span><br></pre></td></tr></table></figure><p>至此，我们得到了发起请求的所有数据，因此向<code>/zfcaptchaLogin</code>发送一个<code>POST</code>请求，请求体如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type: verify</span><br><span class="line">rtk: 56f88546-d402-4afd-88b5-82a203258da8</span><br><span class="line">time: 1630650071446</span><br><span class="line">mt: 将模拟滑动的内容通过base64编码</span><br><span class="line">instanceId: zfcaptchaLogin</span><br><span class="line">extend: 将UA进行编码</span><br></pre></td></tr></table></figure><p>当验证通过时，得到如下的响应体:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">msg: ""</span><br><span class="line">status: "success"</span><br><span class="line">vs: "verified"</span><br></pre></td></tr></table></figure><h2 id="登录部分"><a href="#登录部分" class="headerlink" title="登录部分"></a>登录部分</h2><h3 id="获取RSA公钥"><a href="#获取RSA公钥" class="headerlink" title="获取RSA公钥"></a>获取RSA公钥</h3><p>通过查看页面源码和点击登录后抓包，登录发送一个请求到<code>/xtgl/login_slogin.html</code>，然后返回一个302的跳转。<br>其中请求报文内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">csrftoken: csrftoken</span><br><span class="line">language: zh_CN</span><br><span class="line">yhm: 登录账号</span><br><span class="line">mm: 加密后的密码</span><br><span class="line">mm: 加密后的密码</span><br></pre></td></tr></table></figure><p>此处<code>csrftoken</code>和<code>mm</code>两个字段是未知的。其中<code>csrf</code>令牌是为了防止攻击的，一般包含在<code>form</code>表单中，由后端生成。因此我们可以直接从页面中提取。如下图：</p><img src="/2021/09/03/%E6%96%B0%E7%89%88%E6%AD%A3%E6%96%B9%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%E7%99%BB%E5%BD%95%E5%AE%9E%E7%8E%B0/csrftoken.png" class="" title="csrftoken"><p>而<code>mm</code>字段，通过对前端异步请求部分的代码进行分析后，发现是利用<code>RSA</code>进行加密，从抓包中可以发现一个发送到<code>/login_getPublicKey.html</code>地址的<code>GET</code>请求。其响应体内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exponent: "AQAB"</span><br><span class="line">modulus: "AIdzVtHXJLlh5vOlWFiRnWHc1xaChgqY1u4LNpaMjVUByVHwdvMMmlw4np8u/B3esIS2hsdQ7nRkrzWYYbkTWo8bm2LGS0H3/h1GVjLWaMrn1uj6lMYz0Y0O0AMUc19y23XRnSM7Q/d9V7tk6oS1HwyUKJwA7aSTgyenhNj26XrL"</span><br></pre></td></tr></table></figure><p>因此得到了<code>RSA</code>的<code>指数</code>和<code>模</code>，但这里的<code>modulus</code>长度为 172。大概率是正方修改过加密，在<code>JavaScript</code>文件的注释中也可以看到。<br>本来是打算自己重写一个python版的实现，后来在<code>GitHub</code>上发现已有前人栽树，我乘凉就好啦！ </p><blockquote><p>PyRsa仓库: <a href="https://github.com/hibiscustoyou/pyrsa" target="_blank" rel="noopener">https://github.com/hibiscustoyou/pyrsa</a></p></blockquote><p>到现在为止，整个登录流程的未知项就全解决了！🛫🍯</p><h3 id="开始登录"><a href="#开始登录" class="headerlink" title="开始登录"></a>开始登录</h3><p>再次观察数据包的流程，得知登录各项的顺序并做优化：</p><p><strong>! 注意，在登录发生302跳转的时候，cookie会发生改变 !</strong></p><ol><li>访问登录页面，获取<code>csrf</code>和原始的<code>cookies</code></li><li>获取<code>rsa</code>公钥</li><li>处理滑块验证</li><li>发起登录，得到登录后的<code>cookie</code></li></ol><p>成功截图：</p><img src="/2021/09/03/%E6%96%B0%E7%89%88%E6%AD%A3%E6%96%B9%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%E7%99%BB%E5%BD%95%E5%AE%9E%E7%8E%B0/login.png" class="" title="login"><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>sdk开发中，希望大佬们多多给意见或者一起开发哈！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近开学后相信很多同学都发现课表小程序等无法使用了，这是因为学校更新了正方教务系统，导致了大批基于旧版正方系统的校园小程序无法继续爬取课表。&lt;/p&gt;
&lt;p&gt;之前曾在GitHub上看到过本校师兄开发的&lt;code&gt;school-api&lt;/code&gt;–一个基于旧版正方的pytho</summary>
      
    
    
    
    <category term="搞事情" scheme="https://blog.farmer233.top/categories/%E6%90%9E%E4%BA%8B%E6%83%85/"/>
    
    
    <category term="python" scheme="https://blog.farmer233.top/tags/python/"/>
    
    <category term="爬虫" scheme="https://blog.farmer233.top/tags/%E7%88%AC%E8%99%AB/"/>
    
    <category term="正方教务系统" scheme="https://blog.farmer233.top/tags/%E6%AD%A3%E6%96%B9%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="web" scheme="https://blog.farmer233.top/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>Golang基础语法笔记 | 数组、切片&amp;映射</title>
    <link href="https://blog.farmer233.top/2021/08/20/Golang%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    <id>https://blog.farmer233.top/2021/08/20/Golang%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0/</id>
    <published>2021-08-19T16:30:25.000Z</published>
    <updated>2021-08-29T17:59:56.159Z</updated>
    
    <content type="html"><![CDATA[<p>Go入门和《Go语言实战》的笔记，本篇总结了基础的数组、切片和哈希表的内容。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是切片和映射的基础数据结构，因此了解数组的工作原理有助于理解切片和映射。<br>和C语言一样，在go中数组也是一段<strong>连续</strong>、<strong>长度固定</strong>用于存储<strong>同一类型</strong>元素的连续块。</p><h3 id="声明和初始化"><a href="#声明和初始化" class="headerlink" title="声明和初始化"></a>声明和初始化</h3><p>数组的声明和初始化，和其他类型差不多。声明的原则是：</p><ol><li>指明存储数据的类型。</li><li>存储元素的数量，也就是数组长度。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array [<span class="number">5</span>]<span class="keyword">int</span></span><br></pre></td></tr></table></figure></li></ol><p>声明变量时，总会使用对应类型的灵芝累对变量进行初始化，如上面的代码声明了一个数组<code>array</code>，但我们还没有对他进行初始化，此时这个数组内的值，就是对应类型的零值=&gt; 这里的对应类型时<code>int</code>，因此改数组目前为5个0 <code>[0,0,0,0,0]</code><br>由于数组初始化后长度是固定的，如果需要存储更多的元素则需要进行扩容。也就是需要再创建一个更长的数组，再把原来的数组复制到新数组里面。    </p><p>上面的数组仅仅只是<strong>声明</strong>，go还可以很方便的<strong>初始化并声明</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><p>上面的这段代码相当于下面:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array [<span class="number">5</span>]<span class="keyword">int</span></span><br><span class="line">array = [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><p>除此之外，go语言还能自动计算声明数组的长度，也就是根据内容，自动分配长度</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br></pre></td></tr></table></figure><p>有的时候我们已知数组的长度，但内容只知道个别几个，我们可以用下面这种方式:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>: <span class="number">10</span>, <span class="number">3</span>: <span class="number">30</span>&#125;</span><br></pre></td></tr></table></figure><p>这样我们声明了一个长度为<code>5</code>的数组，并且初始化索引为<code>1</code>和<code>3</code>的元素</p><h3 id="使用数组"><a href="#使用数组" class="headerlink" title="使用数组"></a>使用数组</h3><p>数组使用上和别的语言没有太大的差异，主要就是通过下标访问。值得关心的是，Go语言的指针数组十分的好用<br><strong>将一个指针数组赋值给另一个</strong>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 [<span class="number">3</span>]*<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">arr2 := [<span class="number">3</span>]*<span class="keyword">string</span>&#123;<span class="built_in">new</span>(<span class="keyword">string</span>), <span class="built_in">new</span>(<span class="keyword">string</span>), <span class="built_in">new</span>(<span class="keyword">string</span>)&#125;</span><br><span class="line"></span><br><span class="line">*arr2[<span class="number">0</span>] = <span class="string">"Red"</span></span><br><span class="line">*arr2[<span class="number">1</span>] = <span class="string">"Blue"</span></span><br><span class="line">*arr2[<span class="number">2</span>] = <span class="string">"Green"</span></span><br><span class="line"><span class="comment">// 复制</span></span><br><span class="line">arr1 = arr2</span><br></pre></td></tr></table></figure><p>此时复制后的两个数组则指向同一组字符串了。</p><h3 id="函数间传递数组"><a href="#函数间传递数组" class="headerlink" title="函数间传递数组"></a>函数间传递数组</h3><p>在函数间传递变量时，总是以值的方式传递（也就是值传递）。因此在函数间传递数组是一个开销很大的操作–比如有个占用<code>8M</code>内存的数组，那么每次调用这个函数的时候go都会在栈上分配8MB的内存，试想一下同时调用100次这个函数，占用的内存会多么的惊人。<br>虽然Go自己会处理复制的这个操作，但还有一种更优雅的方法来处理这个操作，这个方法在C中十分的常见-&gt;<strong>传入指向数组的指针</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配一个8MB的数组</span></span><br><span class="line"><span class="keyword">var</span> arr [le6]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">foo(&amp;arr)</span><br><span class="line"></span><br><span class="line">fun foo(arr *[le6]<span class="keyword">int</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是传递数组的指针的例子，会发现数组被修改了。所以这种情况虽然节省了复制的内存，但是要谨慎使用，因为一不小心，就会修改原数组，导致不必要的问题。</p><blockquote><p>这里注意，数组的指针和指针数组是两个概念，数组的指针是<code>*[5]int</code>,指针数组是<code>[5]*int</code>，注意<code>*</code>的位置。</p></blockquote><p>针对函数间传递数组的问题，比如复制问题，比如大小僵化问题，都有更好的解决办法，这个就是切片，它更灵活。</p><h2 id="切片-Slice"><a href="#切片-Slice" class="headerlink" title="切片(Slice)"></a>切片(Slice)</h2><p>切片是一种数组结构，它是围绕动态数组的概念构建的（⚠<strong>和python的切片不完全相同</strong>）。切片可以按需自动增长和缩小，因为切片底层内存也是在连续的块中分配的，所以切片还有索引、迭代以及垃圾回收等好处</p><h3 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h3><p>切片的底层是数组，切片本身非常的小，它是对底层数组进行了抽象。切片有3个字段的数据结构，包含了Go需要操作数组的元数据。<br>这三个字段分别是<code>指向底层数组的指针</code>、<code>长度(切片能访问元素的个数)</code>和<code>切片总体的容量(真实容量)</code></p><blockquote><p>为了解决数组长度不可变，切片实际上就是提前声明了一个更长的数组(即切片的容量)，而切片的长度表示当前切片内能访问的元素的数量。</p></blockquote><p><strong>因此切片有这样一条公式：</strong><code>长度&lt;=容量</code></p><h3 id="声明-amp-初始化-amp-使用"><a href="#声明-amp-初始化-amp-使用" class="headerlink" title="声明&amp;初始化&amp;使用"></a>声明&amp;初始化&amp;使用</h3><p><strong>1. make和切片字面量</strong></p><p>使用<code>make</code>函数时，需要传入一个参数，指定切片的长度</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个长度和容量都是5的字符串切片</span></span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>前面说到，切片的长度和容量是两个不一样的概念，因此创建的时候也可以指定<code>长度</code>和<code>容量</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 长度为3，容量为5</span></span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>除了使用<code>make</code>函数，我们还可以使用切片<strong>字面量</strong>来声明切片–指定初始化的值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><p>可以发现切片和创建数组非常像，只不过不用指定<code>[]</code>中的值。  <strong>注意</strong>此时切片的长度和容量是相等的，并且会根据我们指定额字面量推到出来，当然我们也可以只初始化某个索引的值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">2</span>: <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 空切片和nil切片</strong><br>有的时候我们需要声明一个值为<code>nil</code>的切片(nil切片)。只要在声明式不做初始化就可以了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice []<span class="keyword">int</span></span><br></pre></td></tr></table></figure><p>空切片和nil切片不同的地方在于，空切片的底层数组包含0个元素，也就是说没有分配任何存储空间。<br>但切片里面的<strong>指向底层数组的指针</strong>是有内容的，而nil切片<strong>指向底层数组的指针</strong>则为nil</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><strong>3. 使用切片</strong><br>go的切片用法上和python的类似，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">newSlice := slice[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"><span class="comment">// newSlice -&gt; 2,3</span></span><br></pre></td></tr></table></figure><p>需要注意，第一个切片因为使用字面量的方式，因此它的长度和容量都为5。不过之后的<code>newSlice</code>就不一样了，对于<code>newSlice</code>来说其底层数组的容量只有4个元素，切片长度为2。根据下面的公式，可以计算任意切片的长度和容量:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对于底层数组容量为K的切片 slice[i:j] </span><br><span class="line">长度: j - i</span><br><span class="line">容量: k - i</span><br></pre></td></tr></table></figure><blockquote><p>由于切片是在元切片的基础上的抽象，因此新的切片和旧切片实际上指向的是同一个数组，故修改同一个索引的内容时会导致原切片的内容发生改变</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">array := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">newSlice := array[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"><span class="comment">// array -&gt; 1,2,3,4,5</span></span><br><span class="line"><span class="comment">// newSlice -&gt; 2, 3</span></span><br><span class="line">newSlice[<span class="number">1</span>] = <span class="number">233</span></span><br><span class="line"><span class="comment">//  array -&gt; 1,2,233,4,5</span></span><br><span class="line"><span class="comment">//  newSlice -&gt; 2, 233</span></span><br></pre></td></tr></table></figure><p><strong>三个索引的切片</strong><br>创建切片时，第三个索引选项可以用来<strong>控制新切片的容量</strong>。⚠其目的并不是增加容量，而时限制容量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">source := []<span class="keyword">string</span>&#123;<span class="string">"Apple"</span>, <span class="string">"Orange"</span>, <span class="string">"Plum"</span>, <span class="string">"Banana"</span>, <span class="string">"Grape"</span>&#125;</span><br><span class="line"><span class="comment">// 数组: [2:3)  ; 容量: [2, 4)</span></span><br><span class="line"><span class="comment">// 因此长度: 1; 容量: 2</span></span><br><span class="line">slice := source[<span class="number">2</span>:<span class="number">3</span>:<span class="number">4</span>]</span><br></pre></td></tr></table></figure><p><strong>第三个选项也不可以超出索引范围!!!</strong></p><h3 id="切片增长"><a href="#切片增长" class="headerlink" title="切片增长"></a>切片增长</h3><p>按需增长可以说是切片的一个重要的特性。Go内置的<code>append</code>函数会处理增长长度时所有的操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">newSlice := slice[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">newSlice = <span class="built_in">append</span>(newSlice, <span class="number">60</span>)</span><br></pre></td></tr></table></figure><p>因为<code>newSlice</code>在底层数组里还有额外的容量可用，append会将可用的元素合并到切片的长度，并对其进行赋值。由于和原始的<code>slice</code>共享同一个底层数组，slice中索引为3的元素的值也被改动了。<br>如果底层数组没有足够的可用容量，append会创建一个新的底层数组，将被引用的现有值复制到新数组里，再追加新的值。</p><blockquote><p>append会智能地处理底层数组地容量增长，当切片容量小于1000个元素时总会成倍地增加容量，超过1000后容量的增长因子设为1.25(增长算法不恒定)</p></blockquote><p>此外，通过<code>...</code>操作符，把一个切片追加到另一个切片里。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">newSlice := slice[<span class="number">1</span>:<span class="number">2</span>:<span class="number">3</span>]</span><br><span class="line">newSlice = <span class="built_in">append</span>(newSlice, slice...)</span><br></pre></td></tr></table></figure><h3 id="迭代切片"><a href="#迭代切片" class="headerlink" title="迭代切片"></a>迭代切片</h3><p>切片是一个集合，我们就可以迭代其中的元素。与python类似，Go有个特殊的关键字<code>range</code>，它可以配合<code>for</code>来迭代切片里的元素。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i,v:=<span class="keyword">range</span> slice&#123;</span><br><span class="line">fmt.Printf(<span class="string">"index:%d, value:%d\n"</span>,i,v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中可以看到，迭代的时候会返回两个值: <code>index</code>和<code>value</code>，这里的<code>value</code>是一个副本。<br>需要强调的是，range创建了每个元素的<strong>副本</strong>，而不是直接返回该元素的引用。<br>很多时候，我们使用迭代都不需要索引<code>index</code>，此时可以使用占位符<code>_</code>来忽略这个值:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">for</span> _,v:=<span class="keyword">range</span> slice&#123;</span><br><span class="line">fmt.Printf(<span class="string">"value:%d\n"</span>, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>range</code>总是从头开始迭代。如果需要更多的控制，依旧可以使用传统的for循环：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="keyword">for</span> index := <span class="number">2</span>; index &lt; <span class="built_in">len</span>(slice); index++&#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Index: %d Value: %d\n"</span>, index, slice[index])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output</span></span><br><span class="line">Index: <span class="number">2</span> Value: <span class="number">3</span></span><br><span class="line">Index: <span class="number">3</span> Value: <span class="number">4</span></span><br></pre></td></tr></table></figure><p>有两个特殊的内置函数<code>len</code>可以用于处理数组、切片和通道。对于切片来说，<code>len</code>返回切片的长度，<code>cap</code>返回切片的容量。</p><h3 id="函数间传递"><a href="#函数间传递" class="headerlink" title="函数间传递"></a>函数间传递</h3><p>在函数间传递切片的时候，就是要以值的方式传递切片，因为切片的尺寸很小，在函数间复制和传递切片成本也很低。（因为切片的数据结构只是一个指向数组的指针、长度和容量，不是把整个数组复制）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">int</span>, le6)</span><br><span class="line">slice = foo(slice)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(slice []<span class="keyword">int</span>)</span> []<span class="title">int</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> slice</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="映射-Map"><a href="#映射-Map" class="headerlink" title="映射(Map)"></a>映射(Map)</h2><p>正如标题所示，在《Go语言实战》中Map翻译成映射，相比于翻译相信Map更广为人知。<br>Map是一种数据结构(哈希表 or 散列表)，用来存储一系列的<strong>键值对</strong>，如果你学习过别的语言相信看到这你就明白Map是什么了。在<code>python</code>中这样的数据结构称为<code>dict(字典)</code>、<code>JavaScript</code>中称为<code>json(JavaScript Object Notation)</code></p><h3 id="内部实现-1"><a href="#内部实现-1" class="headerlink" title="内部实现"></a>内部实现</h3><p>Map是Go语言中哈希表的实现，因此我们每次迭代Map时打印的Key和Value时无序的，每次迭代都是不一样的。   </p><p>Map的散列表中包含一组桶，在存储、删除或查找键值对的时候，所有操作都要线选择一个桶，如何选择桶？就是先把要查找的<code>key</code>传给哈希函数，从而<strong>生成一个索引</strong>，进而找到对应的桶。</p><p>因此随着<em>映射</em>的增加，索引会分布的越来越均匀，因此访问键值对的速度就越快。（参考哈希表相关内容）由于本文主要是学习Go基础，因此不再继续深入，只要记住<strong>Map是无序的</strong></p><h3 id="声明-amp-初始化"><a href="#声明-amp-初始化" class="headerlink" title="声明&amp;初始化"></a>声明&amp;初始化</h3><p>Map的创建有如下几种方式：</p><ol><li><code>make</code>函数声明<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure></li><li><code>map</code>字面量<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不指定任何键值对-&gt;也就是一个空map</span></span><br><span class="line">dict := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="comment">// 赋予内容</span></span><br><span class="line">dict := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"张三"</span>:<span class="number">43</span>&#125;</span><br><span class="line"><span class="comment">// 多个内容</span></span><br><span class="line">dict := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"张三"</span>:<span class="number">43</span>,<span class="string">"李四"</span>:<span class="number">50</span>&#125;</span><br></pre></td></tr></table></figure></li></ol><p>Map的键可以是任何值，键的类型可以是内置的类型，也可以是结构类型，但是不管怎么样，这个键可以使用<code>==</code>运算符进行比较，所以像切片、函数以及含有切片的结构类型就不能用于Map的键了，因为他们具有引用的语义，不可比较。</p><blockquote><p>总结: 对于Map的值来说没有什么限制，但切片这种类型在键里不能用的，可以用在值里</p></blockquote><h3 id="使用Map"><a href="#使用Map" class="headerlink" title="使用Map"></a>使用Map</h3><p>Go语言的Map和别的语言都大同小异，使用非常简单和数组切片差不多   </p><p>如果键张三存在，则对其值修改，如果不存在，则新增这个键值对</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dict := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">dict[<span class="string">"张三"</span>] = <span class="number">43</span></span><br><span class="line">age := dict[<span class="string">"张三"</span>]</span><br></pre></td></tr></table></figure><p>很多时候我们都要判断Map中是否存在某个键值对.在Go Map中，如果我们获取一个不存在的键的值，也是可以的，返回的是<em>值类型</em>的零值，这样就会导致我们不知道是真的存在一个为零值的键值对呢，还是说这个键值对就不存在。对此，Map为我们提供了检测一个键值对是否存在的方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">age, exist := dict[<span class="string">"李四"</span>]</span><br><span class="line"><span class="keyword">if</span> exist &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看这个例子，和获取键的值没有太大区别，只是多了一个返回值。第一个返回值是键的值；第二个返回值标记这个键是否存在，这是一个boolean类型的变量，我们判断它就知道该键是否存在了。这也是Go多值返回的好处。</p><p>如果我们想删除一个键值对，可以使用内置的<code>delete</code>函数, <code>delete</code>函数接受两个参数，第一个是要操作的Map，第二个是要删除的Map的键。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(dict,<span class="string">"张三"</span>)</span><br></pre></td></tr></table></figure><blockquote><p>delete函数删除不存在的键也是可以的，只是没有任何作用。</p></blockquote><p>在Go中，我们可以使用<code>range</code>迭代Map，这和遍历切片是一样的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dict := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"张三"</span>: <span class="number">43</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> dict &#123;</span><br><span class="line">fmt.Println(key, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>rang</code>返回两个值，这和python是类似的，第一个是键，第二个是值。</p><h3 id="在函数间传递Map"><a href="#在函数间传递Map" class="headerlink" title="在函数间传递Map"></a>在函数间传递Map</h3><p>函数间传递Map是不会制造副本的，也就是说如果一个Map传递给一个函数，该函数对这个Map做了修改，那么这个Map的所有引用都会被修改。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">dict := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"王五"</span>: <span class="number">60</span>, <span class="string">"张三"</span>: <span class="number">43</span>&#125;</span><br><span class="line">modify(dict)</span><br><span class="line">fmt.Println(dict[<span class="string">"张三"</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(dict <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">dict[<span class="string">"张三"</span>] = <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Go入门和《Go语言实战》的笔记，本篇总结了基础的数组、切片和哈希表的内容。&lt;/p&gt;
&lt;h2 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h2&gt;&lt;p&gt;数组是切片和映射的基础数据结构，因此了解数组的工</summary>
      
    
    
    
    <category term="学了些什么" scheme="https://blog.farmer233.top/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="Golang" scheme="https://blog.farmer233.top/tags/Golang/"/>
    
    <category term="笔记" scheme="https://blog.farmer233.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>提问中需要避免的一些行为</title>
    <link href="https://blog.farmer233.top/2021/08/07/%E6%8F%90%E9%97%AE%E4%B8%AD%E9%9C%80%E8%A6%81%E9%81%BF%E5%85%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%8C%E4%B8%BA/"/>
    <id>https://blog.farmer233.top/2021/08/07/%E6%8F%90%E9%97%AE%E4%B8%AD%E9%9C%80%E8%A6%81%E9%81%BF%E5%85%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%8C%E4%B8%BA/</id>
    <published>2021-08-06T18:10:23.000Z</published>
    <updated>2021-08-07T04:14:53.440Z</updated>
    
    <content type="html"><![CDATA[<img src="/2021/08/07/%E6%8F%90%E9%97%AE%E4%B8%AD%E9%9C%80%E8%A6%81%E9%81%BF%E5%85%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%8C%E4%B8%BA/question.jpg" class="" title="img"><blockquote><p>本文灵感源于F大的这篇文章–<a href="https://frostming.com/2019/12-26/qa-no-action/" target="_blank" rel="noopener">社区问答中需要避免的行为</a>  </p></blockquote><p>长年混迹于QQ群、微信群和各大论坛，给人的印象和态度都属于是态度不友好类型。这并不是因为我鄙视菜鸟，我也曾是菜鸟（现在也是）。我这么做的原因也是我希望<strong>提问者能自己意识到问题所在</strong> -&gt; 为什么错了？应该怎么解决？这比我直接告诉他一个答案有帮助得多。逛社区这么久，我发现很多问题都提问的不是很好，不吐不快。<br>ps: 除了提问者应该学会提问外，回答者也有不好的回答。</p><h2 id="How-To-Ask-Questions"><a href="#How-To-Ask-Questions" class="headerlink" title="How To Ask Questions"></a>How To Ask Questions</h2><p>这个问题已经是听得耳朵起茧了，故不再赘述。但必须强调的是问问题是一门高深的学问，问的好不好直接影响到你是否能得到高效、直接、有效的回答。<br><strong>关于提问总结出有一下两个比较主要的问题：</strong></p><ol><li>不会提问</li><li>X-Y问题</li></ol><p>如果不会提问，<strong>一定要阅读下面的链接</strong>：</p><ul><li><a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md" target="_blank" rel="noopener">提问的智慧</a></li><li><a href="https://coolshell.cn/articles/10804.html" target="_blank" rel="noopener">X-Y问题</a></li></ul><h3 id="X-Y问题"><a href="#X-Y问题" class="headerlink" title="X-Y问题"></a>X-Y问题</h3><p>相比于不会提问，更让人恼火的是<code>X-Y问题</code>。概况起来如下：</p><ol><li>提问者想解决问题X</li><li>然后觉得Y可能是解决X问题的方法</li><li>但他不知道Y应该怎么做</li><li>于是他去问别人Y应该怎么做</li></ol><p>于是很多人都会热心的告诉这个人Y应该怎么处理，但大家都觉得Y这个方案比较怪异。经过大量的讨论浪费了大量的实践后人们终于明白了原始问题X，于是发现Y根本就不是用来解决X最合适的方案。<br>这个问题最大的问题在于：<strong>在一个根本错误的方向上浪费他人大量的时间和精力！！！</strong>十分的让人高血压！<br>关于X-Y问题，有许多的变种。不能说他们没有自己尝试动手解决问题，但这样的问题往往更浪费时间。</p><h2 id="用XXX干嘛，为什么不用XXX"><a href="#用XXX干嘛，为什么不用XXX" class="headerlink" title="用XXX干嘛，为什么不用XXX"></a>用XXX干嘛，为什么不用XXX</h2><blockquote><p>Q: 用Flask怎么做XXX？<br>A: 用Django吧</p></blockquote><p>某小白终于鼓起勇气，开始学某一框架，碰到了瓶颈，结果上来一提问，被安利了另一个框架，好嘛，白学了。这也很不负责任，我觉得要说服人用一个新的框架，接触新的知识，你得对两者都有相当的熟悉度，并且清楚两者的优劣。<br>如果你只是对其中一个比较熟悉，除非你确信已有方案确实做不到，或者要付出极大的代价才能实现，否则我会尽量沿用提问者已选择的方案。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/2021/08/07/%E6%8F%90%E9%97%AE%E4%B8%AD%E9%9C%80%E8%A6%81%E9%81%BF%E5%85%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%8C%E4%B8%BA/question.</summary>
      
    
    
    
    <category term="胡思乱语" scheme="https://blog.farmer233.top/categories/%E8%83%A1%E6%80%9D%E4%B9%B1%E8%AF%AD/"/>
    
    
    <category term="胡言乱语" scheme="https://blog.farmer233.top/tags/%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD/"/>
    
    <category term="吐槽" scheme="https://blog.farmer233.top/tags/%E5%90%90%E6%A7%BD/"/>
    
  </entry>
  
  <entry>
    <title>[Leetcode]数据结构题目集的最后一天</title>
    <link href="https://blog.farmer233.top/2021/08/02/Leetcode-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E7%9B%AE%E9%9B%86%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E5%A4%A9/"/>
    <id>https://blog.farmer233.top/2021/08/02/Leetcode-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E7%9B%AE%E9%9B%86%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E5%A4%A9/</id>
    <published>2021-08-02T10:48:19.000Z</published>
    <updated>2021-09-26T07:14:55.584Z</updated>
    
    <content type="html"><![CDATA[<p>终于刷完了，芜湖！🛫🛫🛫<br>这套题目集总体难度不高，适合刚学的时候作为随堂练习。<br>题目代码我也同步到<code>GitHub</code>仓库了🎈：<a href="https://github.com/Farmer-chong/LearnProcess/tree/master/Leetcode/leetcode-dataStruct-1" target="_blank" rel="noopener">https://github.com/Farmer-chong/LearnProcess/tree/master/Leetcode/leetcode-dataStruct-1</a></p><a id="more"></a><h2 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h2><blockquote><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p></blockquote><p>假设一个二叉搜索树具有如下特征：</p><ul><li>节点的左子树只包含<strong>小于</strong>当前节点的数。</li><li>节点的右子树只包含<strong>大于</strong>当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p>示例 1:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">输入:</span></span><br><span class="line">    <span class="number">2</span></span><br><span class="line">   <span class="string">/</span> <span class="string">\</span></span><br><span class="line">  <span class="number">1</span>   <span class="number">3</span></span><br><span class="line"><span class="string">输出:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">    <span class="number">5</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">1</span>   <span class="number">4</span></span><br><span class="line">     / \</span><br><span class="line">    <span class="number">3</span>   <span class="number">6</span></span><br><span class="line">输出: <span class="literal">false</span></span><br><span class="line">解释: 输入为: [<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">3</span>,<span class="number">6</span>]。</span><br><span class="line">     根节点的值为 <span class="number">5</span> ，但是其右子节点值为 <span class="number">4</span> 。</span><br></pre></td></tr></table></figure><h3 id="解题思路-amp-题解"><a href="#解题思路-amp-题解" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>因为是一颗二叉搜索树，因此每个节点都满足左边小、右边大这个特性。<br>因此每次判断的时候记录<strong>最小值</strong>和<strong>最大值</strong>，然后判断即可。解题思路如下：</p><ol><li>由题目得知是整型，因此最大最小值分别为最小、最大的整型数值</li><li>当前节点值和最大最小值比较，错误则返回<code>F</code></li><li>将当前节点的值作为最大、最小值传入左右子树</li><li>返回左右子树的判断结果</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValidBST</span><span class="params">(root *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> validBST(root, math.MinInt64, math.MaxInt64)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">validBST</span><span class="params">(root *TreeNode, min, max <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> root.Val &lt;= min || root.Val &gt;= max &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> validBST(root.Left, min, root.Val) &amp;&amp; validBST(root.Right, root.Val, max)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="两数之和-IV-输入-BST"><a href="#两数之和-IV-输入-BST" class="headerlink" title="两数之和 IV - 输入 BST"></a>两数之和 IV - 输入 BST</h2><blockquote><p>给定一个二叉搜索树 root 和一个目标结果 k，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。</p></blockquote><p>示例 1：<br><img src="https://assets.leetcode.com/uploads/2020/09/21/sum_tree_1.jpg" alt=""></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="number">7</span>], k = <span class="number">9</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>示例 2：<br><img src="https://assets.leetcode.com/uploads/2020/09/21/sum_tree_2.jpg" alt=""></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="number">7</span>], k = <span class="number">28</span></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>], k = <span class="number">4</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>示例 4：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>], k = <span class="number">1</span></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>示例 5：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>], k = <span class="number">3</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>提示:</p><ul><li>二叉树的节点个数的范围是  <code>[1, 104]</code>.</li><li><code>-104 &lt;= Node.val &lt;= 104</code></li><li><code>root</code> 为二叉搜索树</li><li><code>-105 &lt;= k &lt;= 105</code></li></ul><h3 id="解题思路-amp-题解-1"><a href="#解题思路-amp-题解-1" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>这题的解题思路大致和<code>求两数和</code>差不多，只是将for循环换成了递归遍历，然后利用<code>hashMap</code>存储已遍历的内容。    </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findTarget</span><span class="params">(root *TreeNode, k <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">hashMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>, <span class="number">100</span>*<span class="number">100</span>)</span><br><span class="line"><span class="keyword">return</span> preOrder(root, hashMap, k)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preOrder</span><span class="params">(root *TreeNode, hashMap <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>, k <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> _, ok := hashMap[k-root.Val]; ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">hashMap[root.Val] = <span class="literal">true</span></span><br><span class="line"><span class="keyword">return</span> preOrder(root.Left, hashMap, k) || preOrder(root.Right, hashMap, k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a>二叉搜索树的最近公共祖先</h2><blockquote><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p></blockquote><blockquote><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p></blockquote><p>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png" alt=""></p><p>示例 1:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [<span class="number">6</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">3</span>,<span class="number">5</span>], p = <span class="number">2</span>, q = <span class="number">8</span></span><br><span class="line">输出: <span class="number">6</span> </span><br><span class="line">解释: 节点 <span class="number">2</span> 和节点 <span class="number">8</span> 的最近公共祖先是 <span class="number">6</span>。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [<span class="number">6</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">3</span>,<span class="number">5</span>], p = <span class="number">2</span>, q = <span class="number">4</span></span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">解释: 节点 <span class="number">2</span> 和节点 <span class="number">4</span> 的最近公共祖先是 <span class="number">2</span>, 因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure><p>说明:</p><ul><li>所有节点的值都是唯一的。</li><li><code>p、q</code> 为不同节点且均存在于给定的二叉搜索树中。</li></ul><h3 id="解题思路-amp-题解-2"><a href="#解题思路-amp-题解-2" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>解题思路：</p><ol><li>当前节点和<code>p、q</code>节点进行比较</li><li>如果是<code>p、q</code>节点、则返回该节点</li><li>获取左右子树的节点，当左右节点都存在，则证明当前节点为最近的<code>祖先节点</code></li><li>如果只有单一一个节点，则继续将该节点返回</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lowestCommonAncestor</span><span class="params">(root, p, q *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> root == p || root == q &#123;</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> leftNode, rightNode *TreeNode</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> p.Val &gt; q.Val &#123;</span><br><span class="line"><span class="comment">// 左 大于 右 则交换。保证左边小于右边（p &lt; q)</span></span><br><span class="line">p, q = q, p</span><br><span class="line">&#125;</span><br><span class="line">leftNode = lowestCommonAncestor(root.Left, p, q)</span><br><span class="line">rightNode = lowestCommonAncestor(root.Right, p, q)</span><br><span class="line"><span class="keyword">if</span> leftNode != <span class="literal">nil</span> &amp;&amp; rightNode != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> leftNode != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> leftNode</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> rightNode != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> rightNode</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;终于刷完了，芜湖！🛫🛫🛫&lt;br&gt;这套题目集总体难度不高，适合刚学的时候作为随堂练习。&lt;br&gt;题目代码我也同步到&lt;code&gt;GitHub&lt;/code&gt;仓库了🎈：&lt;a href=&quot;https://github.com/Farmer-chong/LearnProcess/tree/master/Leetcode/leetcode-dataStruct-1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/Farmer-chong/LearnProcess/tree/master/Leetcode/leetcode-dataStruct-1&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="学了些什么" scheme="https://blog.farmer233.top/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="Golang" scheme="https://blog.farmer233.top/tags/Golang/"/>
    
    <category term="笔记" scheme="https://blog.farmer233.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="算法和数据结构" scheme="https://blog.farmer233.top/tags/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="leetcode" scheme="https://blog.farmer233.top/tags/leetcode/"/>
    
    <category term="刷题" scheme="https://blog.farmer233.top/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>[Leetcode]二叉搜索树中的搜索&amp;插入</title>
    <link href="https://blog.farmer233.top/2021/08/02/Leetcode-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2-%E6%8F%92%E5%85%A5/"/>
    <id>https://blog.farmer233.top/2021/08/02/Leetcode-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2-%E6%8F%92%E5%85%A5/</id>
    <published>2021-08-02T10:35:07.000Z</published>
    <updated>2021-08-02T12:51:34.298Z</updated>
    
    <content type="html"><![CDATA[<p>第十三天了！快刷完了~！😊🛫<br>题目开始涉及二叉树、二叉堆等难一点的操作了，还有二叉树的调整。<br>做完感觉知识点掌握的更扎实了，果然温故而知新啊！</p><a id="more"></a><h2 id="二叉搜索树中的搜索"><a href="#二叉搜索树中的搜索" class="headerlink" title="二叉搜索树中的搜索"></a>二叉搜索树中的搜索</h2><blockquote><p>给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p></blockquote><p>例如，</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">给定二叉搜索树:</span><br><span class="line"></span><br><span class="line">        <span class="number">4</span></span><br><span class="line">       / \</span><br><span class="line">      <span class="number">2</span>   <span class="number">7</span></span><br><span class="line">     / \</span><br><span class="line">    <span class="number">1</span>   <span class="number">3</span></span><br><span class="line"></span><br><span class="line">和值: <span class="number">2</span></span><br><span class="line">你应该返回如下子树:</span><br><span class="line"></span><br><span class="line">      <span class="number">2</span>     </span><br><span class="line">     / \   </span><br><span class="line">    <span class="number">1</span>   <span class="number">3</span></span><br></pre></td></tr></table></figure><p>在上述示例中，如果要找的值是<code>5</code>，但因为没有节点值为 <code>5</code>，我们应该返回 <code>NULL</code>.</p><h3 id="解题思路-amp-题解"><a href="#解题思路-amp-题解" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>因为这是一颗搜索树，因此搜索功能实现起来特别简单，思路如下：</p><ol><li>判断当前节点的值，相同则返回</li><li>判断当前节点的值与目标的值，根据大小选择左子树还是右子树</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchBST</span><span class="params">(root *TreeNode, val <span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> || root.Val == val &#123;</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> root.Val &gt; val &#123;</span><br><span class="line"><span class="keyword">return</span> searchBST(root.Left, val)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> root.Val &lt; val &#123;</span><br><span class="line"><span class="keyword">return</span> searchBST(root.Right, val)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉搜索树中的插入操作"><a href="#二叉搜索树中的插入操作" class="headerlink" title="二叉搜索树中的插入操作"></a>二叉搜索树中的插入操作</h2><blockquote><p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。</p></blockquote><p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。</p><p>示例 1：<br><img src="https://assets.leetcode.com/uploads/2020/10/05/insertbst.jpg" alt=""></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>], val = <span class="number">5</span></span><br><span class="line">输出：[<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">解释：另一个满足题目要求可以通过的树是：</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2020/10/05/bst.jpg" alt=""></p><p>示例 2：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">40</span>,<span class="number">20</span>,<span class="number">60</span>,<span class="number">10</span>,<span class="number">30</span>,<span class="number">50</span>,<span class="number">70</span>], val = <span class="number">25</span></span><br><span class="line">输出：[<span class="number">40</span>,<span class="number">20</span>,<span class="number">60</span>,<span class="number">10</span>,<span class="number">30</span>,<span class="number">50</span>,<span class="number">70</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">25</span>]</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>], val = <span class="number">5</span></span><br><span class="line">输出：[<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>给定的树上的节点数介于 <code>0</code> 和 <code>10^4</code> 之间</li><li>每个节点都有一个唯一整数值，取值范围从 <code>0</code> 到 <code>10^8</code></li><li><code>-10^8 &lt;= val &lt;= 10^8</code></li><li>新值和原始二叉搜索树中的任意节点值都不同</li></ul><h3 id="解题思路-amp-题解-1"><a href="#解题思路-amp-题解-1" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>这题感觉有点漏洞，因为这题是往一颗<strong>搜索二叉树</strong>里面插入<strong>一个</strong>数据，因此不会造成二叉树层数超标。<br>故思路如下：</p><ol><li>用搜索的思路，查找出插入位置</li><li>往目标位置插入</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertIntoBST</span><span class="params">(root *TreeNode, val <span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;TreeNode&#123;Val: val&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> root.Val &lt; val &#123;</span><br><span class="line">root.Right = insertIntoBST(root.Right, val)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">root.Left = insertIntoBST(root.Left, val)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;第十三天了！快刷完了~！😊🛫&lt;br&gt;题目开始涉及二叉树、二叉堆等难一点的操作了，还有二叉树的调整。&lt;br&gt;做完感觉知识点掌握的更扎实了，果然温故而知新啊！&lt;/p&gt;</summary>
    
    
    
    <category term="学了些什么" scheme="https://blog.farmer233.top/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="Golang" scheme="https://blog.farmer233.top/tags/Golang/"/>
    
    <category term="笔记" scheme="https://blog.farmer233.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="算法和数据结构" scheme="https://blog.farmer233.top/tags/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="leetcode" scheme="https://blog.farmer233.top/tags/leetcode/"/>
    
    <category term="刷题" scheme="https://blog.farmer233.top/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>[Leetcode]翻转二叉树&amp;路径总和</title>
    <link href="https://blog.farmer233.top/2021/08/01/Leetcode-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/"/>
    <id>https://blog.farmer233.top/2021/08/01/Leetcode-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/</id>
    <published>2021-08-01T13:42:03.000Z</published>
    <updated>2021-08-02T10:37:27.418Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h2><blockquote><p>翻转一棵二叉树。</p></blockquote><p>示例：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">     <span class="number">4</span></span><br><span class="line">   /   \</span><br><span class="line">  <span class="number">2</span>     <span class="number">7</span></span><br><span class="line"> / \   / \</span><br><span class="line"><span class="number">1</span>   <span class="number">3</span> <span class="number">6</span>   <span class="number">9</span></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">     <span class="number">4</span></span><br><span class="line">   /   \</span><br><span class="line">  <span class="number">7</span>     <span class="number">2</span></span><br><span class="line"> / \   / \</span><br><span class="line"><span class="number">9</span>   <span class="number">6</span> <span class="number">3</span>   <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="解题思路-amp-题解"><a href="#解题思路-amp-题解" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>利用递归，将左子树和右子树交换。代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">invertTree</span><span class="params">(root *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">left := invertTree(root.Right)</span><br><span class="line">root.Right = invertTree(root.Left)</span><br><span class="line">root.Left = left</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a>路径总和</h2><blockquote><p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。<br>叶子节点 是指没有子节点的节点。</p></blockquote><p>示例 1：<br><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg" alt=""></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="literal">null</span>,<span class="number">13</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">1</span>], targetSum = <span class="number">22</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>示例 2：<br><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg" alt=""></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], targetSum = <span class="number">5</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>], targetSum = <span class="number">0</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点的数目在范围 <code>[0, 5000]</code> 内</li><li><code>-1000</code> &lt;= Node.val &lt;= <code>1000</code></li><li><code>-1000</code> &lt;= targetSum &lt;= <code>1000</code></li></ul><h3 id="解题思路-amp-题解-1"><a href="#解题思路-amp-题解-1" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>这题和之前的<code>求两数和</code>差不多思路，将已遍历的节点值放入<code>haspMap</code>中，并且每次访问节点的时候，计算当前节点和目标数相减后的值是否存在<code>hashMap</code>中。<br><strong>具体思路如下</strong></p><ol><li>读取当前节点的值</li><li>将<code>当前节点的值</code>放入<code>hashMap</code>中</li><li>判断 <code>targetSum - 当前节点的值</code> 是否在<code>hashMap</code>中</li><li>在则返回<code>true</code>,不在则继续遍历</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasPathSum</span><span class="params">(root *TreeNode, targetSum <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> root.Left == <span class="literal">nil</span> &amp;&amp; root.Right == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> targetSum == root.Val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> hasPathSum(root.Left, targetSum-root.Val) || hasPathSum(root.Right, targetSum-root.Val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h2 id=&quot;翻转二叉树&quot;&gt;&lt;a href=&quot;#翻转二叉树&quot; class=&quot;headerlink&quot; title=&quot;翻转二叉树&quot;&gt;&lt;/a&gt;翻转二叉树&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;翻转一棵二叉树。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
      
    
    
    
    <category term="学了些什么" scheme="https://blog.farmer233.top/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="Golang" scheme="https://blog.farmer233.top/tags/Golang/"/>
    
    <category term="笔记" scheme="https://blog.farmer233.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="算法和数据结构" scheme="https://blog.farmer233.top/tags/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="leetcode" scheme="https://blog.farmer233.top/tags/leetcode/"/>
    
    <category term="刷题" scheme="https://blog.farmer233.top/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>[Leetcode]第十一天-树的更多操作</title>
    <link href="https://blog.farmer233.top/2021/08/01/Leetcode-%E7%AC%AC%E5%8D%81%E4%B8%80%E5%A4%A9-%E6%A0%91%E7%9A%84%E6%9B%B4%E5%A4%9A%E6%93%8D%E4%BD%9C/"/>
    <id>https://blog.farmer233.top/2021/08/01/Leetcode-%E7%AC%AC%E5%8D%81%E4%B8%80%E5%A4%A9-%E6%A0%91%E7%9A%84%E6%9B%B4%E5%A4%9A%E6%93%8D%E4%BD%9C/</id>
    <published>2021-08-01T13:21:23.000Z</published>
    <updated>2021-08-01T13:52:14.928Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="二叉树的层序遍"><a href="#二叉树的层序遍" class="headerlink" title="二叉树的层序遍"></a>二叉树的层序遍</h2><h3 id="解题思路-amp-题解"><a href="#解题思路-amp-题解" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrder</span><span class="params">(root *TreeNode)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">ret := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line">q := []*TreeNode&#123;root&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; <span class="built_in">len</span>(q) &gt; <span class="number">0</span>; i++ &#123;</span><br><span class="line">ret = <span class="built_in">append</span>(ret, []<span class="keyword">int</span>&#123;&#125;)</span><br><span class="line">p := []*TreeNode&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(q); j++ &#123;</span><br><span class="line">node := q[j]</span><br><span class="line">ret[i] = <span class="built_in">append</span>(ret[i], node.Val)</span><br><span class="line"><span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">p = <span class="built_in">append</span>(p, node.Left)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">p = <span class="built_in">append</span>(p, node.Right)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">q = p</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Queue []*TreeNode</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span> <span class="title">Add</span><span class="params">(data *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">*q = <span class="built_in">append</span>(*q, data)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span> <span class="title">Remove</span><span class="params">()</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">node := (*q)[<span class="number">0</span>]</span><br><span class="line">*q = (*q)[<span class="number">1</span>:]</span><br><span class="line"><span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(*q) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h2><blockquote><p>给定一个二叉树，找出其最大深度。<br>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。<br>说明: 叶子节点是指没有子节点的节点。</p></blockquote><p>示例：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定二叉树 [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">15</span>,<span class="number">7</span>]，</span><br><span class="line">    <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">9</span>  <span class="number">20</span></span><br><span class="line">    /  \</span><br><span class="line">   <span class="number">15</span>   <span class="number">7</span></span><br><span class="line">返回它的最大深度 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><h3 id="解题思路-amp-题解-1"><a href="#解题思路-amp-题解-1" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>简单的通过递归，在返回的时候判断左子树深还是右子树深，然后返回比较深的那颗子树的值。<br>代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxDepth</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">leftDeep := maxDepth(root.Left) + <span class="number">1</span></span><br><span class="line">rightDeep := maxDepth(root.Right) + <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> leftDeep &gt;= rightDeep &#123;</span><br><span class="line"><span class="keyword">return</span> leftDeep</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> rightDeep</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h2><h3 id="解题思路-amp-题解-2"><a href="#解题思路-amp-题解-2" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>和判断深度差不多，也是分为左子树和右子树。通过交叉传入左右子树判断节点的值是否相等。<br>代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSymmetric</span><span class="params">(root *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> check(root, root)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(p, q *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> p == <span class="literal">nil</span> &amp;&amp; q == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> p == <span class="literal">nil</span> || q == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p.Val == q.Val &amp;&amp; check(p.Left, q.Right) &amp;&amp; check(p.Right, q.Left)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h2 id=&quot;二叉树的层序遍&quot;&gt;&lt;a href=&quot;#二叉树的层序遍&quot; class=&quot;headerlink&quot; title=&quot;二叉树的层序遍&quot;&gt;&lt;/a&gt;二叉树的层序遍&lt;/h2&gt;&lt;h3 id=&quot;解题思路-amp-题解&quot;&gt;&lt;a href=&quot;#解题思</summary>
      
    
    
    
    <category term="学了些什么" scheme="https://blog.farmer233.top/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="Golang" scheme="https://blog.farmer233.top/tags/Golang/"/>
    
    <category term="笔记" scheme="https://blog.farmer233.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="算法和数据结构" scheme="https://blog.farmer233.top/tags/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="leetcode" scheme="https://blog.farmer233.top/tags/leetcode/"/>
    
    <category term="刷题" scheme="https://blog.farmer233.top/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>[Leetcode]题目集第十天-树的开始</title>
    <link href="https://blog.farmer233.top/2021/07/31/Leetcode-%E9%A2%98%E7%9B%AE%E9%9B%86%E7%AC%AC%E5%8D%81%E5%A4%A9-%E6%A0%91%E7%9A%84%E5%BC%80%E5%A7%8B/"/>
    <id>https://blog.farmer233.top/2021/07/31/Leetcode-%E9%A2%98%E7%9B%AE%E9%9B%86%E7%AC%AC%E5%8D%81%E5%A4%A9-%E6%A0%91%E7%9A%84%E5%BC%80%E5%A7%8B/</id>
    <published>2021-07-31T13:15:34.000Z</published>
    <updated>2021-08-01T13:29:24.129Z</updated>
    
    <content type="html"><![CDATA[<p>树是一种重要的数据结构，终于开始刷树了😊<br>今天刷的是二叉树的三种基本变量–二叉树的前序遍历、二叉树的中序遍历和二叉树的后序遍历。三种遍历大同小异，只是输出元素的位置不一样，就不过多赘述了。</p><h2 id="三种遍历"><a href="#三种遍历" class="headerlink" title="三种遍历"></a>三种遍历</h2><p>代码和leetcode上的不太一样，但稍微改动一下就能提交了。代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> nodeType <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">value       nodeType</span><br><span class="line">left, right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BinaryTree proOrder function</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *TreeNode)</span> <span class="title">preOrder</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> t == <span class="literal">nil</span> || t.value == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(t.value)</span><br><span class="line">t.left.preOrder()</span><br><span class="line">t.right.preOrder()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// binaryTree inOrder function</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *TreeNode)</span> <span class="title">inOrder</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> t == <span class="literal">nil</span> || t.value == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">t.left.inOrder()</span><br><span class="line">fmt.Println(t.value)</span><br><span class="line">t.right.inOrder()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BinaryTree postOrder function</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *TreeNode)</span> <span class="title">postOrder</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> t == <span class="literal">nil</span> || t.value == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">t.left.postOrder()</span><br><span class="line">t.right.postOrder()</span><br><span class="line">fmt.Println(t.value)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newTree</span><span class="params">(inputList *[]nodeType)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(*inputList) == <span class="number">0</span> || inputList == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data := (*inputList)[<span class="number">0</span>]</span><br><span class="line">*inputList = (*inputList)[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> data == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node := &amp;TreeNode&#123;data, <span class="literal">nil</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">node.left = newTree(inputList)</span><br><span class="line">node.right = newTree(inputList)</span><br><span class="line"><span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">inputList := []nodeType&#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="number">10</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="number">8</span>, <span class="literal">nil</span>, <span class="number">4</span>&#125;</span><br><span class="line">root := newTree(&amp;inputList)</span><br><span class="line">fmt.Println(<span class="string">"res"</span>, root.left.right.value)</span><br><span class="line">fmt.Println(<span class="string">"前序遍历"</span>)</span><br><span class="line">root.preOrder()</span><br><span class="line">fmt.Println(<span class="string">"中序遍历"</span>)</span><br><span class="line">root.inOrder()</span><br><span class="line">fmt.Println(<span class="string">"后续遍历"</span>)</span><br><span class="line">root.postOrder()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;树是一种重要的数据结构，终于开始刷树了😊&lt;br&gt;今天刷的是二叉树的三种基本变量–二叉树的前序遍历、二叉树的中序遍历和二叉树的后序遍历。三种遍历大同小异，只是输出元素的位置不一样，就不过多赘述了。&lt;/p&gt;
&lt;h2 id=&quot;三种遍历&quot;&gt;&lt;a href=&quot;#三种遍历&quot; clas</summary>
      
    
    
    
    <category term="学了些什么" scheme="https://blog.farmer233.top/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="Golang" scheme="https://blog.farmer233.top/tags/Golang/"/>
    
    <category term="笔记" scheme="https://blog.farmer233.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="算法和数据结构" scheme="https://blog.farmer233.top/tags/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="leetcode" scheme="https://blog.farmer233.top/tags/leetcode/"/>
    
    <category term="刷题" scheme="https://blog.farmer233.top/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>[Leetcode]有效的括号&amp;用栈实现队列</title>
    <link href="https://blog.farmer233.top/2021/07/31/Leetcode-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>https://blog.farmer233.top/2021/07/31/Leetcode-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</id>
    <published>2021-07-30T17:11:02.000Z</published>
    <updated>2021-07-31T13:16:13.268Z</updated>
    
    <content type="html"><![CDATA[<h2 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h2><blockquote><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p></blockquote><p><strong>有效字符串需满足：</strong></p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ol><p>示例 1：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"()"</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"()[]&#123;&#125;"</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"(]"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>示例 4：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"([)]"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>示例 5：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"&#123;[]&#125;"</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="解题思路-amp-题解"><a href="#解题思路-amp-题解" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>这道题和课堂例题没啥区别没啥好讲的，直接上代码：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValid</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s)%<span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">pars := []<span class="keyword">rune</span>&#123;</span><br><span class="line"><span class="string">'('</span>: <span class="string">')'</span>,</span><br><span class="line"><span class="string">'&#123;'</span>: <span class="string">'&#125;'</span>,</span><br><span class="line"><span class="string">'['</span>: <span class="string">']'</span>,</span><br><span class="line">&#125;</span><br><span class="line">stack := []<span class="keyword">rune</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> _, c := <span class="keyword">range</span> s &#123;</span><br><span class="line"><span class="keyword">if</span> c == <span class="string">'('</span> || c == <span class="string">'&#123;'</span> || c == <span class="string">'['</span> &#123;</span><br><span class="line">stack = <span class="built_in">append</span>(stack, c)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">jugeCh := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">if</span> c != pars[jugeCh] &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(stack) != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h2><blockquote><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：</p></blockquote><p>实现 <code>MyQueue</code> 类：</p><ul><li>void push(int x) 将元素 x 推到队列的末尾</li><li>int pop() 从队列的开头移除并返回元素</li><li>int peek() 返回队列开头的元素</li><li>boolean empty() 如果队列为空，返回 true ；否则，返回 false</li></ul><p><strong>说明：</strong><br>你只能使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。<br>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</p><p><strong>进阶：</strong><br>你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。</p><p>示例：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">"MyQueue"</span>, <span class="string">"push"</span>, <span class="string">"push"</span>, <span class="string">"peek"</span>, <span class="string">"pop"</span>, <span class="string">"empty"</span>]</span><br><span class="line">[[], [<span class="number">1</span>], [<span class="number">2</span>], [], [], []]</span><br><span class="line">输出：</span><br><span class="line">[<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="keyword">false</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MyQueue myQueue = <span class="keyword">new</span> MyQueue();</span><br><span class="line">myQueue.<span class="keyword">push</span>(<span class="number">1</span>); <span class="comment">// queue is: [1]</span></span><br><span class="line">myQueue.<span class="keyword">push</span>(<span class="number">2</span>); <span class="comment">// queue is: [1, 2] (leftmost is front of the queue)</span></span><br><span class="line">myQueue.peek(); <span class="comment">// return 1</span></span><br><span class="line">myQueue.<span class="keyword">pop</span>(); <span class="comment">// return 1, queue is [2]</span></span><br><span class="line">myQueue.empty(); <span class="comment">// return false</span></span><br></pre></td></tr></table></figure><h3 id="解题思路-amp-题解-1"><a href="#解题思路-amp-题解-1" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>这里利用了两个栈，一个栈处理输入另一个处理输出（in和out）。<br>利用栈的特性，当<strong>输出栈</strong>为空时将<strong>输入栈</strong>的内容<code>pop</code>到<strong>输出栈</strong>, 这样<strong>输出</strong>栈的顺序就是队列的顺序了！<br>代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyQueue <span class="keyword">struct</span> &#123;</span><br><span class="line">in, out []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">MyQueue</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> MyQueue&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyQueue)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">this.in = <span class="built_in">append</span>(this.in, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyQueue)</span> <span class="title">in2out</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(this.in) &gt; <span class="number">0</span> &#123;</span><br><span class="line">this.out = <span class="built_in">append</span>(this.out, this.in[<span class="built_in">len</span>(this.in)<span class="number">-1</span>])</span><br><span class="line">this.in = this.in[:<span class="built_in">len</span>(this.in)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyQueue)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(this.out) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 将输入栈 弹出到输出栈中</span></span><br><span class="line">this.in2out()</span><br><span class="line">&#125;</span><br><span class="line">out := this.out[<span class="built_in">len</span>(this.out)<span class="number">-1</span>]</span><br><span class="line">this.out = this.out[:<span class="built_in">len</span>(this.out)<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Get the front element. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyQueue)</span> <span class="title">Peek</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(this.out) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 将输入栈 弹出到输出栈中</span></span><br><span class="line">this.in2out()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> this.out[<span class="built_in">len</span>(this.out)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyQueue)</span> <span class="title">Empty</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(this.in) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(this.out) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * obj.Push(x);</span></span><br><span class="line"><span class="comment"> * param_2 := obj.Pop();</span></span><br><span class="line"><span class="comment"> * param_3 := obj.Peek();</span></span><br><span class="line"><span class="comment"> * param_4 := obj.Empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;有效的括号&quot;&gt;&lt;a href=&quot;#有效的括号&quot; class=&quot;headerlink&quot; title=&quot;有效的括号&quot;&gt;&lt;/a&gt;有效的括号&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串</summary>
      
    
    
    
    <category term="学了些什么" scheme="https://blog.farmer233.top/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="Golang" scheme="https://blog.farmer233.top/tags/Golang/"/>
    
    <category term="笔记" scheme="https://blog.farmer233.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="算法和数据结构" scheme="https://blog.farmer233.top/tags/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="leetcode" scheme="https://blog.farmer233.top/tags/leetcode/"/>
    
    <category term="刷题" scheme="https://blog.farmer233.top/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>[Leetcode]反转链表&amp;删除排序链表中的重复元素</title>
    <link href="https://blog.farmer233.top/2021/07/23/Leetcode-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
    <id>https://blog.farmer233.top/2021/07/23/Leetcode-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</id>
    <published>2021-07-22T16:30:03.000Z</published>
    <updated>2021-07-29T17:01:46.716Z</updated>
    
    <content type="html"><![CDATA[<p>第八天题目，涉及的都是些基本的链表操作~不算太难😀<br>去旅游玩几天👻🕊🕊🕊</p><a id="more"></a><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><blockquote><p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p></blockquote><p>示例 1：<br><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt=""></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：[<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>示例 2：<br><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" alt=""></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="comment">[]</span></span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></table></figure><h3 id="解题思路-amp-题解"><a href="#解题思路-amp-题解" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>这题第一时间想到了递归，当操作流程在<strong>递归</strong>触底前则表示正向递归，触底后计算则表示反向递归。<br>这里利用了<strong>反向递归</strong>（触底后操作），得到一个链表尾开头的链表和当前节点，然后将这条链添加当前元素。<br>此时，node节点表示反转后的链表。<br>代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br><span class="line">node := reverseList(head.Next)</span><br><span class="line">head.Next.Next = head</span><br><span class="line">head.Next = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除排序链表中的重复元素"><a href="#删除排序链表中的重复元素" class="headerlink" title="删除排序链表中的重复元素"></a>删除排序链表中的重复元素</h2><blockquote><p>存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除所有重复的元素，使每个元素 只出现一次 。<br>返回同样按升序排列的结果链表。</p></blockquote><p>示例 1：<br><img src="https://assets.leetcode.com/uploads/2021/01/04/list1.jpg" alt=""></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>示例 2：<br><img src="https://assets.leetcode.com/uploads/2021/01/04/list2.jpg" alt=""></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><h3 id="解题思路-amp-题解-1"><a href="#解题思路-amp-题解-1" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>这题有个大前提<code>按升序排列的链表</code>, 这个链表是排好序的。通过判断当前节点和下一个节点的值是否想等，相等就删除下一个节点。<br>代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteDuplicates</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">node := head</span><br><span class="line"><span class="keyword">for</span> node.Next != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> node.Val == node.Next.Val &#123;</span><br><span class="line">node.Next = node.Next.Next</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">node = node.Next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;第八天题目，涉及的都是些基本的链表操作~不算太难😀&lt;br&gt;去旅游玩几天👻🕊🕊🕊&lt;/p&gt;</summary>
    
    
    
    <category term="学了些什么" scheme="https://blog.farmer233.top/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="Golang" scheme="https://blog.farmer233.top/tags/Golang/"/>
    
    <category term="笔记" scheme="https://blog.farmer233.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="算法和数据结构" scheme="https://blog.farmer233.top/tags/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="leetcode" scheme="https://blog.farmer233.top/tags/leetcode/"/>
    
    <category term="刷题" scheme="https://blog.farmer233.top/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>[Leetcode]数据结构题目集第七天-链表</title>
    <link href="https://blog.farmer233.top/2021/07/22/Leetcode-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E7%9B%AE%E9%9B%86%E7%AC%AC%E4%B8%83%E5%A4%A9-%E9%93%BE%E8%A1%A8/"/>
    <id>https://blog.farmer233.top/2021/07/22/Leetcode-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E7%9B%AE%E9%9B%86%E7%AC%AC%E4%B8%83%E5%A4%A9-%E9%93%BE%E8%A1%A8/</id>
    <published>2021-07-21T17:04:04.000Z</published>
    <updated>2021-07-22T16:30:27.652Z</updated>
    
    <content type="html"><![CDATA[<p>这次题目有三题，分别是<code>环形链表</code>、<code>合并两个有序链表</code>和<code>移除链表元素</code>.<br>其中<code>环形链表</code>比较值得一看，解法有三种，感觉第一种有点骚✨</p><a id="more"></a><h2 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h2><blockquote><p>给定一个链表，判断链表中是否有环。<br>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：pos 不作为参数进行传递，</strong>仅仅是为了标识链表的实际情况。<br>如果链表中存在环，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p></blockquote><p><strong>进阶：</strong><br>你能用 O(1)（即，常量）内存解决此问题吗？</p><p>示例 1：<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt=""></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">-4</span>], pos = <span class="number">1</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p>示例 2：<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt=""></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>], pos = <span class="number">0</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p>示例 3：<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt=""></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>], pos = <span class="number">-1</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围是 [0, 104]</li><li>-105 &lt;= Node.val &lt;= 105</li><li>pos 为 -1 或者链表中的一个 有效索引 。</li></ul><h3 id="解题思路-amp-题解"><a href="#解题思路-amp-题解" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>这题有好几个方法解决，如下：</p><ol><li>利用一个特殊的值覆盖已遍历的元素，当再次遇到该值时表示有回环</li><li>利用哈希表存储记录节点地址</li><li>快慢指针法（传统法） </li></ol><h4 id="特殊值法"><a href="#特殊值法" class="headerlink" title="特殊值法"></a>特殊值法</h4><p>这个方法感觉有点奇葩，特殊值要测试点中不存在才可以😄</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasCycle</span><span class="params">(head *ListNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> head.Val == <span class="number">114514</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head.Val = <span class="number">114514</span></span><br><span class="line">        &#125;</span><br><span class="line">        head = head.Next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="哈希表存储节点"><a href="#哈希表存储节点" class="headerlink" title="哈希表存储节点"></a>哈希表存储节点</h4><p>这个方法只需要将链表遍历一次，但需要耗费更大的内存空间。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasCycle</span><span class="params">(head *ListNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">nodeMap := <span class="keyword">map</span>[ListNode]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">node := head</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">nodeMap[*node]++</span><br><span class="line"><span class="keyword">if</span> nodeMap[*node] &gt; <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">node = node.Next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="快慢指针法"><a href="#快慢指针法" class="headerlink" title="快慢指针法"></a>快慢指针法</h4><p>这个是传统的方法，但有可能需要遍历几次闭环，等慢指针追上快指针。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasCycle</span><span class="params">(head *ListNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    slow, fast := head, head.Next</span><br><span class="line">    <span class="keyword">for</span> fast != slow &#123;</span><br><span class="line">        <span class="keyword">if</span> fast == <span class="literal">nil</span> || fast.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow.Next</span><br><span class="line">        fast = fast.Next.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h2><blockquote><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p></blockquote><p>示例 1：<br><img src="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg" alt=""></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>], l2 = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = <span class="comment">[]</span>, l2 = <span class="comment">[]</span></span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = <span class="comment">[]</span>, l2 = <span class="comment">[0]</span></span><br><span class="line">输出：<span class="comment">[0]</span></span><br></pre></td></tr></table></figure><h3 id="解题思路-amp-题解-1"><a href="#解题思路-amp-题解-1" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p><strong>需要注意</strong>这题有一个大前提，题目给的两个链表都是<strong>升序</strong>的，因此这题类似前面的<code>合并两个有序数组</code>有点类似。</p><ol><li>通过比较头节点，小的添加到新链</li><li>遍历完其中一条链后，将另一条链直接拼接在后面<br>代码如下：<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTwoLists</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">res := &amp;ListNode&#123;&#125;</span><br><span class="line">node := res</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> l1 == <span class="literal">nil</span> &#123;</span><br><span class="line">node.Next = l2</span><br><span class="line"><span class="keyword">return</span> res.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> l2 == <span class="literal">nil</span> &#123;</span><br><span class="line">node.Next = l1</span><br><span class="line"><span class="keyword">return</span> res.Next</span><br><span class="line">&#125;</span><br><span class="line">tmp := &amp;ListNode&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> l1.Val &lt;= l2.Val &#123;</span><br><span class="line">tmp.Val = l1.Val</span><br><span class="line">l1 = l1.Next</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">tmp.Val = l2.Val</span><br><span class="line">l2 = l2.Next</span><br><span class="line">&#125;</span><br><span class="line">node.Next = tmp</span><br><span class="line">node = node.Next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="移除链表元素"><a href="#移除链表元素" class="headerlink" title="移除链表元素"></a>移除链表元素</h2><blockquote><p>给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。</p></blockquote><p>示例 1：<br><img src="https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg" alt=""></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], val = <span class="number">6</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = <span class="comment">[]</span>, val = 1</span><br><span class="line">输出：<span class="comment">[]</span></span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>], val = <span class="number">7</span></span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><h3 id="解题思路-amp-题解-2"><a href="#解题思路-amp-题解-2" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>这题就是基本的删除链表元素，直接上代码：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeElements</span><span class="params">(head *ListNode, val <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">root := &amp;ListNode&#123;Next: head&#125;</span><br><span class="line">node := root</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> node.Next != <span class="literal">nil</span> &amp;&amp; node.Next.Val == val &#123;</span><br><span class="line">node.Next = node.Next.Next</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">node = node.Next</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;这次题目有三题，分别是&lt;code&gt;环形链表&lt;/code&gt;、&lt;code&gt;合并两个有序链表&lt;/code&gt;和&lt;code&gt;移除链表元素&lt;/code&gt;.&lt;br&gt;其中&lt;code&gt;环形链表&lt;/code&gt;比较值得一看，解法有三种，感觉第一种有点骚✨&lt;/p&gt;</summary>
    
    
    
    <category term="学了些什么" scheme="https://blog.farmer233.top/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="Golang" scheme="https://blog.farmer233.top/tags/Golang/"/>
    
    <category term="笔记" scheme="https://blog.farmer233.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="算法和数据结构" scheme="https://blog.farmer233.top/tags/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="leetcode" scheme="https://blog.farmer233.top/tags/leetcode/"/>
    
    <category term="刷题" scheme="https://blog.farmer233.top/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>[Leetcode]数据结构题目集第六天</title>
    <link href="https://blog.farmer233.top/2021/07/21/Leetcode-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E7%9B%AE%E9%9B%86%E7%AC%AC%E5%85%AD%E5%A4%A9/"/>
    <id>https://blog.farmer233.top/2021/07/21/Leetcode-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E7%9B%AE%E9%9B%86%E7%AC%AC%E5%85%AD%E5%A4%A9/</id>
    <published>2021-07-21T15:56:16.000Z</published>
    <updated>2021-07-21T16:57:44.546Z</updated>
    
    <content type="html"><![CDATA[<p>这次题目有三题，分别是<code>字符串中的第一个唯一字符</code>、<code>赎金信</code>和<code>有效的字母异位词</code>.<br>今天三道题目的思路都差不多，感觉都是<code>两个数组的交集 II</code>的变形,内容篇幅可能比较长，目录可以快速定位到对应题目的解题思路&amp;题解.  </p><h2 id="字符串中的第一个唯一字符"><a href="#字符串中的第一个唯一字符" class="headerlink" title="字符串中的第一个唯一字符"></a>字符串中的第一个唯一字符</h2><blockquote><p>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</p></blockquote><p>示例：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">s</span> = <span class="string">"leetcode"</span></span><br><span class="line">返回 <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">s</span> = <span class="string">"loveleetcode"</span></span><br><span class="line">返回 <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="解题思路-amp-题解"><a href="#解题思路-amp-题解" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>拿到题目的第一反应是和之前<code>两个数组的交集 II</code>一样的思路。<br>通过哈希表记录元素出现的下标，然后扫码字符串找出出现的次数为1的元素，然后返回该元素的下标。<br>大致思路: </p><ol><li>数组0-25表示’a’ -&gt; ‘z’</li><li>哈希表使用一个26长度的数组表示</li><li>数组内容表示元素出现次数</li></ol><p>代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">firstUniqChar</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">items := [<span class="number">26</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">items[s[i]-<span class="string">'a'</span>]++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> items[s[i]-<span class="string">'a'</span>] == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="赎金信"><a href="#赎金信" class="headerlink" title="赎金信"></a>赎金信</h2><blockquote><p>给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。</p></blockquote><p>(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)</p><p>示例 1：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">ransomNote</span> = <span class="string">"a"</span>, <span class="attr">magazine</span> = <span class="string">"b"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">ransomNote</span> = <span class="string">"aa"</span>, <span class="attr">magazine</span> = <span class="string">"ab"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">ransomNote</span> = <span class="string">"aa"</span>, <span class="attr">magazine</span> = <span class="string">"aab"</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="解题思路-amp-题解-1"><a href="#解题思路-amp-题解-1" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>这题与上一题差不多，思路上甚至更像<code>两个数组的交集 II</code>，也是通过一个数组哈希表存储字符出现的次数。<br>第二次遍历的时候将数组内容减一，当内容为0时表示内容不够则返回<code>false</code></p><p>代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canConstruct</span><span class="params">(ransomNote <span class="keyword">string</span>, magazine <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">conMap := [<span class="number">26</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(magazine); i++ &#123;</span><br><span class="line">conMap[magazine[i]-<span class="string">'a'</span>]++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(ransomNote); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> conMap[ransomNote[i]-<span class="string">'a'</span>] == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">conMap[ransomNote[i]-<span class="string">'a'</span>]--</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有效的字母异位词"><a href="#有效的字母异位词" class="headerlink" title="有效的字母异位词"></a>有效的字母异位词</h2><blockquote><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。<br><strong>注意：若 <code>s</code> 和 <code>t</code> 中每个字符出现的次数都相同，则称 <code>s</code> 和 <code>t</code> 互为字母异位词。</strong></p></blockquote><p>示例 1:</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="attr">s</span> = <span class="string">"anagram"</span>, <span class="attr">t</span> = <span class="string">"nagaram"</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="attr">s</span> = <span class="string">"rat"</span>, <span class="attr">t</span> = <span class="string">"car"</span></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="解题思路-amp-题解-2"><a href="#解题思路-amp-题解-2" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>这题应该就是<code>两个数组的交集 II</code>的变形了，今天这三题整体上思路都没啥区别，不过多赘述了。    </p><p>代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isAnagram</span><span class="params">(s <span class="keyword">string</span>, t <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">res := [<span class="number">26</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">res[s[i]-<span class="string">'a'</span>]++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(t); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> res[t[i]-<span class="string">'a'</span>] == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">res[t[i]-<span class="string">'a'</span>]--</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> res &#123;</span><br><span class="line"><span class="keyword">if</span> v != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这次题目有三题，分别是&lt;code&gt;字符串中的第一个唯一字符&lt;/code&gt;、&lt;code&gt;赎金信&lt;/code&gt;和&lt;code&gt;有效的字母异位词&lt;/code&gt;.&lt;br&gt;今天三道题目的思路都差不多，感觉都是&lt;code&gt;两个数组的交集 II&lt;/code&gt;的变形,内容篇幅可能比较长，目录</summary>
      
    
    
    
    <category term="学了些什么" scheme="https://blog.farmer233.top/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="Golang" scheme="https://blog.farmer233.top/tags/Golang/"/>
    
    <category term="笔记" scheme="https://blog.farmer233.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="算法和数据结构" scheme="https://blog.farmer233.top/tags/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="leetcode" scheme="https://blog.farmer233.top/tags/leetcode/"/>
    
    <category term="刷题" scheme="https://blog.farmer233.top/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>[Leetcode]有效的数独&amp;矩阵置零</title>
    <link href="https://blog.farmer233.top/2021/07/20/Leetcode-%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC-%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6/"/>
    <id>https://blog.farmer233.top/2021/07/20/Leetcode-%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC-%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6/</id>
    <published>2021-07-20T14:34:22.000Z</published>
    <updated>2021-07-20T14:53:58.707Z</updated>
    
    <content type="html"><![CDATA[<p>Leetcode数据结构题目集第五天，<code>有效的数独</code>和<code>矩阵置零</code>.<br>其中<code>矩阵置零</code>比较有趣放在前面，<code>有效的数独</code>只是代码量比较长，逻辑部分并不难。  </p><a id="more"></a><h2 id="矩阵置零"><a href="#矩阵置零" class="headerlink" title="矩阵置零"></a>矩阵置零</h2><blockquote><p>给定一个 <code>m x n</code> 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用<code>原地</code>算法。</p></blockquote><p>进阶：</p><ul><li>一个直观的解决方案是使用  O(mn) 的额外空间，但这并不是一个好的解决方案。</li><li>一个简单的改进方案是使用 O(m + n) 的额外空间，但这仍然不是最好的解决方案。<br>你能想出一个仅使用常量空间的解决方案吗？</li></ul><p>示例 1：<br><img src="https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg" alt=""></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]]</span><br></pre></td></tr></table></figure><p>示例 2：<br><img src="https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg" alt=""></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>]]</span><br><span class="line">输出：[[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>]]</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>m == matrix.length</li><li>n == matrix[0].length</li><li>1 &lt;= m, n &lt;= 200</li><li>-231 &lt;= matrix[i][j] &lt;= 231 - 1</li></ul><h3 id="解题思路-amp-题解"><a href="#解题思路-amp-题解" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p><strong>通过观察发现置零是将<code>0</code>的行号和列号记录下来，然后将记录下来的行列置零即可</strong><br>具体思路如下：</p><ul><li>当同一行有一个0时，则该行后面遇到0值时也无需关系这一行的变化-&gt;因为一行里面有一个0，整行都是0（列同理）</li><li>在同一行有两个0时需要注意，这意味着有两列也需要置零。</li></ul><p>代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setZeroes</span><span class="params">(matrix [][]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">row, col := []<span class="keyword">int</span>&#123;&#125;, []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> r := <span class="number">0</span>; r &lt; <span class="built_in">len</span>(matrix); r++ &#123;</span><br><span class="line"><span class="keyword">for</span> c := <span class="number">0</span>; c &lt; <span class="built_in">len</span>(matrix[r]); c++ &#123;</span><br><span class="line"><span class="keyword">if</span> matrix[r][c] == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 记录</span></span><br><span class="line">row = <span class="built_in">append</span>(row, r)</span><br><span class="line">col = <span class="built_in">append</span>(col, c)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> _, item := <span class="keyword">range</span> row &#123;</span><br><span class="line"><span class="keyword">for</span> index := <span class="keyword">range</span> matrix[item] &#123;</span><br><span class="line">matrix[item][index] = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, item := <span class="keyword">range</span> col &#123;</span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> matrix &#123;</span><br><span class="line">value[item] = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有效的数独"><a href="#有效的数独" class="headerlink" title="有效的数独"></a>有效的数独</h2><blockquote><p>请你判断一个 9x9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。<br>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）<br>数独部分空格内已填入了数字，空白格用 ‘.’ 表示。</p></blockquote><p><strong>注意：</strong></p><ul><li>一个有效的数独（部分已被填充）不一定是可解的。</li><li>只需要根据以上规则，验证已经填入的数字是否有效即可。</li></ul><p>示例 1：<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714svg.png" alt=""></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：board = </span><br><span class="line">[[<span class="string">"5"</span>,<span class="string">"3"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"7"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>]</span><br><span class="line">,[<span class="string">"6"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"1"</span>,<span class="string">"9"</span>,<span class="string">"5"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>]</span><br><span class="line">,[<span class="string">"."</span>,<span class="string">"9"</span>,<span class="string">"8"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"6"</span>,<span class="string">"."</span>]</span><br><span class="line">,[<span class="string">"8"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"6"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"3"</span>]</span><br><span class="line">,[<span class="string">"4"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"8"</span>,<span class="string">"."</span>,<span class="string">"3"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"1"</span>]</span><br><span class="line">,[<span class="string">"7"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"2"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"6"</span>]</span><br><span class="line">,[<span class="string">"."</span>,<span class="string">"6"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"2"</span>,<span class="string">"8"</span>,<span class="string">"."</span>]</span><br><span class="line">,[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"4"</span>,<span class="string">"1"</span>,<span class="string">"9"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"5"</span>]</span><br><span class="line">,[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"8"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"7"</span>,<span class="string">"9"</span>]]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：board = </span><br><span class="line">[[<span class="string">"8"</span>,<span class="string">"3"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"7"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>]</span><br><span class="line">,[<span class="string">"6"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"1"</span>,<span class="string">"9"</span>,<span class="string">"5"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>]</span><br><span class="line">,[<span class="string">"."</span>,<span class="string">"9"</span>,<span class="string">"8"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"6"</span>,<span class="string">"."</span>]</span><br><span class="line">,[<span class="string">"8"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"6"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"3"</span>]</span><br><span class="line">,[<span class="string">"4"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"8"</span>,<span class="string">"."</span>,<span class="string">"3"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"1"</span>]</span><br><span class="line">,[<span class="string">"7"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"2"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"6"</span>]</span><br><span class="line">,[<span class="string">"."</span>,<span class="string">"6"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"2"</span>,<span class="string">"8"</span>,<span class="string">"."</span>]</span><br><span class="line">,[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"4"</span>,<span class="string">"1"</span>,<span class="string">"9"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"5"</span>]</span><br><span class="line">,[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"8"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"7"</span>,<span class="string">"9"</span>]]</span><br><span class="line">输出：false</span><br><span class="line">解释：除了第一行的第一个数字从 <span class="number">5</span> 改为 <span class="number">8</span> 以外，空格内其他数字均与 示例<span class="number">1</span> 相同。 但由于位于左上角的 <span class="number">3</span>x3 宫内有两个 <span class="number">8</span> 存在, 因此这个数独是无效的。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>board.length == 9</li><li>board[i].length == 9</li><li>board[i][j] 是一位数字或者 ‘.’</li></ul><h3 id="解题思路-amp-题解-1"><a href="#解题思路-amp-题解-1" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>题目<del>没什么难度</del>，唯一需要注意的是：判断子矩阵的时候，是根据<code>当前坐标/矩阵大小</code>来决定的。<br>代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValidSudoku</span><span class="params">(board [][]<span class="keyword">byte</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">rowBuf := <span class="built_in">make</span>([][<span class="number">9</span>]<span class="keyword">bool</span>, <span class="number">9</span>)</span><br><span class="line">colBuf := <span class="built_in">make</span>([][<span class="number">9</span>]<span class="keyword">bool</span>, <span class="number">9</span>)</span><br><span class="line">boxBuf := <span class="built_in">make</span>([][<span class="number">9</span>]<span class="keyword">bool</span>, <span class="number">9</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> row:=<span class="number">0</span>; row&lt;<span class="number">9</span>; row++ &#123;</span><br><span class="line"><span class="keyword">for</span> col:=<span class="number">0</span>; col&lt;<span class="number">9</span>; col++ &#123;</span><br><span class="line"><span class="keyword">if</span> board[row][col] == <span class="string">'.'</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val := board[row][col] - <span class="string">'1'</span></span><br><span class="line"><span class="keyword">if</span> rowBuf[row][val] || colBuf[col][val] || boxBuf[row/<span class="number">3</span>*<span class="number">3</span>+col/<span class="number">3</span>][val] &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rowBuf[row][val] = <span class="literal">true</span></span><br><span class="line">colBuf[col][val] = <span class="literal">true</span></span><br><span class="line">boxBuf[row/<span class="number">3</span>*<span class="number">3</span>+col/<span class="number">3</span>][val] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">validDigit</span><span class="params">(digit <span class="keyword">byte</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> digit &gt;= <span class="string">'1'</span> &amp;&amp; digit &lt;= <span class="string">'9'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inRow</span><span class="params">(rows []<span class="keyword">byte</span>, col <span class="keyword">int</span>, digit <span class="keyword">byte</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> c := <span class="number">0</span>; c &lt; <span class="number">9</span>; c++ &#123;</span><br><span class="line"><span class="keyword">if</span> rows[c] == digit &amp;&amp; c != col &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inColumn</span><span class="params">(g [][]<span class="keyword">byte</span>, column, row <span class="keyword">int</span>, digit <span class="keyword">byte</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> r := <span class="number">0</span>; r &lt; <span class="number">9</span>; r++ &#123;</span><br><span class="line"><span class="keyword">if</span> g[r][column] == digit &amp;&amp; r != row &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inRegion</span><span class="params">(g [][]<span class="keyword">byte</span>, row, column <span class="keyword">int</span>, digit <span class="keyword">byte</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">startRow, startColumn := row/<span class="number">3</span>*<span class="number">3</span>, column/<span class="number">3</span>*<span class="number">3</span></span><br><span class="line"><span class="keyword">for</span> r := startRow; r &lt; startRow+<span class="number">3</span>; r++ &#123;</span><br><span class="line"><span class="keyword">for</span> c := startColumn; c &lt; startColumn+<span class="number">3</span>; c++ &#123;</span><br><span class="line"><span class="keyword">if</span> g[r][c] == digit &amp;&amp; r != row &amp;&amp; c != column &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Leetcode数据结构题目集第五天，&lt;code&gt;有效的数独&lt;/code&gt;和&lt;code&gt;矩阵置零&lt;/code&gt;.&lt;br&gt;其中&lt;code&gt;矩阵置零&lt;/code&gt;比较有趣放在前面，&lt;code&gt;有效的数独&lt;/code&gt;只是代码量比较长，逻辑部分并不难。  &lt;/p&gt;</summary>
    
    
    
    <category term="学了些什么" scheme="https://blog.farmer233.top/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="Golang" scheme="https://blog.farmer233.top/tags/Golang/"/>
    
    <category term="笔记" scheme="https://blog.farmer233.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="算法和数据结构" scheme="https://blog.farmer233.top/tags/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="leetcode" scheme="https://blog.farmer233.top/tags/leetcode/"/>
    
    <category term="刷题" scheme="https://blog.farmer233.top/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>[Leetcode]重塑矩阵&amp;杨辉三角</title>
    <link href="https://blog.farmer233.top/2021/07/19/Leetcode-%E9%87%8D%E5%A1%91%E7%9F%A9%E9%98%B5-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/"/>
    <id>https://blog.farmer233.top/2021/07/19/Leetcode-%E9%87%8D%E5%A1%91%E7%9F%A9%E9%98%B5-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/</id>
    <published>2021-07-19T11:49:09.000Z</published>
    <updated>2021-07-19T16:21:37.606Z</updated>
    
    <content type="html"><![CDATA[<p>Leetcode数据结构题目集第四天，<code>重塑矩阵</code>和<code>杨辉三角</code>.</p><h2 id="重塑矩阵"><a href="#重塑矩阵" class="headerlink" title="重塑矩阵"></a>重塑矩阵</h2><blockquote><p>在MATLAB中，有一个非常有用的函数 reshape，它可以将一个矩阵重塑为另一个大小不同的新矩阵，但保留其原始数据。<br>给出一个由二维数组表示的矩阵，以及两个正整数r和c，分别表示想要的重构的矩阵的行数和列数。<br>重构后的矩阵需要将原始矩阵的所有元素以相同的行遍历顺序填充。<br>如果具有给定参数的reshape操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。</p></blockquote><p>示例 1:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">nums = </span><br><span class="line">[[<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line"> [<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">r = <span class="number">1</span>, c = <span class="number">4</span></span><br><span class="line">输出: </span><br><span class="line">[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">解释:</span><br><span class="line">行遍历nums的结果是 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]。新的矩阵是 <span class="number">1</span> * <span class="number">4</span> 矩阵, 用之前的元素值一行一行填充新矩阵。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">nums = </span><br><span class="line">[[<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line"> [<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">r = <span class="number">2</span>, c = <span class="number">4</span></span><br><span class="line">输出: </span><br><span class="line">[[<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line"> [<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">解释:</span><br><span class="line">没有办法将 <span class="number">2</span> * <span class="number">2</span> 矩阵转化为 <span class="number">2</span> * <span class="number">4</span> 矩阵。 所以输出原矩阵。</span><br></pre></td></tr></table></figure><p>注意：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给定矩阵的宽和高范围在 [<span class="number">1</span>, <span class="number">100</span>]。</span><br><span class="line">给定的 r 和 c 都是正数。</span><br></pre></td></tr></table></figure><h3 id="解题思路-amp-题解"><a href="#解题思路-amp-题解" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>解题思路大体就是先转成一维矩阵，然后再转成目标矩阵。核心思想是下面的公式:</p><ol><li>(i, j) -&gt; i * n + j =&gt; x</li><li>i=x / n</li><li>j=x % n</li></ol><p>代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">matrixReshape</span><span class="params">(mat [][]<span class="keyword">int</span>, r <span class="keyword">int</span>, c <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">m, n := <span class="built_in">len</span>(mat), <span class="built_in">len</span>(mat[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">if</span> m*n != r*c &#123;</span><br><span class="line"><span class="keyword">return</span> mat</span><br><span class="line">&#125;</span><br><span class="line">res := <span class="built_in">make</span>([][]<span class="keyword">int</span>, r)</span><br><span class="line"><span class="keyword">for</span> r := <span class="keyword">range</span> res &#123;</span><br><span class="line">res[r] = <span class="built_in">make</span>([]<span class="keyword">int</span>, c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m*n; i++ &#123;</span><br><span class="line">res[i/c][i%c] = mat[i/n][i%n]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="杨辉三角"><a href="#杨辉三角" class="headerlink" title="杨辉三角"></a>杨辉三角</h2><blockquote><p>给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。<br>在杨辉三角中，每个数是它左上方和右上方的数的和。</p></blockquote><p>示例:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">5</span></span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">     [<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">   [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line"> [<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="解题思路-amp-题解-1"><a href="#解题思路-amp-题解-1" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>杨辉三角这算是一道经典题目了，大一就开始接触。这里主要用到这个特性-&gt;<code>每行长度等于当前列数 -&gt; 第一行只有一个，第二行有两个，第三行有三个。</code></p><p>代码如下: </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generate</span><span class="params">(numRows <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">res := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numRows; i++ &#123;</span><br><span class="line">temp := <span class="built_in">make</span>([]<span class="keyword">int</span>, i+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt;= i; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> j == <span class="number">0</span> || j == i &#123;</span><br><span class="line">temp[j] = <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">temp[j] = res[i<span class="number">-1</span>][j<span class="number">-1</span>] + res[i<span class="number">-1</span>][j]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">res = <span class="built_in">append</span>(res, temp)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Leetcode数据结构题目集第四天，&lt;code&gt;重塑矩阵&lt;/code&gt;和&lt;code&gt;杨辉三角&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&quot;重塑矩阵&quot;&gt;&lt;a href=&quot;#重塑矩阵&quot; class=&quot;headerlink&quot; title=&quot;重塑矩阵&quot;&gt;&lt;/a&gt;重塑矩阵&lt;/h2&gt;&lt;b</summary>
      
    
    
    
    <category term="学了些什么" scheme="https://blog.farmer233.top/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="Golang" scheme="https://blog.farmer233.top/tags/Golang/"/>
    
    <category term="笔记" scheme="https://blog.farmer233.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="算法和数据结构" scheme="https://blog.farmer233.top/tags/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="leetcode" scheme="https://blog.farmer233.top/tags/leetcode/"/>
    
    <category term="刷题" scheme="https://blog.farmer233.top/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>[Leetcode]两个数组的交集2&amp;买卖股票的最佳时机</title>
    <link href="https://blog.farmer233.top/2021/07/18/Leetcode-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%862-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"/>
    <id>https://blog.farmer233.top/2021/07/18/Leetcode-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%862-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</id>
    <published>2021-07-18T14:01:49.000Z</published>
    <updated>2021-07-19T11:49:57.480Z</updated>
    
    <content type="html"><![CDATA[<p>Leetcode数据结构题目集的第三天的题目。<br>这次分别是<code>两个数组的交集II</code>和<code>买卖股票的最佳时机</code>。</p><a id="more"></a><h2 id="两个数组的交集II"><a href="#两个数组的交集II" class="headerlink" title="两个数组的交集II"></a>两个数组的交集II</h2><blockquote><p>给定两个数组，编写一个函数来计算它们的交集。</p></blockquote><p>示例 1：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>], nums2 = [<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">4</span>,<span class="number">9</span>,<span class="number">5</span>], nums2 = [<span class="number">9</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">4</span>]</span><br><span class="line">输出：[<span class="number">4</span>,<span class="number">9</span>]</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。</li><li>我们可以不考虑输出结果的顺序。</li></ul><p><strong>进阶：</strong></p><ul><li>如果给定的数组已经排好序呢？你将如何优化你的算法？</li><li>如果 nums1 的大小比 nums2 小很多，哪种方法更优？<br>如果 nums2 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？</li></ul><h3 id="解题思路-amp-题解"><a href="#解题思路-amp-题解" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>题目要求两个数组的交集，但没有要求顺序。<br>故我们可以遍历长的那个数组，用哈希表来存放数据结构为<code>item-次数</code>的内容。<br>然后遍历短数组时，若元素在哈希表的key中则添加到结果，并将哈希表对应的内容次数减一。<br>代码如下:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intersect</span><span class="params">(nums1 []<span class="keyword">int</span>, nums2 []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">res := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">tmp := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 为了防止num1的长度比nums2小</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nums2) &gt; <span class="built_in">len</span>(nums1) &#123;</span><br><span class="line">nums1, nums2 = nums2, nums1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, num := <span class="keyword">range</span> nums1 &#123;</span><br><span class="line">tmp[num]++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, item := <span class="keyword">range</span> nums2 &#123;</span><br><span class="line"><span class="keyword">if</span> _, ok := tmp[item]; ok &amp;&amp; tmp[item] != <span class="number">0</span> &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, item)</span><br><span class="line">tmp[item]--</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h2><blockquote><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。<br>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。<br>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p></blockquote><p>示例 1：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：在第 <span class="number">2</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">5</span> 天（股票价格 = <span class="number">6</span>）的时候卖出，最大利润 = <span class="number">6</span><span class="number">-1</span> = <span class="number">5</span> 。</span><br><span class="line">     注意利润不能是 <span class="number">7</span><span class="number">-1</span> = <span class="number">6</span>, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [<span class="number">7</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：在这种情况下, 没有交易完成, 所以最大利润为 <span class="number">0</span>。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= prices.length &lt;= 105</code></li><li><code>0 &lt;= prices[i] &lt;= 104</code></li></ul><h3 id="解题思路-amp-题解-1"><a href="#解题思路-amp-题解-1" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>主要思路如下</p><ul><li>记录<strong>今天之前买入的最小值</strong></li><li>计算<strong>今天之前最小值，今天卖出的获利</strong> =&gt; 今天卖出能获利多少</li><li>遍历的时候比较<strong>每天的获利与最大值</strong><br>代码如下:<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">min := prices[<span class="number">0</span>]</span><br><span class="line">max := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, item := <span class="keyword">range</span> prices &#123;</span><br><span class="line"><span class="keyword">if</span> item &lt; min &#123;</span><br><span class="line">min = item</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> item-min &gt; max &#123;</span><br><span class="line">max = item - min</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Leetcode数据结构题目集的第三天的题目。&lt;br&gt;这次分别是&lt;code&gt;两个数组的交集II&lt;/code&gt;和&lt;code&gt;买卖股票的最佳时机&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="学了些什么" scheme="https://blog.farmer233.top/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="Golang" scheme="https://blog.farmer233.top/tags/Golang/"/>
    
    <category term="笔记" scheme="https://blog.farmer233.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="算法和数据结构" scheme="https://blog.farmer233.top/tags/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="leetcode" scheme="https://blog.farmer233.top/tags/leetcode/"/>
    
    <category term="刷题" scheme="https://blog.farmer233.top/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>[Leetcode]合并两个有序数组</title>
    <link href="https://blog.farmer233.top/2021/07/17/Leetcode-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <id>https://blog.farmer233.top/2021/07/17/Leetcode-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</id>
    <published>2021-07-17T13:58:31.000Z</published>
    <updated>2021-07-17T14:39:36.117Z</updated>
    
    <content type="html"><![CDATA[<p>Leetcode数据结构题目集的第二题🎉🎈<br>这次分别是“合并两个有序数组”和“两数之和”，由于两数之和之前已经做过了这里就不再赘述了。</p><a id="more"></a><h2 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a>合并两个有序数组</h2><blockquote><p>给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。<br>初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间大小等于 m + n，这样它就有足够的空间保存来自 nums2 的元素。</p></blockquote><p>示例 1：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3</span><br><span class="line">输出：[1,2,2,3,5,6]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1], m = 1, nums2 = [], n = 0</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><h2 id="解题思路-amp-题解"><a href="#解题思路-amp-题解" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h2><p>已知m, n为nums1, nums2的元素数量且nums1的空间大小等于 m + n，也就是说通过切片 我们能拿到nums1实际需要的元素内容。<br>由于nums1的空间大小足够我们合并，因此可以直接将nums2的内容直接添加到nums1数组的m - 1后面，然后再对合并后的数组进行排序则得到了题解。<br>代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(nums1 []<span class="keyword">int</span>, m <span class="keyword">int</span>, nums2 []<span class="keyword">int</span>, n <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    nums1 = <span class="built_in">append</span>(nums1[:m], nums2...)</span><br><span class="line">    sort.Ints(nums1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h2><p>官方的第一个解法其实就是我上面的解法，此外还有一个解法是我没有想出来的，看完后加上个人理解复现一下。</p><p>这里放一张leetcode官方的动图，直观的看到原理。</p><img src="/2021/07/17/Leetcode-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/1.gif" class="" title="doubelePoint"><p>原理：利用两个point变量来模拟指针，数组看成一个队列 当其中一个队列遍历完后退出循环。代码中有详细的注释辅助理解。<br>代码如下:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(nums1 []<span class="keyword">int</span>, m <span class="keyword">int</span>, nums2 []<span class="keyword">int</span>, n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 存放结果</span></span><br><span class="line">res := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, m+n)</span><br><span class="line"><span class="comment">// 两个数组的指针</span></span><br><span class="line">point1, point2 := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 数组一循环完, 将数组二剩余元素添加到结果里面</span></span><br><span class="line"><span class="keyword">if</span> point1 == m &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, nums2[point2:]...)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 与上面同理</span></span><br><span class="line"><span class="keyword">if</span> point2 == n &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, nums1[point1:]...)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 比较两个队列头的值，将小的放入结果数组中</span></span><br><span class="line"><span class="keyword">if</span> nums1[point1] &lt; nums2[point2] &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, nums1[point1])</span><br><span class="line">point1++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, nums2[point2])</span><br><span class="line">point2++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 不太清楚leetcode的判题程序，这里无法改变nums1的引用，因此使用copy复制。</span></span><br><span class="line">    <span class="comment">// nums1 = res</span></span><br><span class="line">    <span class="built_in">copy</span>(nums1, res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Leetcode数据结构题目集的第二题🎉🎈&lt;br&gt;这次分别是“合并两个有序数组”和“两数之和”，由于两数之和之前已经做过了这里就不再赘述了。&lt;/p&gt;</summary>
    
    
    
    <category term="学了些什么" scheme="https://blog.farmer233.top/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="Golang" scheme="https://blog.farmer233.top/tags/Golang/"/>
    
    <category term="笔记" scheme="https://blog.farmer233.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="算法和数据结构" scheme="https://blog.farmer233.top/tags/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="leetcode" scheme="https://blog.farmer233.top/tags/leetcode/"/>
    
    <category term="刷题" scheme="https://blog.farmer233.top/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>[Leetcode]存在重复元素&amp;最大子序和</title>
    <link href="https://blog.farmer233.top/2021/07/16/Leetcode-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
    <id>https://blog.farmer233.top/2021/07/16/Leetcode-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</id>
    <published>2021-07-16T09:41:16.000Z</published>
    <updated>2021-07-16T10:16:12.692Z</updated>
    
    <content type="html"><![CDATA[<p>这次刷的是leetcode的14天数据结构题目集，这是第一天的题目集✨🎉<br>最近在看王道的数据结构和《小灰漫画算法》，顺便练习一下Golang。</p><a id="more"></a><h2 id="存在重复元素"><a href="#存在重复元素" class="headerlink" title="存在重复元素"></a>存在重复元素</h2><blockquote><p>给定一个整数数组，判断是否存在重复元素。<br>如果存在一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。</p></blockquote><p>Example1:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p>Example2:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p>Example3:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,1,1,3,3,4,3,2,4,2]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><h3 id="解题思路-amp-题解"><a href="#解题思路-amp-题解" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>已知数组是一个整型数组，故我们可以对数组进行排序，然后遍历数组。<br>通过判断相邻两个元素是否相等，从而判断数组是否有重复元素。</p><p>题解如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">containsDuplicate</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    sort.Ints(nums)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] == nums[i<span class="number">-1</span>] &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h2><blockquote><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p></blockquote><p>Example1:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span><br></pre></td></tr></table></figure><p>Example2:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p>Example3:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p>Example4:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-1]</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><p>Example5:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-100000]</span><br><span class="line">输出：-100000</span><br></pre></td></tr></table></figure><h3 id="解题思路-amp-题解-1"><a href="#解题思路-amp-题解-1" class="headerlink" title="解题思路&amp;题解"></a>解题思路&amp;题解</h3><p>这道题可以说是浙大数据结构讲的 <strong>最大子列和</strong> 问题的变形，第一时间想到的是在线处理。<br>但这里需要注意<strong>输入的内容可以是负的</strong>，因此将原本的在线处理稍微变形。for循环的时候将已经遍历的元素累加起来，如果<strong>当前元素和累加结果相加大于当前元素</strong></span>（<code>nums[i - 1] + nums[i] &gt; nums[i]</code>）则证明改子列不会变小，然后再和最大值进行比较。</p><p>题解如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">max := nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line"><span class="keyword">if</span>(nums[i - <span class="number">1</span>] + nums[i] &gt; nums[i])&#123;</span><br><span class="line">            nums[i] += nums[i - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; max) &#123;</span><br><span class="line">            max = nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;这次刷的是leetcode的14天数据结构题目集，这是第一天的题目集✨🎉&lt;br&gt;最近在看王道的数据结构和《小灰漫画算法》，顺便练习一下Golang。&lt;/p&gt;</summary>
    
    
    
    <category term="学了些什么" scheme="https://blog.farmer233.top/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="Golang" scheme="https://blog.farmer233.top/tags/Golang/"/>
    
    <category term="笔记" scheme="https://blog.farmer233.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="算法和数据结构" scheme="https://blog.farmer233.top/tags/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="leetcode" scheme="https://blog.farmer233.top/tags/leetcode/"/>
    
    <category term="刷题" scheme="https://blog.farmer233.top/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>初探Typescript-使用http模块的简易爬虫</title>
    <link href="https://blog.farmer233.top/2021/03/12/%E5%88%9D%E6%8E%A2Typescript-%E4%BD%BF%E7%94%A8http%E6%A8%A1%E5%9D%97%E7%9A%84%E7%AE%80%E6%98%93%E7%88%AC%E8%99%AB/"/>
    <id>https://blog.farmer233.top/2021/03/12/%E5%88%9D%E6%8E%A2Typescript-%E4%BD%BF%E7%94%A8http%E6%A8%A1%E5%9D%97%E7%9A%84%E7%AE%80%E6%98%93%E7%88%AC%E8%99%AB/</id>
    <published>2021-03-12T11:45:30.000Z</published>
    <updated>2021-03-12T12:24:05.482Z</updated>
    
    <content type="html"><![CDATA[<p>这两天hxd找我写一道面试题，要求使用typescript<br>typescript是JavaScript的一个超集，它具有<strong>类型系统</strong>并且可以编译成普通的JavaScript代码。   </p><h2 id="1-从多个网页爬取内容，然后进行解析"><a href="#1-从多个网页爬取内容，然后进行解析" class="headerlink" title="1. 从多个网页爬取内容，然后进行解析"></a>1. 从多个网页爬取内容，然后进行解析</h2><p>有10个网页，1.txt 到 10.txt</p><p><a href="http://dy-public.oss-cn-shenzhen.aliyuncs.com/interviewTestData/1.txt" target="_blank" rel="noopener">http://dy-public.oss-cn-shenzhen.aliyuncs.com/interviewTestData/1.txt</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">abc</span>&gt;</span> <span class="tag">&lt;<span class="name">de</span></span></span><br><span class="line"><span class="tag"><span class="attr">f</span>&gt;</span>data : 1992; name : agent 1 <span class="tag">&lt;/<span class="name">def</span>&gt;</span><span class="tag">&lt;/<span class="name">abc</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="0"><li>格式有可能有区别</li><li>用 promise, async, await 分别实现并发、串行爬取</li><li>网页下载使用nodejs的http即可</li><li>使用正则表达式获取data后面的字段，将10个文件的data值全部获取，并相加</li></ol><h2 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h2><p>Node.js 有大量的网络请求模块，题目这里要求用node的http模块<br>http模块是node自带的，使用起来十分简单，代码如下:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">http.get(url, <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    res.setEncoding(<span class="string">'utf8'</span>)</span><br><span class="line">    res.on(<span class="string">'data'</span>, <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(data)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).on(<span class="string">'error'</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(e.message)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>http模块还可以指定options，但这里只需要下载网页，因此使用简单的get请求足以。  </p><h2 id="爬虫主体"><a href="#爬虫主体" class="headerlink" title="爬虫主体"></a>爬虫主体</h2><p>爬虫大致分为两部分-&gt; <strong>网络请求</strong>和 <strong>数据清理</strong>, 网络请求已经实现了，剩下就是把请求回来的数据进行清理了。这里也没啥多的选择，题目要求使用正则表达式，简单的构建整理一下就得到了下面的代码:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> http <span class="keyword">from</span> <span class="string">'http'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Spider &#123;</span><br><span class="line">    sum: <span class="built_in">Number</span></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.sum = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    httpGet(url) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            http.get(url, <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                res.setEncoding(<span class="string">'utf8'</span>)</span><br><span class="line">                res.on(<span class="string">'data'</span>, <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">                    resolve(data)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;).on(<span class="string">'error'</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">                reject(e.message)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    render(urls) &#123;</span><br><span class="line">        urls.reduce(<span class="function">(<span class="params">promise, url</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> promise.then(_ =&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.httpGet(url)</span><br><span class="line">            &#125;).then(<span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.flush(node)</span><br><span class="line">            &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.sum += res</span><br><span class="line">            &#125;)</span><br><span class="line">                .catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e))</span><br><span class="line">        &#125;, <span class="built_in">Promise</span>.resolve())</span><br><span class="line">    &#125;</span><br><span class="line">    flush(data) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> re = <span class="regexp">/:\s(\d+?);/gi</span></span><br><span class="line">            <span class="keyword">const</span> <span class="built_in">number</span> = <span class="built_in">Number</span>(re.exec(<span class="built_in">String</span>(data))[<span class="number">1</span>])</span><br><span class="line">            resolve(<span class="built_in">number</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> baseUrl = <span class="string">'http://dy-public.oss-cn-shenzhen.aliyuncs.com/interviewTestData/'</span></span><br><span class="line"><span class="keyword">let</span> urlList = []</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">1</span>; index &lt;= <span class="number">10</span>; index++) &#123;</span><br><span class="line">    urlList.push(<span class="string">`<span class="subst">$&#123;baseUrl&#125;</span><span class="subst">$&#123;index&#125;</span>.txt`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> spider = <span class="keyword">new</span> Spider()</span><br><span class="line">spider.render(urlList)</span><br><span class="line"><span class="comment">// 模拟等待微队列运行完成， 可以用await语法糖</span></span><br><span class="line"><span class="comment">// 这里只是写个大题的框架罢了，后面根据具体的要求改动</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(spider.sum)</span><br><span class="line">&#125;, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure><h2 id="The-End"><a href="#The-End" class="headerlink" title="The End"></a>The End</h2><p>到此为止，整个爬虫就写完了，总结一下体验。typescript是具有类型系统，这对于我这写多了python和JavaScript的人来说太好上手了！ </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这两天hxd找我写一道面试题，要求使用typescript&lt;br&gt;typescript是JavaScript的一个超集，它具有&lt;strong&gt;类型系统&lt;/strong&gt;并且可以编译成普通的JavaScript代码。   &lt;/p&gt;
&lt;h2 id=&quot;1-从多个网页爬取内容，然后</summary>
      
    
    
    
    <category term="学了些什么" scheme="https://blog.farmer233.top/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="笔记" scheme="https://blog.farmer233.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="前端" scheme="https://blog.farmer233.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="web" scheme="https://blog.farmer233.top/tags/web/"/>
    
    <category term="TypeScript" scheme="https://blog.farmer233.top/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>简单看看JavaScript中的Promise</title>
    <link href="https://blog.farmer233.top/2021/02/08/%E7%AE%80%E5%8D%95%E7%9C%8B%E7%9C%8BJavaScript%E4%B8%AD%E7%9A%84Promise/"/>
    <id>https://blog.farmer233.top/2021/02/08/%E7%AE%80%E5%8D%95%E7%9C%8B%E7%9C%8BJavaScript%E4%B8%AD%E7%9A%84Promise/</id>
    <published>2021-02-08T07:49:23.000Z</published>
    <updated>2021-02-08T09:02:22.007Z</updated>
    
    <content type="html"><![CDATA[<p>谈到JavaScript相信它的事件回调大家肯定都听过。即使只有一个执行线程，它也能处理异步高并发。<br>同样很多人回调写多了都不可避免的会变成<strong>Callback Hell(回调地狱)</strong>，这样的代码会非常复杂难懂，因为回调不像同步代码，它的执行顺序不是从上至下的，读回调代码必须反复横跳，思考什么情况下回跳到什么地方。<br>Promise就是一种异步编程，很早就有了随着ES6的发布Promise也成了JavaScript原生支持的对象,但学校这学期的课程并没有相关章节。因此顺便学习下Promise对象的使用。</p><p>以JavaScript原生的AJAX为栗子，AJAX的请求形式如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">url, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">    xhr.open(<span class="string">'GET'</span>, url)</span><br><span class="line">    xhr.send()</span><br><span class="line">    xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.status == <span class="number">200</span>) &#123;</span><br><span class="line">            callback(<span class="built_in">JSON</span>.parse(<span class="keyword">this</span>.response))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"加载失败"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们就以此方式依次请求三个接口(地址)，假设响应体的JSON格式是<code>{id: 1, name: &quot;farmer&quot;}</code>, JS代码如下:  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ajax(<span class="string">'http://127.0.0.1:5003/?name=farmer'</span>, (user) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 先拿到一个东西，再用这个东西去查别的，比如通过用户名查该用户的资料</span></span><br><span class="line">    ajax(<span class="string">'http://127.0.0.1:5003/?name='</span> + user.name, (e) =&gt; &#123;</span><br><span class="line">        ajax(<span class="string">'http://127.0.0.1:5003/?name='</span> + user.name, (e) =&gt; &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(e)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>是不是觉得嵌套很多？ 如果连续请求更多的地址，那嵌套就要看傻了。 接下来我们试试用Promise对象对ajax进行封装，看看效果怎么样。 代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">        xhr.open(<span class="string">'GET'</span>, url)</span><br><span class="line">        xhr.send()</span><br><span class="line">        xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.status == <span class="number">200</span>) &#123;</span><br><span class="line">                resolve(<span class="built_in">JSON</span>.parse(<span class="keyword">this</span>.response))</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                reject(<span class="string">"加载失败"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            reject(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中，我们自己封装的AJAX会返回一个“Promise”对象，初始化该对象时我们要传入一个函数，这个函数又接受两个回调函数作为参数，分别是<code>resolve</code>和<code>reject</code>。<code>resolve</code>就是你操作成功时调用的方法，<code>reject</code>就是失败时调用的。接下来让我们同样实现前面三个接口的功能:  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> url = <span class="string">"http://127.0.0.1:5003/"</span></span><br><span class="line">ajax(<span class="string">`<span class="subst">$&#123;url&#125;</span>?name=xiaotao`</span>).then(</span><br><span class="line">    value =&gt;&#123;</span><br><span class="line">        <span class="comment">// 这里可以通过第一个数据再发送请求</span></span><br><span class="line">        <span class="keyword">return</span> ajax(<span class="string">`<span class="subst">$&#123;url&#125;</span>?name=`</span> + value.name)</span><br><span class="line">    &#125;</span><br><span class="line">).then(<span class="function"><span class="params">value</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ajax(<span class="string">`<span class="subst">$&#123;url&#125;</span>?name=`</span> + value.name)</span><br><span class="line">&#125;).then(</span><br><span class="line">    value =&gt; <span class="built_in">console</span>.log(value),</span><br><span class="line">    reason =&gt; <span class="built_in">console</span>.log(reason)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>大家是不是发现，本来长长的嵌套，变成了顺序执行的代码了？ 到此就是Promise的简单探讨了。 如果你对上面的栗子还不太清楚，那下面是一些Promise对象更基础、详细的解释or栗子。希望能帮到你~😃</p><h2 id="Promise怎么用？"><a href="#Promise怎么用？" class="headerlink" title="Promise怎么用？"></a>Promise怎么用？</h2><p>相信刚接触Promise的童鞋都比较迷惑，到底应该怎么用Promise。其实上面有提到过，初始化该对象时我们要传入一个函数(我这里使用的是匿名函数)，这个函数又接受两个回调函数作为参数(这里读起来比较拗口，可以和下面的栗子结合起来看)，分别是<code>resolve</code>和<code>reject</code>。<code>resolve</code>就是你操作成功时调用的方法，<code>reject</code>就是失败时调用的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// resolved 成功</span></span><br><span class="line"><span class="comment">// rejected 拒绝</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 工作流程</span></span><br><span class="line">    resolve(<span class="string">"成功状态"</span>)</span><br><span class="line">    <span class="comment">// reject("失败状态")</span></span><br><span class="line">&#125;).then( <span class="comment">// then -&gt; 微任务列表</span></span><br><span class="line">    <span class="comment">// 工作后的处理</span></span><br><span class="line">    <span class="comment">// then方法有两个参数，第一个是成功的回调函数，第二个是失败的</span></span><br><span class="line">    value =&gt; &#123;</span><br><span class="line">        <span class="comment">// 成功</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"成功业务处理-1"</span>)</span><br><span class="line">    &#125;, </span><br><span class="line">    reason =&gt; &#123;</span><br><span class="line">        <span class="comment">// 失败</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'失败(拒绝)的业务处理-1'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">).then(</span><br><span class="line">    value =&gt; <span class="built_in">console</span>.log(<span class="string">"成功业务处理-2"</span>),</span><br><span class="line">    reason =&gt; <span class="built_in">console</span>.log(<span class="string">'失败(拒绝)的业务处理-2'</span>)</span><br><span class="line">    <span class="comment">// 上面一个Then可能不太清晰，这里和上面的逻辑是一样的。</span></span><br><span class="line">    <span class="comment">// then有两个参数，这两个参数是两个回调函数。</span></span><br><span class="line">    <span class="comment">// 一个是成功状态的回调函数，对应这里的value。 而这个成功状态则是上面的resolve</span></span><br><span class="line">    <span class="comment">// 一个是失败状态的回调函数，对应这里的reason。而这个失败状态则是上面的reject</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="Then的更多用法"><a href="#Then的更多用法" class="headerlink" title="Then的更多用法"></a>Then的更多用法</h2><p>我们从上面的栗子可以看到，then函数也有两个参数，也是一个成功一个失败。其实then也是一个Promise。<br>但从上面的栗子也可以发现，第二个then无论前一个then是哪个参数处理的，都只会出发成功状态。如果我们想让第二个then的失败处理也能生效，我们应该将代码改成下面这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'fulfilled'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = p1.then(</span><br><span class="line">    value =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(value)</span><br><span class="line">        <span class="comment">// 第一个Then return的内容, Then默认返回成功(resolve)</span></span><br><span class="line">        <span class="comment">// return 'Farmer'</span></span><br><span class="line">        <span class="comment">// 返回一个Promise</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// resolve("解决")</span></span><br><span class="line">            reject(<span class="string">"Then 解决失败"</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    reason =&gt; &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(reason)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">// resolve("解决")</span></span><br><span class="line">                    reject(<span class="string">"Then 解决失败"</span>)</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">).then(</span><br><span class="line">    value =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(value)</span><br><span class="line">    &#125;,</span><br><span class="line">    reason =&gt; <span class="built_in">console</span>.log(reason)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>当第一个then返回一个Promise对象后，第二个then就能根据前一个then返回的Promise的状态进行处理。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于Promise一些更深层次的理论这里就不探讨了，网上资料很多，大家可以去搜索下。本文中的示例代码可以在<a href="https://gitee.com/Farmer-chong/my-codes/tree/master/PromiseLearn" target="_blank" rel="noopener">这里下载</a>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;谈到JavaScript相信它的事件回调大家肯定都听过。即使只有一个执行线程，它也能处理异步高并发。&lt;br&gt;同样很多人回调写多了都不可避免的会变成&lt;strong&gt;Callback Hell(回调地狱)&lt;/strong&gt;，这样的代码会非常复杂难懂，因为回调不像同步代码，它的执</summary>
      
    
    
    
    <category term="学了些什么" scheme="https://blog.farmer233.top/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    
    
    <category term="笔记" scheme="https://blog.farmer233.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JavaScript" scheme="https://blog.farmer233.top/tags/JavaScript/"/>
    
    <category term="前端" scheme="https://blog.farmer233.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="web" scheme="https://blog.farmer233.top/tags/web/"/>
    
  </entry>
  
</feed>
