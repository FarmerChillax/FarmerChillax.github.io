<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>《OSTEP》学习笔记（十）常见并发问题 | Farmer</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement('script');
  hm.src = 'https://hm.baidu.com/hm.js?' + 'b9d3811fb8d19b04438737cb71b15c9e';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><div class="darkmode-toggle">🌓</div><script>var prefersDarkMode = window.matchMedia('(prefers-color-scheme: dark)');
var toggle = document.querySelector('.darkmode-toggle');
var html = document.querySelector('html');

html.dataset.dark = localStorage.dark || prefersDarkMode.matches;

toggle.addEventListener('click', () => {
localStorage.dark = !(html.dataset.dark == 'true');
html.dataset.dark = localStorage.dark;
});</script><meta name="generator" content="Hexo 6.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">《OSTEP》学习笔记（十）常见并发问题</h1><a id="logo" href="/.">Farmer</a><p class="description">-Farmer的自习室</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/readings/"><i class="fa fa-bookmark"> 阅读清单</i></a><a href="/now/"><i class="fa fa-calendar"> Now</i></a><a href="/history/"><i class="fa fa-book"> 历史</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">《OSTEP》学习笔记（十）常见并发问题</h1><div class="post-meta">2024-01-01<span> | </span><span class="category"><a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 1.7k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 6</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="post-content"><p>从下面的统计中我们可以看出，常见的并发问题可以分为：「非死锁的缺陷」与「死锁缺陷」</p>
<img src="/2024/01/01/%E3%80%8AOSTEP%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89%E5%B8%B8%E8%A7%81%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98/info.png" class="" title="info">

<span id="more"></span>


<h2 id="非死锁缺陷"><a href="#非死锁缺陷" class="headerlink" title="非死锁缺陷"></a>非死锁缺陷</h2><p>非死锁缺陷主要可以概括为以下几个：</p>
<ul>
<li>违反原子性</li>
</ul>
<p>「违反原子性」是指违反了多次内存访问中预期的<strong>可串行性</strong>，也就是说临界区代码没有被锁保护起来（即代码段本意是原子的，但在执行中并没有强制实现原子性）。如下面的代码，解决方法也就是加锁:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Thread <span class="number">1</span>::</span><br><span class="line">    <span class="comment">// 判断和赋值应该是原子性的</span></span><br><span class="line">    <span class="keyword">if</span> (thd-&gt;proc_info)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="built_in">fputs</span>(thd-&gt;proc_info, ...);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Thread <span class="number">2</span>::</span><br><span class="line">    thd-&gt;proc_info = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>违反顺序性</li>
</ul>
<p>两个内存访问的<strong>预期顺序</strong>被打破了（即 A 应该在 B 之前执行，但是实际运行中却不是这个顺序）比如下面的这段代码中，如果 mState &#x3D; mThread-&gt;State 语句先执行，则 mThread 为空。可以通过加<strong>条件变量</strong>(或信号量)解决：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Thread <span class="number">1</span>::</span><br><span class="line">    <span class="type">void</span> <span class="title function_">init</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        mThread = PR_CreateThread(mMain, ...);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Thread <span class="number">2</span>::</span><br><span class="line">    <span class="type">void</span> <span class="title function_">mMain</span><span class="params">(...)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        mState = mThread-&gt;State;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="死锁缺陷"><a href="#死锁缺陷" class="headerlink" title="死锁缺陷"></a>死锁缺陷</h2><p>除了上面的缺陷外，死锁（deadlock）死一种并发系统中经典的问题。比如下面的代码就可能会出现死锁：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Thread <span class="number">1</span>:</span><br><span class="line">lock(L1);</span><br><span class="line">lock(L2);</span><br><span class="line"></span><br><span class="line">Thread <span class="number">2</span>:</span><br><span class="line">lock(L2);</span><br><span class="line">lock(L1);</span><br></pre></td></tr></table></figure>

<h3 id="为什么发生死锁"><a href="#为什么发生死锁" class="headerlink" title="为什么发生死锁"></a>为什么发生死锁</h3><ul>
<li>复杂的依赖：以操作系统为例。虚拟内存系统依赖文件系统才能从磁盘读到内存页；<code>文件系统</code>依赖<code>虚拟内存系统</code>申请一页内存，以便存放读到的块。</li>
<li>封装：软件开发者一直倾向于隐藏实现细节，以模块化的方式让软件开发更容易。然而，模块化和锁不是很契合，以 Java 的 Vector 类和 AddAll()方法为例，我们这样调用这个方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vector v1, v2;</span><br><span class="line">v1.AddAll(v2);</span><br></pre></td></tr></table></figure>

<p>在内部，这个方法需要多线程安全，因此针对被添加向量（v1）和参数（v2）的锁都需要获取。假设这个方法，先给 v1 加锁，然后再给 v2 加锁。如果另外某个线程几乎同时在调用 v2.AddAll(v1)，就可能遇到死锁。</p>
<h3 id="产生死锁的条件"><a href="#产生死锁的条件" class="headerlink" title="产生死锁的条件"></a>产生死锁的条件</h3><ul>
<li>互斥：线程对于需要的资源进行互斥的访问（例如一个线程抢到锁）</li>
<li>持有并等待：线程持有了资源（例如已将持有的锁），同时又在等待其他资源（例如，需要获得的锁）</li>
<li>非抢占：线程获得的资源（例如锁），不能被抢占</li>
<li>循环等待：线程之间存在一个环路，环路上每个线程都额外持有一个资源，而这个资源又是下一个线程要申请的</li>
</ul>
<h3 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h3><ul>
<li>循环等待：这个方法是最实用和常用的方法，就是让代码不产生循环等待的情况。最直接的方法就是获取锁的时候提供一个<strong>全序</strong>（total ordering），通过严格的加锁顺序避免了循环等待。</li>
<li>持有并等待：这个方法通过原子地抢锁来避免死锁问题，也就是说在用一把大锁把几个锁保护起来，但这么做可能会影响性能。</li>
<li>非抢占：解决非抢占就是要让线程能占用其他线程没在用的锁，不能占着茅坑不拉屎。具体来说<code>trylock()</code> 函数会尝试获取锁，当锁被占有时则返回-1。</li>
<li>互斥：如果不存在锁那么便不存在死锁。通过强大的硬件指令，我们可以构造出<strong>不需要锁</strong>的数据结构，这个强大的硬件指令就是「比较并交换（compare-and-swap）」。</li>
</ul>
<p>下面是一个「比较并交换」的例子，在 <code>*address</code> 的值等于 <code>expected</code> 值时，将其赋值为 new：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">CompareAndSwap</span><span class="params">(<span class="type">int</span> *address, <span class="type">int</span> expected, <span class="type">int</span> new)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (*address == expected)</span><br><span class="line">    &#123;</span><br><span class="line">        *address = new;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// success</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// failure</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假定我们想原子地给某个值增加特定的数量:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">AtomicIncrement</span><span class="params">(<span class="type">int</span> *value, <span class="type">int</span> amount)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> old = *value;</span><br><span class="line">    &#125; <span class="keyword">while</span> (CompareAndSwap(value, old, old + amount) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 无同步操作</span></span><br><span class="line"><span class="comment">        int old = *value;</span></span><br><span class="line"><span class="comment">        *value = old + amount;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个更复杂的例子：<strong>链表插入</strong>。这是在链表头部插入元素的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">node_t</span> *n = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">node_t</span>));</span><br><span class="line">    assert(n != <span class="literal">NULL</span>);</span><br><span class="line">    n-&gt;value = value;</span><br><span class="line">    n-&gt;next = head;</span><br><span class="line">    head = n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<strong>加锁</strong>解决同步：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">node_t</span> *n = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">node_t</span>));</span><br><span class="line">    assert(n != <span class="literal">NULL</span>);</span><br><span class="line">    n-&gt;value = value;</span><br><span class="line">    lock(listlock); <span class="comment">// begin critical section</span></span><br><span class="line">    n-&gt;next = head;</span><br><span class="line">    head = n;</span><br><span class="line">    unlock(listlock); <span class="comment">// end of critical section</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用<strong>比较并交换指令</strong>（compare-and-swap)来实现插入操作:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">node_t</span> *n = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">node_t</span>));</span><br><span class="line">    assert(n != <span class="literal">NULL</span>);</span><br><span class="line">    n-&gt;value = value;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        n-&gt;next = head;</span><br><span class="line">    &#125; <span class="keyword">while</span> (CompareAndSwap(&amp;head, n-&gt;next, n) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码，首先把 next 指针指向当前的链表头（head），然后试着把新结点交换到链表头。但是，如果此时其他的线程成功地修改了 head 的值，这里的交换就会失败，导致这个线程根据新的 head 值重试。</p>
<h3 id="通过调度避免死锁"><a href="#通过调度避免死锁" class="headerlink" title="通过调度避免死锁"></a>通过调度避免死锁</h3><p>除了死锁预防外，有的场景死锁避免（avoidance）可能会更加合适，通过合理的调度避免产生死锁。比如下面的这个例子中，只要 T1 和 T2 (需要同一个锁的线程)不同时运行，就不会产生死锁。但这样就失去了并发性</p>
<img src="/2024/01/01/%E3%80%8AOSTEP%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89%E5%B8%B8%E8%A7%81%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98/sort.jpg" class="" title="sort">


<h3 id="检查和恢复"><a href="#检查和恢复" class="headerlink" title="检查和恢复"></a>检查和恢复</h3><p>最后一种常用的策略就是允许死锁偶尔发生，检查到死锁时再采取行动。</p>
<blockquote>
<p>提示：不要总是完美（TOM WEST 定律）</p>
</blockquote>
<p>Tom West 是经典的计算机行业小说《Soul of a New Machine》的主人公，有一句很棒的工程格言：“不是所有值得做的事情都值得做好”。<code>如果坏事很少发生，并且造成的影响很小，那么我们不应该去花费大量的精力去预防它</code>。当然，如果你在制造航天飞机，事故会导致航天飞机爆炸，那么你应该忽略这个建议。</p>
<p>很多数据库系统使用了<strong>死锁检测和恢复技术</strong>。死锁检测器会定期运行，通过构建资源图来检查循环。当循环（死锁）发生时，系统需要重启。如果还需要更复杂的数据结构相关的修复，那么需要人工参与。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本章中学习了并发编程中出现的缺陷的类型。同时也简要的讨论了死锁的发生和处理。死锁和并发编程可谓是想生相伴，在计算机发展的历史中，在一些通用库和系统中（比如Linux），都已经有了一些无等待的实现，但这仍然不够通用，并且设计一个新的无等待数据结构极为复杂，以至于不实用。也许，我们可以换个角度来看，一种新的无需任何锁的并发编程模型或许才是最好的解决方案。</p>
</div><div id="donate"><link rel="stylesheet" type="text/css" href="/css/donate.css?v=1.0.0"><script type="text/javascript" src="/js/donate.js?v=1.0.0" successtext="复制成功！"></script><a class="pos-f tr3" id="github" href="https://github.com/farmerChillax" target="_blank" title="Github"></a><div id="DonateText">Donate</div><ul class="list pos-f" id="donateBox"><li id="AliPay" qr="/img/AliPayQR.jpg"></li><li id="WeChat" qr="/img/WeChatQR.jpg"></li></ul><div class="pos-f left-100" id="QRBox"><div id="MainBox"></div></div></div><script type="text/javascript" src="/js/share.js?v=1.0.0" async></script><a class="article-share-link" data-url="https://blog.farmer233.top/2024/01/01/%E3%80%8AOSTEP%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89%E5%B8%B8%E8%A7%81%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98/" data-id="clqvrt54p0000yh320oyz3kw7" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAT4AAAE+CAAAAAAxUyPsAAAFPUlEQVR42u3bwW7cRhAEUP3/TydXA7GoqmquAyRvT4Z2Rc68EbDF7vbXV/z665fX87u/fub5t9or//Pn3/07uWb++Rde+PDhw4cP3+PmnyGSzSTbe2bKQZPfTd593u+3xPjw4cOHD9/Ed/mC35beHsPlju2hJvfFhw8fPnz4/gzfFg7y0PB8hfY4k7tf1o8PHz58+PD9meCSf9nf322LCO01/4Xchw8fPnz4/vd8LU0eQbZIlJcMtmiSN/hf63Xgw4cPHz588St5tP4v/fvlFz58+PDhwxd8Peev9srJNpJRtnz0rb1jtGt8+PDhw4dv2vWlQPBu03qLUPkRtmV6fPjw4cOH712+fAjs0upuF3q5Wh6YtgD0m787fPjw4cOHr+Rro0BCfCkHtEeYN+bbkscPd8SHDx8+fPhe4rsEjvbnyWa2wbjkUPNSAj58+PDhw3fn24bSLgX09jOXUv72+QQUHz58+PDh2/iSB+P7uFjbhH4+vG3N+fXzwgc+fPjw4cPX8uUB5b6ZNkO1hYC2+L41zn9zfXz48OHDhy/my5vcW7E+P4D8lUer9rfy4yymDPDhw4cPH75Hvm0sLC/Nt2X9S2M+OdTtDwIfPnz48OG78xVf2NPA2bsEbx1nHmi+LdPjw4cPHz58Jd8nBsJa6HZcbFtJe/cf7oIPHz58+PCVfNvI1xYykgLB1oy/7OUe3fDhw4cPH76cL3owDh65L2Nq+eP6RtCuNo9E+PDhw4cP38a3bbItKyThILlLEqQucao4Hnz48OHDh2/iy9vD+caeUdoyRFt6uP9BRCvEhw8fPnz4lhr711ZeTyCSaHKPES3oFnTw4cOHDx++O197+0ux+63Sw/0zr10THz58+PDhO/R572XxNmq0I3FtKT8ZdLvsCx8+fPjw4Wv5nr+FL5tMln7/ZMu67TeKd/jw4cOHD1/J15azt2LB5Vn7Hq3a9kMShvDhw4cPH76c7z74dRkvuze5t2hyaTZE83348OHDhw9fsNpLUXuj/ETfuf1JXhCpiwX48OHDhw/fz9/RdYF7G3RrQ0zybht62hCDDx8+fPjwvcuXj4Ilt9/Gv/L15LFji0R1gQMfPnz48OGb+PIAsQ2NJVtK7nI5hjzQ1PMF+PDhw4cPX8CXXKKNCBeydj2XtkFbrMeHDx8+fPgufFsDOA8WbQlgK9N/ImZFpRB8+PDhw4dvqaLXw2rb0ttG9fYAn9dIniHyGIQPHz58+PDlfG3JO4k4OdNWVrgMpd35vrZkhA8fPnz48L0UL95teLdt77bInrcBogPDhw8fPnz4Sr77JjfWNiS1JYyt5TDuBR8+fPjw4Yv30o5zXUJM/iierCE5hrYBUK8cHz58+PDhO/Bt42WXWPDWkWyRKH/32xXiw4cPHz58S1d6/A9Rl5BxaWZfmuiXobpvDwYfPnz48OEr+bYg0kaK/IF/21hbGsib4tGfAj58+PDhwxfw5QNe7SP6PV5sseMSUNpSAj58+PDhw7fxvdssbwe/tuL7NjD37nrw4cOHDx++O187vNWiX5rZbbxIjjw/kii44MOHDx8+fEvn+rWIswWFd0PPuwFrRMSHDx8+fPji+LK1sdvSfxtQtlmArcT/Ays+fPjw4cM38V3KAfni3kpS90L85Y4/zBrgw4cPHz58L/Hl0SEPN1sPOg8fl6J/UjTBhw8fPnz4Psd3aajnRYQkEuVbvawEHz58+PDh+xxf+2X/VoGgRUzufm+EF8eJDx8+fPjw7UmgLlVvbel2UCy/y6VNnpfy8eHDhw8fvonvb5CSMHf84OGoAAAAAElFTkSuQmCC">分享</a><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C%E8%AF%AD%E8%A8%80/" rel="tag">C语言</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Operating-Systems/" rel="tag">Operating Systems</a></li></ul></div><div class="post-nav"><a class="next" href="/2023/11/25/%E3%80%8AOSTEP%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89%E4%BF%A1%E5%8F%B7%E9%87%8F/">《OSTEP》学习笔记（九）信号量</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
  clientID: '0a5a339e4c6a3cc81b76',
  clientSecret: 'ce2b79ca94465b2a758faca9e0b95e4df38d6204',
  repo: 'FarmerChillax.github.io',
  owner: 'FarmerChillax',
  admin: ['FarmerChillax'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/">学了些什么</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%90%9E%E4%BA%8B%E6%83%85/">搞事情</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%83%A1%E6%80%9D%E4%B9%B1%E8%AF%AD/">胡思乱语</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Golang/" style="font-size: 15px;">Golang</a> <a href="/tags/%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD/" style="font-size: 15px;">胡言乱语</a> <a href="/tags/%E7%88%AC%E8%99%AB/" style="font-size: 15px;">爬虫</a> <a href="/tags/%E6%AD%A3%E6%96%B9%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F/" style="font-size: 15px;">正方教务系统</a> <a href="/tags/nginx/" style="font-size: 15px;">nginx</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/" style="font-size: 15px;">计算机网络基础</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/%E7%AC%94%E8%AE%B0/" style="font-size: 15px;">笔记</a> <a href="/tags/CTF/" style="font-size: 15px;">CTF</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 15px;">C语言</a> <a href="/tags/%E5%88%B7%E9%A2%98/" style="font-size: 15px;">刷题</a> <a href="/tags/PTA/" style="font-size: 15px;">PTA</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 15px;">前端</a> <a href="/tags/web/" style="font-size: 15px;">web</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 15px;">数据库</a> <a href="/tags/DDNS/" style="font-size: 15px;">DDNS</a> <a href="/tags/Operating-Systems/" style="font-size: 15px;">Operating Systems</a> <a href="/tags/%E7%94%9F%E6%B4%BB%E8%AE%B0%E5%BD%95/" style="font-size: 15px;">生活记录</a> <a href="/tags/%E5%90%90%E6%A7%BD/" style="font-size: 15px;">吐槽</a> <a href="/tags/%E9%BB%91%E6%9A%97%E6%96%99%E7%90%86/" style="font-size: 15px;">黑暗料理</a> <a href="/tags/TypeScript/" style="font-size: 15px;">TypeScript</a> <a href="/tags/vs-code/" style="font-size: 15px;">vs code</a> <a href="/tags/%E6%8F%92%E4%BB%B6/" style="font-size: 15px;">插件</a> <a href="/tags/Flask-APIFlask/" style="font-size: 15px;">Flask/APIFlask</a> <a href="/tags/emotion/" style="font-size: 15px;">emotion</a> <a href="/tags/Rust/" style="font-size: 15px;">Rust</a> <a href="/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/" style="font-size: 15px;">蓝桥杯</a> <a href="/tags/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 15px;">算法和数据结构</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2024/01/01/%E3%80%8AOSTEP%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89%E5%B8%B8%E8%A7%81%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98/">《OSTEP》学习笔记（十）常见并发问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/11/25/%E3%80%8AOSTEP%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89%E4%BF%A1%E5%8F%B7%E9%87%8F/">《OSTEP》学习笔记（九）信号量</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/11/24/%E3%80%8AOSTEP%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/">《OSTEP》学习笔记（八）条件变量</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/11/18/%E3%80%8AOSTEP%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%E5%9F%BA%E4%BA%8E%E9%94%81%E7%9A%84%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">《OSTEP》学习笔记（七）基于锁的并发数据结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/11/17/%E3%80%8AOSTEP%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%E9%94%81/">《OSTEP》学习笔记（六）锁</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/11/17/%E3%80%8AOSTEP%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%E6%8F%92%E5%8F%99%EF%BC%9A%E7%BA%BF%E7%A8%8B-API/">《OSTEP》学习笔记（五）插叙：线程-API</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/11/16/%E3%80%8AOSTEP%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%E5%B9%B6%E5%8F%91%EF%BC%9A%E4%BB%8B%E7%BB%8D/">《OSTEP》学习笔记（四）并发：介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/11/10/%E3%80%8AOSTEP%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E6%8F%92%E5%8F%99%EF%BC%9A%E8%BF%9B%E7%A8%8BAPI/">《OSTEP》学习笔记（三）插叙：进程API</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/11/05/%E3%80%8AOSTEP%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E6%8A%BD%E8%B1%A1%EF%BC%9A%E8%BF%9B%E7%A8%8B/">《OSTEP》学习笔记（二）抽象：进程</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/10/13/%E3%80%8AOSTEP%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D/">《OSTEP》学习笔记（一）操作系统介绍</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://blog.xiaotao233.top/" title="咸鱼的窝" target="_blank">咸鱼的窝</a><ul></ul><a href="https://blog.diyxi.top/" title="DIY，熙!" target="_blank">DIY，熙!</a><ul></ul><a href="https://darkroom.vip/" title="Dark的小黑屋" target="_blank">Dark的小黑屋</a><ul></ul><a href="https://blog.ziki2333.top/" title="ziki" target="_blank">ziki</a><ul></ul><a href="https://blog.feldan.top/" title="feldan" target="_blank">feldan</a><ul></ul><a href="https://blog.xiaohao233.top/" title="Twacの自习室" target="_blank">Twacの自习室</a><ul></ul><a href="https://greyli.com/" title="Grey Li" target="_blank">Grey Li</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2024 <a href="/." rel="nofollow">Farmer.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>