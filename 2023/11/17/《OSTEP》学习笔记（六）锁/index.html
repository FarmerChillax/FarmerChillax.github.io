<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>《OSTEP》学习笔记（六）锁 | Farmer</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement('script');
  hm.src = 'https://hm.baidu.com/hm.js?' + 'b9d3811fb8d19b04438737cb71b15c9e';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><div class="darkmode-toggle">🌓</div><script>var prefersDarkMode = window.matchMedia('(prefers-color-scheme: dark)');
var toggle = document.querySelector('.darkmode-toggle');
var html = document.querySelector('html');

html.dataset.dark = localStorage.dark || prefersDarkMode.matches;

toggle.addEventListener('click', () => {
localStorage.dark = !(html.dataset.dark == 'true');
html.dataset.dark = localStorage.dark;
});</script><meta name="generator" content="Hexo 6.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">《OSTEP》学习笔记（六）锁</h1><a id="logo" href="/.">Farmer</a><p class="description">-Farmer的自习室</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/readings/"><i class="fa fa-bookmark"> 阅读清单</i></a><a href="/now/"><i class="fa fa-calendar"> Now</i></a><a href="/history/"><i class="fa fa-book"> 历史</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">《OSTEP》学习笔记（六）锁</h1><div class="post-meta">2023-11-17<span> | </span><span class="category"><a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 2.6k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 10</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="toc-number">1.</span> <span class="toc-text">锁的基本思想</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Pthread-%E9%94%81"><span class="toc-number">1.1.</span> <span class="toc-text">Pthread 锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%84%E4%BB%B7%E9%94%81%E7%9A%84%E5%87%A0%E4%B8%AA%E6%8C%87%E6%A0%87"><span class="toc-number">2.</span> <span class="toc-text">评价锁的几个指标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E4%B8%AD%E6%96%AD"><span class="toc-number">3.</span> <span class="toc-text">控制中断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%8C%E7%A1%AC%E4%BB%B6%E6%94%AF%E6%8C%81%E3%80%8D%E6%B5%8B%E8%AF%95%E5%B9%B6%E8%AE%BE%E7%BD%AE%E6%8C%87%E4%BB%A4%EF%BC%88%E5%8E%9F%E5%AD%90%E4%BA%A4%E6%8D%A2%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">「硬件支持」测试并设置指令（原子交换）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8F%AF%E7%94%A8%E7%9A%84%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">5.</span> <span class="toc-text">实现可用的自旋锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%84%E4%BB%B7%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">5.1.</span> <span class="toc-text">评价自旋锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E6%94%AF%E6%8C%81%EF%BC%9A%E6%AF%94%E8%BE%83%E5%B9%B6%E4%BA%A4%E6%8D%A2%E6%8C%87%E4%BB%A4%EF%BC%88CAS%EF%BC%89"><span class="toc-number">6.</span> <span class="toc-text">硬件支持：比较并交换指令（CAS）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%9D%A1%E4%BB%B6%E5%BC%8F%E5%AD%98%E5%82%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">7.</span> <span class="toc-text">链接的加载和条件式存储指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E6%94%AF%E6%8C%81%EF%BC%9A%E8%8E%B7%E5%8F%96%E5%B9%B6%E5%A2%9E%E5%8A%A0"><span class="toc-number">8.</span> <span class="toc-text">硬件支持：获取并增加</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E8%BF%87%E5%A4%9A%EF%BC%9A%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="toc-number">9.</span> <span class="toc-text">自旋过多：怎么办</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AF%B9%E5%88%97%EF%BC%9A%E4%BC%91%E7%9C%A0%E6%9B%BF%E4%BB%A3%E8%87%AA%E6%97%8B"><span class="toc-number">10.</span> <span class="toc-text">使用对列：休眠替代自旋</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E9%94%81%EF%BC%88two-phase-lock%EF%BC%89"><span class="toc-number">11.</span> <span class="toc-text">两阶段锁（two-phase lock）</span></a></li></ol></div></div><div class="post-content"><p>并发编程要解决的最基本的问题：<strong>我们希望以原子方式执行一系列的指令</strong>，但由于中断的存在我们做不到这点。因此本章介绍了锁（lock）来解决这一问题。程序员在代码中加锁，放在临界区周围，保证临界区能够像单条原子指令一样执行。</p>
<span id="more"></span>

<h2 id="锁的基本思想"><a href="#锁的基本思想" class="headerlink" title="锁的基本思想"></a>锁的基本思想</h2><p>lock()和 unlock()函数的语义很简单。调用 <strong>lock()</strong> 尝试获取锁，如果没有其他线程持有锁（即它是<strong>可用</strong><code>的</code>），该线程会<strong>获得锁</strong>，进入<strong>临界区</strong>。当持有锁的线程在临界区时，其他线程就无法进入临界区。伪代码如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lock_t mutex;</span><br><span class="line">...</span><br><span class="line">lock(&amp;mutex);</span><br><span class="line">// 临界区代码(可能存在并发问题的代码）</span><br><span class="line">// 比如全局变量的操作: balance = balance + 1</span><br><span class="line">... </span><br><span class="line">unlock(&amp;mutex);</span><br></pre></td></tr></table></figure>

<h3 id="Pthread-锁"><a href="#Pthread-锁" class="headerlink" title="Pthread 锁"></a>Pthread 锁</h3><p>POSIX 库将锁称为互斥量（mutex）使用代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line">pthread_mutex_lock(&amp;lock); <span class="comment">// wrapper for pthread_mutex_lock()</span></span><br><span class="line">balance = balance + <span class="number">1</span>;</span><br><span class="line">pthread_mutex_unlock(&amp;lock);</span><br></pre></td></tr></table></figure>



<h2 id="评价锁的几个指标"><a href="#评价锁的几个指标" class="headerlink" title="评价锁的几个指标"></a>评价锁的几个指标</h2><ul>
<li>能否完成它的基本任务——互斥（mutual exclusion）</li>
<li>公平性（fairness）——当锁可用时，是否每个竞争的线程都有公平的机会抢到锁？</li>
<li>性能（performance）——锁竞争带来的时间开销，比如单 CPU 上竞争的开销的和多 CPU 上多个线程竞争时的开销，通过比较不同的场景，我们嗯更好的理解不同锁技术对性能的影响。</li>
</ul>
<h2 id="控制中断"><a href="#控制中断" class="headerlink" title="控制中断"></a>控制中断</h2><p>控制中断是最早提供的互斥解决方案之一，其本质就是在执行临界区代码的时候关闭中断。这个方案是为单处理器系统开发的，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    DisableInterrupts();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    EnableInterrupts();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的方案的优点是简单、清晰易懂。但缺点却很多：</p>
<ol>
<li>要<strong>允许所有调用线程执行特权操作</strong>（打开&#x2F;关闭中断），信任这种机制不会被滥用。但这是理想的情况，因为我们无法得知用户允许的程序是否可信任，因此该方案不适合作为通用方案。糟糕的情况比如有以下几个：<ol>
<li>一个贪婪的程序可以在开始时就关闭中断，从而独占处理器。</li>
<li>更糟糕的情况是被恶意程序利用，调用 lock 后一直死循环，系统无法重新获得控制权，只能重启系统。</li>
</ol>
</li>
<li><strong>不支持多处理器</strong>，如果多个线程允许在不同的 CPU 上，每个线程都试图进入同一个临界区，那么即便关中断也没用。当下多处理器已经很普遍了，因此需要方案更加通用。</li>
<li><strong>关中断导致中断丢失</strong>，这可能会导致严重的系统问题。比如磁盘完成了读取请求，正常应该会给个中断，但 CPU 因为关中断导致错失了这一中断，那么，操作系统如何知道去唤醒等待读取的进程？</li>
<li><strong>效率低</strong>，与正常的执行指令相比，现代 CPU 对于关闭&#x2F;打开中断的代码执行的比较慢。</li>
</ol>
<p>因此基于上述的情况，只在少数的情况下用开&#x2F;关中断来实现互斥原语，比如操作系统本身会采用屏蔽中断的方式，保证访问自己数据结构的原子性或者避免复杂的中断处理情况，因为在操作系统内部它总是可信的，不存在信任问题。</p>
<blockquote>
<p>「原语」是什么？个人简单的理解，原语是指<strong>操作系统层面</strong>提供的指令，一个原语中可能有很多个底层的指令，但操作系统帮我们确保了这些指令以原子的方式执行。</p>
</blockquote>
<h2 id="「硬件支持」测试并设置指令（原子交换）"><a href="#「硬件支持」测试并设置指令（原子交换）" class="headerlink" title="「硬件支持」测试并设置指令（原子交换）"></a>「硬件支持」测试并设置指令（原子交换）</h2><p>锁的实现需要硬件支持，最简单的<strong>硬件支持</strong>是<strong>测试并设置指令</strong>（test-and-set instruction，TAS），也叫作<strong>原子交换</strong>（atomic exchange）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_t</span> &#123;</span> <span class="type">int</span> flag; &#125; <span class="type">lock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">lock_t</span> *mutex)</span> &#123;</span><br><span class="line">    <span class="comment">// 0 -&gt; lock is available, 1 -&gt; held</span></span><br><span class="line">    mutex-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">lock_t</span> *mutex)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (mutex-&gt;flag == <span class="number">1</span>) <span class="comment">// TEST the flag</span></span><br><span class="line">        ; <span class="comment">// spin-wait (do nothing)</span></span><br><span class="line">    mutex-&gt;flag = <span class="number">1</span>; <span class="comment">// now SET it!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock</span><span class="params">(<span class="type">lock_t</span> *mutex)</span> &#123;</span><br><span class="line">    mutex-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，每次 lock 会判断 flag 的值，也就是<strong>测试并设置指令（test-and-set instruction）</strong>中的test，然后判断成功才 <strong>set</strong></p>
<p>但如果没有硬件辅助，也就是让<strong>测试并设置</strong>作为一个原子操作，会导致两个线程有可能<strong>同时进入</strong>临界区。</p>
<blockquote>
<p>注意自旋等待spin-wait会影响性能</p>
</blockquote>
<h2 id="实现可用的自旋锁"><a href="#实现可用的自旋锁" class="headerlink" title="实现可用的自旋锁"></a>实现可用的自旋锁</h2><p>自旋锁（spin lock）其实就是一直自旋（判断某个条件成立），直到锁可用。</p>
<p>在 SPARC 上，需要的指令叫 ldstub（load&#x2F;store unsigned byte，加载&#x2F;保存无符号字节）；在 x86 上，是 xchg（atomic exchange，原子交换）指令。但它们基本上在不同的平台上做同样的事，通常称为<strong>测试并设置指令</strong>（test-and-set）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">TestAndSet</span><span class="params">(<span class="type">int</span> *old_ptr, <span class="type">int</span> new)</span> &#123;</span><br><span class="line">    <span class="type">int</span> old = *old_ptr; <span class="comment">// fetch old value at old_ptr</span></span><br><span class="line">    *old_ptr = new; <span class="comment">// store &#x27;new&#x27; into old_ptr</span></span><br><span class="line">    <span class="keyword">return</span> old; <span class="comment">// return the old value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将<strong>测试并设置</strong>作为<strong>原子操作</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_t</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> flag;</span><br><span class="line">&#125; <span class="type">lock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">lock_t</span> *lock)</span> &#123;</span><br><span class="line">    <span class="comment">// 0 indicates that lock is available, 1 that it is ld</span></span><br><span class="line">    lock-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">lock_t</span> *lock)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (TestAndSet(&amp;lock-&gt;flag, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">        ; <span class="comment">// spin-wait (do nothing)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock</span><span class="params">(<span class="type">lock_t</span> *lock)</span> &#123;</span><br><span class="line">    lock-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="评价自旋锁"><a href="#评价自旋锁" class="headerlink" title="评价自旋锁"></a>评价自旋锁</h3><p>现在我们来用之前提到的标准来评价基本的自旋锁：</p>
<ul>
<li>锁最重要的一点是正确性（correctness），也就是能够互斥吗？答案是肯定的，因此自旋锁是一把正确的锁。</li>
<li>公平性（fairness）：显然自旋锁不提供任何的公平性保证，因此可能会导致饿死。</li>
<li>性能（performan）：单处理器上，性能开销相当大。因为在上锁后最少会自旋一个时间片，浪费 CPU 周期。在多处理器上，自旋锁性能不错。因为临界区一般很短，因此锁很快就可用了（自旋的时候），并没有浪费很多 CPU 周期，因此效果还不错。</li>
</ul>
<h2 id="硬件支持：比较并交换指令（CAS）"><a href="#硬件支持：比较并交换指令（CAS）" class="headerlink" title="硬件支持：比较并交换指令（CAS）"></a>硬件支持：比较并交换指令（CAS）</h2><p>某些系统提供了另一个硬件原语——比较交换指令（SPARC 中是 compare-and-swap，x86 中是 compare-and-exchange）。下面是伪代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">CompareAndSwap</span><span class="params">(<span class="type">int</span> *ptr, <span class="type">int</span> expected, <span class="type">int</span> new)</span> &#123;</span><br><span class="line">    <span class="type">int</span> actual = *ptr;</span><br><span class="line">    <span class="keyword">if</span> (actual == expected)</span><br><span class="line">        *ptr = new;</span><br><span class="line">    <span class="keyword">return</span> actual;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到和<strong>测试并设置指令</strong>的工作方式类似，但其实它十分强大，这在后面讨论「无等待同步（wait-free synchronization）时，会用到这条指令的强大之处。但如果只是用它实现一个简单的自旋锁，那么它无疑等价于上面分析的自旋锁。</p>
<h2 id="链接的加载和条件式存储指令"><a href="#链接的加载和条件式存储指令" class="headerlink" title="链接的加载和条件式存储指令"></a>链接的加载和条件式存储指令</h2><p>一些平台提供了实现临界区的一对指令：链接的加载（load-lionked）和条件式存储（store-conditional）可以用来配合使用，实现其他并发结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">LoadLinked</span><span class="params">(<span class="type">int</span> *ptr)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">StoreConditional</span><span class="params">(<span class="type">int</span> *ptr, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (no one has updated *ptr since the LoadLinked to this address) &#123;</span><br><span class="line">        *ptr = value;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// success!</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// failed to update</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>条件式存储</strong>（store-conditional）指令，只有上一次执行<strong>LoadLinked</strong>的地址在期间<strong>都没有更新</strong>时， 才会成功，同时更新了该地址的值</p>
<p>先通过 <strong>LoadLinked</strong> 尝试获取锁值，如果判断到锁被释放了，就执行<strong>StoreConditional</strong>判断在「执行完」<strong>LoadLinked</strong>到<strong>StoreConditional</strong>「执行前」ptr 有没有被<strong>更新</strong>，没有被更新则说明<strong>没有</strong>其他线程来抢，可以进临界区，有更新则说明已经被其他线程抢走了，继续重复本段落所述内容循环：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">lock_t</span> *lock)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (LoadLinked(&amp;lock-&gt;flag) == <span class="number">1</span>)</span><br><span class="line">            ; <span class="comment">// spin until it&#x27;s zero</span></span><br><span class="line">        <span class="keyword">if</span> (StoreConditional(&amp;lock-&gt;flag, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// if set-it-to-1 was a success: all done</span></span><br><span class="line">                <span class="comment">// otherwise: try it all over again</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock</span><span class="params">(<span class="type">lock_t</span> *lock)</span> &#123;</span><br><span class="line">    lock-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="硬件支持：获取并增加"><a href="#硬件支持：获取并增加" class="headerlink" title="硬件支持：获取并增加"></a>硬件支持：获取并增加</h2><p><strong>获取并增加</strong>（fetch-and-add）指令能<strong>原子地返回特定地址的旧值</strong>，并且让该值<strong>自增一</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">FetchAndAdd</span><span class="params">(<span class="type">int</span> *ptr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> old = *ptr;</span><br><span class="line">    *ptr = old + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_t</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> ticket;</span><br><span class="line">    <span class="type">int</span> turn;</span><br><span class="line">&#125; <span class="type">lock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock_init</span><span class="params">(<span class="type">lock_t</span> *lock)</span> &#123;</span><br><span class="line">    lock-&gt;ticket = <span class="number">0</span>;</span><br><span class="line">    lock-&gt;turn = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">lock_t</span> *lock)</span> &#123;</span><br><span class="line">    <span class="comment">// 开始挂号，获取当前号码。然后号码加1，保证每个人号码都不同</span></span><br><span class="line">    <span class="type">int</span> myturn = FetchAndAdd(&amp;lock-&gt;ticket);</span><br><span class="line">    <span class="comment">// 等待被叫号</span></span><br><span class="line">    <span class="keyword">while</span> (lock-&gt;turn != myturn)</span><br><span class="line">        ; <span class="comment">// spin</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock</span><span class="params">(<span class="type">lock_t</span> *lock)</span> &#123;</span><br><span class="line">    <span class="comment">// 只需要加1功能，不用返回旧值</span></span><br><span class="line">    FetchAndAdd(&amp;lock-&gt;turn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方案使用了两个变量来构建锁（ticket和turn），基本操作也很简单：每次进入 lock，就获取当前ticket<code>值</code>，相当于<strong>挂号</strong>，然后全局 ticket 本身会<strong>自增一</strong>，因此后续线程都会获得属于自己的唯一 ticket值，<strong>lock-&gt;turn</strong>表示当前<strong>叫号值</strong>，叫到号的运行。unlock 时递增lock-&gt;turn更新<strong>叫号值</strong>就行（也就是叫下一个号）。这种返回式保证了公平性，相当于每个线程排队运行（FIFO）。</p>
<h2 id="自旋过多：怎么办"><a href="#自旋过多：怎么办" class="headerlink" title="自旋过多：怎么办"></a>自旋过多：怎么办</h2><p>一个线程会一直自旋检查一个<strong>不会改变</strong>的值，浪费掉整个时间片！如果有 N 个线程去竞争一个锁，情况会更糟糕。同样的场景下，会浪费 <strong>N−1 个时间片</strong>，只是自旋并等待一个线程释放该锁。</p>
<p>如何让锁不会不必要地自旋，浪费 CPU 时间？要解决这个问题，只有硬件支持是不够的，我们还需要操作系统的支持！</p>
<h2 id="使用对列：休眠替代自旋"><a href="#使用对列：休眠替代自旋" class="headerlink" title="使用对列：休眠替代自旋"></a>使用对列：休眠替代自旋</h2><p>需要一个队列来保存等待锁的线程，上锁时发现锁已被持有，则入队并让调用线程休眠，解锁时从队列中取出一个线程唤醒。Solaris 中 <code>park()</code>能够让调用线程休眠，<code>unpark(threadID)</code>则会唤醒 threadID 标识的线程。</p>
<h2 id="两阶段锁（two-phase-lock）"><a href="#两阶段锁（two-phase-lock）" class="headerlink" title="两阶段锁（two-phase lock）"></a>两阶段锁（two-phase lock）</h2><p>两阶段锁中如果第一个自旋阶段没有获得锁，第二阶段调用者会睡眠，直到锁可用。Linux 中的 futex 就是这种锁，不过只自旋一次；更常见的方式是在循环中自旋固定的次数(希望这段时间内能获取到锁)，然后使用 futex 睡眠。</p>
</div><div id="donate"><link rel="stylesheet" type="text/css" href="/css/donate.css?v=1.0.0"><script type="text/javascript" src="/js/donate.js?v=1.0.0" successtext="复制成功！"></script><a class="pos-f tr3" id="github" href="https://github.com/farmerChillax" target="_blank" title="Github"></a><div id="DonateText">Donate</div><ul class="list pos-f" id="donateBox"><li id="AliPay" qr="/img/AliPayQR.jpg"></li><li id="WeChat" qr="/img/WeChatQR.jpg"></li></ul><div class="pos-f left-100" id="QRBox"><div id="MainBox"></div></div></div><script type="text/javascript" src="/js/share.js?v=1.0.0" async></script><a class="article-share-link" data-url="https://blog.farmer233.top/2023/11/17/%E3%80%8AOSTEP%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%E9%94%81/" data-id="clp2mek7e002rc0321qk16ogr" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASYAAAEmCAAAAADqr2IGAAAEjUlEQVR42u3ay27bMBAF0Pz/T6dAt4mce2fUwlSOV4XrktRRAc7r4yP+fP79XH3zefH5+rdfV/j6y6vdr355tW+7yw0fTJgwYcL0lkyfLz+vH7WFe73Oft/2lRcnxIQJEyZMhzO1yyW/nH2TX//5Df76tBE9JkyYMGH6BUz55d0+dkKQQLfrY8KECRMmTJuHyS/mWaF589owYcKECdNvY2qXe82xCQXylDh/he36mDBhwoTpSUyzFuAz/vwP55swYcKECdMbMH2Wn9mlPruYNylxG6z88NSYMGHChOlYpuTosyPm6Wh7I89OcsNemDBhwoTpcKZ2RKYtB2+wNoXd/UgQJkyYMGE6nWlzzc/KqTlZ/vBJUp0kwwUWJkyYMGF6e6a2jJtv096kbSk2abW2jUxMmDBhwvRsps2i+9LqPhHNgZIQ4WMWDWHChAkTpjdjyh+73aA94qzs277UvCR9uSYmTJgwYTqcKU+G7xqImQ3I5u3JvJ1Z9H4xYcKECdNRTJujz5Lb5IHbRmbeEJ21TjFhwoQJ07lMs9SxDReSgZtNA3UfxET/CTBhwoQJ01FMbZKZhw5t43PTpGxDirocjAkTJkyYDmfKG4T5Ndx+0+44Kx+3rVNMmDBhwvQMplkZt0XMh2zagZ626FyXlTFhwoQJ0+FM+dHza76F2KS4s/MUJ8SECRMmTI9maou/7RhNW1bOz79P3YuAABMmTJgwvTHT7CJvh2/uTX1nzddhUIIJEyZMmB7KlHyfFE/vTVNnu6wSaUyYMGHCdCxT3t5LUtDXCfAsYd4nw21yjgkTJkyYnsQ0Cwj2ozPtCvnlPaP/4ZVgwoQJE6bDmfaJa96wbIu8bZN1nypfFnkxYcKECdOBTHcVWPOrenO1zxqudSXg6veYMGHChOlwpv9ztd9Qkx5d53toTJgwYcJ0LtPswfaPl7+G5EW2ZeLkl5gwYcKE6RlMm7HUPO3MV5ulx20qW58QEyZMmDAdyJRfivvCa15KzkOEtgA9DF8wYcKECdMjmFqUzUFn+7YvoE3aL/fChAkTJkyPY9oP0+RjOknjMH9tsxV+wMKECRMmTI9gen30ZJvZN3cVcGepeBQcYMKECROmY5nqqzHYZpMY56XYvGQ8K/JiwoQJE6bnMbVHnI3stCl3knvmjc82yKgzdUyYMGHC9MZMs0ZjUqJtL/7Zv22LvHlYgAkTJkyYzmXK25Oz4+YNyDyt3Qwe5eNEmDBhwoTpeUz5sE6ecG7+1b1Jcr5CFI9gwoQJE6ZDmDZAmwZhm/TOUusWokjmMWHChAnTIUyz8u5dBdwccVbAnYU73/wtJkyYMGE6lqnN9WZXeBJM5I3StkC8acRiwoQJE6ZnMOVL5+Oem0v93hLtLAn/5ntMmDBhwnQ40+zC3iTDsyCjLTffFvRgwoQJE6ZfwJSEAgnN7FHzsZ59or4KCDBhwoQJ0+OYZkXbfNi0LfXm7cwi3MGECRMmTIcz5UXeWbI6G6xJXkMSQMwGdFbtTEyYMGHC9DZMswJou/RssKZNm9uhn3vLxJgwYcKE6c2Y/gAk9QW2D04pHAAAAABJRU5ErkJggg==">分享</a><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C%E8%AF%AD%E8%A8%80/" rel="tag">C语言</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Operating-Systems/" rel="tag">Operating Systems</a></li></ul></div><div class="post-nav"><a class="pre" href="/2023/11/18/%E3%80%8AOSTEP%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%E5%9F%BA%E4%BA%8E%E9%94%81%E7%9A%84%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">《OSTEP》学习笔记（七）基于锁的并发数据结构</a><a class="next" href="/2023/11/17/%E3%80%8AOSTEP%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%E6%8F%92%E5%8F%99%EF%BC%9A%E7%BA%BF%E7%A8%8B-API/">《OSTEP》学习笔记（五）插叙：线程-API</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
  clientID: '0a5a339e4c6a3cc81b76',
  clientSecret: 'ce2b79ca94465b2a758faca9e0b95e4df38d6204',
  repo: 'FarmerChillax.github.io',
  owner: 'FarmerChillax',
  admin: ['FarmerChillax'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/">学了些什么</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%90%9E%E4%BA%8B%E6%83%85/">搞事情</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%83%A1%E6%80%9D%E4%B9%B1%E8%AF%AD/">胡思乱语</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Golang/" style="font-size: 15px;">Golang</a> <a href="/tags/%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD/" style="font-size: 15px;">胡言乱语</a> <a href="/tags/%E7%88%AC%E8%99%AB/" style="font-size: 15px;">爬虫</a> <a href="/tags/%E6%AD%A3%E6%96%B9%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F/" style="font-size: 15px;">正方教务系统</a> <a href="/tags/nginx/" style="font-size: 15px;">nginx</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/" style="font-size: 15px;">计算机网络基础</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/%E7%AC%94%E8%AE%B0/" style="font-size: 15px;">笔记</a> <a href="/tags/CTF/" style="font-size: 15px;">CTF</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 15px;">C语言</a> <a href="/tags/%E5%88%B7%E9%A2%98/" style="font-size: 15px;">刷题</a> <a href="/tags/PTA/" style="font-size: 15px;">PTA</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 15px;">前端</a> <a href="/tags/web/" style="font-size: 15px;">web</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 15px;">数据库</a> <a href="/tags/DDNS/" style="font-size: 15px;">DDNS</a> <a href="/tags/Operating-Systems/" style="font-size: 15px;">Operating Systems</a> <a href="/tags/%E7%94%9F%E6%B4%BB%E8%AE%B0%E5%BD%95/" style="font-size: 15px;">生活记录</a> <a href="/tags/%E5%90%90%E6%A7%BD/" style="font-size: 15px;">吐槽</a> <a href="/tags/%E9%BB%91%E6%9A%97%E6%96%99%E7%90%86/" style="font-size: 15px;">黑暗料理</a> <a href="/tags/TypeScript/" style="font-size: 15px;">TypeScript</a> <a href="/tags/vs-code/" style="font-size: 15px;">vs code</a> <a href="/tags/%E6%8F%92%E4%BB%B6/" style="font-size: 15px;">插件</a> <a href="/tags/Flask-APIFlask/" style="font-size: 15px;">Flask/APIFlask</a> <a href="/tags/emotion/" style="font-size: 15px;">emotion</a> <a href="/tags/Rust/" style="font-size: 15px;">Rust</a> <a href="/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/" style="font-size: 15px;">蓝桥杯</a> <a href="/tags/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 15px;">算法和数据结构</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2024/01/01/%E3%80%8AOSTEP%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89%E5%B8%B8%E8%A7%81%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98/">《OSTEP》学习笔记（十）常见并发问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/11/25/%E3%80%8AOSTEP%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89%E4%BF%A1%E5%8F%B7%E9%87%8F/">《OSTEP》学习笔记（九）信号量</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/11/24/%E3%80%8AOSTEP%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/">《OSTEP》学习笔记（八）条件变量</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/11/18/%E3%80%8AOSTEP%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%E5%9F%BA%E4%BA%8E%E9%94%81%E7%9A%84%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">《OSTEP》学习笔记（七）基于锁的并发数据结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/11/17/%E3%80%8AOSTEP%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%E9%94%81/">《OSTEP》学习笔记（六）锁</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/11/17/%E3%80%8AOSTEP%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%E6%8F%92%E5%8F%99%EF%BC%9A%E7%BA%BF%E7%A8%8B-API/">《OSTEP》学习笔记（五）插叙：线程-API</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/11/16/%E3%80%8AOSTEP%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%E5%B9%B6%E5%8F%91%EF%BC%9A%E4%BB%8B%E7%BB%8D/">《OSTEP》学习笔记（四）并发：介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/11/10/%E3%80%8AOSTEP%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E6%8F%92%E5%8F%99%EF%BC%9A%E8%BF%9B%E7%A8%8BAPI/">《OSTEP》学习笔记（三）插叙：进程API</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/11/05/%E3%80%8AOSTEP%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E6%8A%BD%E8%B1%A1%EF%BC%9A%E8%BF%9B%E7%A8%8B/">《OSTEP》学习笔记（二）抽象：进程</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/10/13/%E3%80%8AOSTEP%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D/">《OSTEP》学习笔记（一）操作系统介绍</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://blog.xiaotao233.top/" title="咸鱼的窝" target="_blank">咸鱼的窝</a><ul></ul><a href="https://blog.diyxi.top/" title="DIY，熙!" target="_blank">DIY，熙!</a><ul></ul><a href="https://darkroom.vip/" title="Dark的小黑屋" target="_blank">Dark的小黑屋</a><ul></ul><a href="https://blog.ziki2333.top/" title="ziki" target="_blank">ziki</a><ul></ul><a href="https://blog.feldan.top/" title="feldan" target="_blank">feldan</a><ul></ul><a href="https://blog.xiaohao233.top/" title="Twacの自习室" target="_blank">Twacの自习室</a><ul></ul><a href="https://greyli.com/" title="Grey Li" target="_blank">Grey Li</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2024 <a href="/." rel="nofollow">Farmer.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>