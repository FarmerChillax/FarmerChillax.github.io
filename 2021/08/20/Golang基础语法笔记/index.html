<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>Golang基础语法笔记 | 数组、切片&amp;映射 | Farmer</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.1/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.1/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.1/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/2.0.4/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/2.1.4/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/2.1.4/toastr.min.css"><script data-ad-client="ca-pub-5878491461085149" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><meta name="generator" content="Hexo 4.2.1"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Golang基础语法笔记 | 数组、切片&amp;映射</h1><a id="logo" href="/.">Farmer</a><p class="description">-Farmer的自习室</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Golang基础语法笔记 | 数组、切片&amp;映射</h1><div class="post-meta">2021-08-20<span> | </span><span class="category"><a href="/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/">学了些什么</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#数组"><span class="toc-number">1.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#声明和初始化"><span class="toc-number">1.1.</span> <span class="toc-text">声明和初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用数组"><span class="toc-number">1.2.</span> <span class="toc-text">使用数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数间传递数组"><span class="toc-number">1.3.</span> <span class="toc-text">函数间传递数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#切片-Slice"><span class="toc-number">2.</span> <span class="toc-text">切片(Slice)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#内部实现"><span class="toc-number">2.1.</span> <span class="toc-text">内部实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#声明-amp-初始化-amp-使用"><span class="toc-number">2.2.</span> <span class="toc-text">声明&amp;初始化&amp;使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#切片增长"><span class="toc-number">2.3.</span> <span class="toc-text">切片增长</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#迭代切片"><span class="toc-number">2.4.</span> <span class="toc-text">迭代切片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数间传递"><span class="toc-number">2.5.</span> <span class="toc-text">函数间传递</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#映射-Map"><span class="toc-number">3.</span> <span class="toc-text">映射(Map)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#内部实现-1"><span class="toc-number">3.1.</span> <span class="toc-text">内部实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#声明-amp-初始化"><span class="toc-number">3.2.</span> <span class="toc-text">声明&amp;初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用Map"><span class="toc-number">3.3.</span> <span class="toc-text">使用Map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在函数间传递Map"><span class="toc-number">3.4.</span> <span class="toc-text">在函数间传递Map</span></a></li></ol></li></ol></div></div><div class="post-content"><p>Go入门和《Go语言实战》的笔记，本篇总结了基础的数组、切片和哈希表的内容。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是切片和映射的基础数据结构，因此了解数组的工作原理有助于理解切片和映射。<br>和C语言一样，在go中数组也是一段<strong>连续</strong>、<strong>长度固定</strong>用于存储<strong>同一类型</strong>元素的连续块。</p>
<h3 id="声明和初始化"><a href="#声明和初始化" class="headerlink" title="声明和初始化"></a>声明和初始化</h3><p>数组的声明和初始化，和其他类型差不多。声明的原则是：</p>
<ol>
<li>指明存储数据的类型。</li>
<li>存储元素的数量，也就是数组长度。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array [<span class="number">5</span>]<span class="keyword">int</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>声明变量时，总会使用对应类型的灵芝累对变量进行初始化，如上面的代码声明了一个数组<code>array</code>，但我们还没有对他进行初始化，此时这个数组内的值，就是对应类型的零值=&gt; 这里的对应类型时<code>int</code>，因此改数组目前为5个0 <code>[0,0,0,0,0]</code><br>由于数组初始化后长度是固定的，如果需要存储更多的元素则需要进行扩容。也就是需要再创建一个更长的数组，再把原来的数组复制到新数组里面。    </p>
<p>上面的数组仅仅只是<strong>声明</strong>，go还可以很方便的<strong>初始化并声明</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>
<p>上面的这段代码相当于下面:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array [<span class="number">5</span>]<span class="keyword">int</span></span><br><span class="line">array = [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>

<p>除此之外，go语言还能自动计算声明数组的长度，也就是根据内容，自动分配长度</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br></pre></td></tr></table></figure>

<p>有的时候我们已知数组的长度，但内容只知道个别几个，我们可以用下面这种方式:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>: <span class="number">10</span>, <span class="number">3</span>: <span class="number">30</span>&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们声明了一个长度为<code>5</code>的数组，并且初始化索引为<code>1</code>和<code>3</code>的元素</p>
<h3 id="使用数组"><a href="#使用数组" class="headerlink" title="使用数组"></a>使用数组</h3><p>数组使用上和别的语言没有太大的差异，主要就是通过下标访问。值得关心的是，Go语言的指针数组十分的好用<br><strong>将一个指针数组赋值给另一个</strong>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 [<span class="number">3</span>]*<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">arr2 := [<span class="number">3</span>]*<span class="keyword">string</span>&#123;<span class="built_in">new</span>(<span class="keyword">string</span>), <span class="built_in">new</span>(<span class="keyword">string</span>), <span class="built_in">new</span>(<span class="keyword">string</span>)&#125;</span><br><span class="line"></span><br><span class="line">*arr2[<span class="number">0</span>] = <span class="string">"Red"</span></span><br><span class="line">*arr2[<span class="number">1</span>] = <span class="string">"Blue"</span></span><br><span class="line">*arr2[<span class="number">2</span>] = <span class="string">"Green"</span></span><br><span class="line"><span class="comment">// 复制</span></span><br><span class="line">arr1 = arr2</span><br></pre></td></tr></table></figure>
<p>此时复制后的两个数组则指向同一组字符串了。</p>
<h3 id="函数间传递数组"><a href="#函数间传递数组" class="headerlink" title="函数间传递数组"></a>函数间传递数组</h3><p>在函数间传递变量时，总是以值的方式传递（也就是值传递）。因此在函数间传递数组是一个开销很大的操作–比如有个占用<code>8M</code>内存的数组，那么每次调用这个函数的时候go都会在栈上分配8MB的内存，试想一下同时调用100次这个函数，占用的内存会多么的惊人。<br>虽然Go自己会处理复制的这个操作，但还有一种更优雅的方法来处理这个操作，这个方法在C中十分的常见-&gt;<strong>传入指向数组的指针</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配一个8MB的数组</span></span><br><span class="line"><span class="keyword">var</span> arr [le6]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">foo(&amp;arr)</span><br><span class="line"></span><br><span class="line">fun foo(arr *[le6]<span class="keyword">int</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是传递数组的指针的例子，会发现数组被修改了。所以这种情况虽然节省了复制的内存，但是要谨慎使用，因为一不小心，就会修改原数组，导致不必要的问题。</p>
<blockquote>
<p>这里注意，数组的指针和指针数组是两个概念，数组的指针是<code>*[5]int</code>,指针数组是<code>[5]*int</code>，注意<code>*</code>的位置。</p>
</blockquote>
<p>针对函数间传递数组的问题，比如复制问题，比如大小僵化问题，都有更好的解决办法，这个就是切片，它更灵活。</p>
<h2 id="切片-Slice"><a href="#切片-Slice" class="headerlink" title="切片(Slice)"></a>切片(Slice)</h2><p>切片是一种数组结构，它是围绕动态数组的概念构建的（⚠<strong>和python的切片不完全相同</strong>）。切片可以按需自动增长和缩小，因为切片底层内存也是在连续的块中分配的，所以切片还有索引、迭代以及垃圾回收等好处</p>
<h3 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h3><p>切片的底层是数组，切片本身非常的小，它是对底层数组进行了抽象。切片有3个字段的数据结构，包含了Go需要操作数组的元数据。<br>这三个字段分别是<code>指向底层数组的指针</code>、<code>长度(切片能访问元素的个数)</code>和<code>切片总体的容量(真实容量)</code></p>
<blockquote>
<p>为了解决数组长度不可变，切片实际上就是提前声明了一个更长的数组(即切片的容量)，而切片的长度表示当前切片内能访问的元素的数量。</p>
</blockquote>
<p><strong>因此切片有这样一条公式：</strong><code>长度&lt;=容量</code></p>
<h3 id="声明-amp-初始化-amp-使用"><a href="#声明-amp-初始化-amp-使用" class="headerlink" title="声明&amp;初始化&amp;使用"></a>声明&amp;初始化&amp;使用</h3><p><strong>1. make和切片字面量</strong></p>
<p>使用<code>make</code>函数时，需要传入一个参数，指定切片的长度</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个长度和容量都是5的字符串切片</span></span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>前面说到，切片的长度和容量是两个不一样的概念，因此创建的时候也可以指定<code>长度</code>和<code>容量</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 长度为3，容量为5</span></span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>除了使用<code>make</code>函数，我们还可以使用切片<strong>字面量</strong>来声明切片–指定初始化的值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现切片和创建数组非常像，只不过不用指定<code>[]</code>中的值。  <strong>注意</strong>此时切片的长度和容量是相等的，并且会根据我们指定额字面量推到出来，当然我们也可以只初始化某个索引的值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">2</span>: <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 空切片和nil切片</strong><br>有的时候我们需要声明一个值为<code>nil</code>的切片(nil切片)。只要在声明式不做初始化就可以了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice []<span class="keyword">int</span></span><br></pre></td></tr></table></figure>
<p>空切片和nil切片不同的地方在于，空切片的底层数组包含0个元素，也就是说没有分配任何存储空间。<br>但切片里面的<strong>指向底层数组的指针</strong>是有内容的，而nil切片<strong>指向底层数组的指针</strong>则为nil</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p><strong>3. 使用切片</strong><br>go的切片用法上和python的类似，如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">newSlice := slice[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"><span class="comment">// newSlice -&gt; 2,3</span></span><br></pre></td></tr></table></figure>
<p>需要注意，第一个切片因为使用字面量的方式，因此它的长度和容量都为5。不过之后的<code>newSlice</code>就不一样了，对于<code>newSlice</code>来说其底层数组的容量只有4个元素，切片长度为2。根据下面的公式，可以计算任意切片的长度和容量:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对于底层数组容量为K的切片 slice[i:j] </span><br><span class="line">长度: j - i</span><br><span class="line">容量: k - i</span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于切片是在元切片的基础上的抽象，因此新的切片和旧切片实际上指向的是同一个数组，故修改同一个索引的内容时会导致原切片的内容发生改变</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">array := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">newSlice := array[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"><span class="comment">// array -&gt; 1,2,3,4,5</span></span><br><span class="line"><span class="comment">// newSlice -&gt; 2, 3</span></span><br><span class="line">newSlice[<span class="number">1</span>] = <span class="number">233</span></span><br><span class="line"><span class="comment">//  array -&gt; 1,2,233,4,5</span></span><br><span class="line"><span class="comment">//  newSlice -&gt; 2, 233</span></span><br></pre></td></tr></table></figure>

<p><strong>三个索引的切片</strong><br>创建切片时，第三个索引选项可以用来<strong>控制新切片的容量</strong>。⚠其目的并不是增加容量，而时限制容量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">source := []<span class="keyword">string</span>&#123;<span class="string">"Apple"</span>, <span class="string">"Orange"</span>, <span class="string">"Plum"</span>, <span class="string">"Banana"</span>, <span class="string">"Grape"</span>&#125;</span><br><span class="line"><span class="comment">// 数组: [2:3)  ; 容量: [2, 4)</span></span><br><span class="line"><span class="comment">// 因此长度: 1; 容量: 2</span></span><br><span class="line">slice := source[<span class="number">2</span>:<span class="number">3</span>:<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<p><strong>第三个选项也不可以超出索引范围!!!</strong></p>
<h3 id="切片增长"><a href="#切片增长" class="headerlink" title="切片增长"></a>切片增长</h3><p>按需增长可以说是切片的一个重要的特性。Go内置的<code>append</code>函数会处理增长长度时所有的操作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">newSlice := slice[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">newSlice = <span class="built_in">append</span>(newSlice, <span class="number">60</span>)</span><br></pre></td></tr></table></figure>

<p>因为<code>newSlice</code>在底层数组里还有额外的容量可用，append会将可用的元素合并到切片的长度，并对其进行赋值。由于和原始的<code>slice</code>共享同一个底层数组，slice中索引为3的元素的值也被改动了。<br>如果底层数组没有足够的可用容量，append会创建一个新的底层数组，将被引用的现有值复制到新数组里，再追加新的值。</p>
<blockquote>
<p>append会智能地处理底层数组地容量增长，当切片容量小于1000个元素时总会成倍地增加容量，超过1000后容量的增长因子设为1.25(增长算法不恒定)</p>
</blockquote>
<p>此外，通过<code>...</code>操作符，把一个切片追加到另一个切片里。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">newSlice := slice[<span class="number">1</span>:<span class="number">2</span>:<span class="number">3</span>]</span><br><span class="line">newSlice = <span class="built_in">append</span>(newSlice, slice...)</span><br></pre></td></tr></table></figure>


<h3 id="迭代切片"><a href="#迭代切片" class="headerlink" title="迭代切片"></a>迭代切片</h3><p>切片是一个集合，我们就可以迭代其中的元素。与python类似，Go有个特殊的关键字<code>range</code>，它可以配合<code>for</code>来迭代切片里的元素。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i,v:=<span class="keyword">range</span> slice&#123;</span><br><span class="line">	fmt.Printf(<span class="string">"index:%d, value:%d\n"</span>,i,v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中可以看到，迭代的时候会返回两个值: <code>index</code>和<code>value</code>，这里的<code>value</code>是一个副本。<br>需要强调的是，range创建了每个元素的<strong>副本</strong>，而不是直接返回该元素的引用。<br>很多时候，我们使用迭代都不需要索引<code>index</code>，此时可以使用占位符<code>_</code>来忽略这个值:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">for</span> _,v:=<span class="keyword">range</span> slice&#123;</span><br><span class="line">	fmt.Printf(<span class="string">"value:%d\n"</span>, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>range</code>总是从头开始迭代。如果需要更多的控制，依旧可以使用传统的for循环：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="keyword">for</span> index := <span class="number">2</span>; index &lt; <span class="built_in">len</span>(slice); index++&#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Index: %d Value: %d\n"</span>, index, slice[index])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output</span></span><br><span class="line">Index: <span class="number">2</span> Value: <span class="number">3</span></span><br><span class="line">Index: <span class="number">3</span> Value: <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>有两个特殊的内置函数<code>len</code>可以用于处理数组、切片和通道。对于切片来说，<code>len</code>返回切片的长度，<code>cap</code>返回切片的容量。</p>
<h3 id="函数间传递"><a href="#函数间传递" class="headerlink" title="函数间传递"></a>函数间传递</h3><p>在函数间传递切片的时候，就是要以值的方式传递切片，因为切片的尺寸很小，在函数间复制和传递切片成本也很低。（因为切片的数据结构只是一个指向数组的指针、长度和容量，不是把整个数组复制）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">int</span>, le6)</span><br><span class="line">slice = foo(slice)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(slice []<span class="keyword">int</span>)</span> []<span class="title">int</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> slice</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="映射-Map"><a href="#映射-Map" class="headerlink" title="映射(Map)"></a>映射(Map)</h2><p>正如标题所示，在《Go语言实战》中Map翻译成映射，相比于翻译相信Map更广为人知。<br>Map是一种数据结构(哈希表 or 散列表)，用来存储一系列的<strong>键值对</strong>，如果你学习过别的语言相信看到这你就明白Map是什么了。在<code>python</code>中这样的数据结构称为<code>dict(字典)</code>、<code>JavaScript</code>中称为<code>json(JavaScript Object Notation)</code></p>
<h3 id="内部实现-1"><a href="#内部实现-1" class="headerlink" title="内部实现"></a>内部实现</h3><p>Map是Go语言中哈希表的实现，因此我们每次迭代Map时打印的Key和Value时无序的，每次迭代都是不一样的。   </p>
<p>Map的散列表中包含一组桶，在存储、删除或查找键值对的时候，所有操作都要线选择一个桶，如何选择桶？就是先把要查找的<code>key</code>传给哈希函数，从而<strong>生成一个索引</strong>，进而找到对应的桶。</p>
<p>因此随着<em>映射</em>的增加，索引会分布的越来越均匀，因此访问键值对的速度就越快。（参考哈希表相关内容）由于本文主要是学习Go基础，因此不再继续深入，只要记住<strong>Map是无序的</strong></p>
<h3 id="声明-amp-初始化"><a href="#声明-amp-初始化" class="headerlink" title="声明&amp;初始化"></a>声明&amp;初始化</h3><p>Map的创建有如下几种方式：</p>
<ol>
<li><code>make</code>函数声明<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure></li>
<li><code>map</code>字面量<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不指定任何键值对-&gt;也就是一个空map</span></span><br><span class="line">dict := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="comment">// 赋予内容</span></span><br><span class="line">dict := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"张三"</span>:<span class="number">43</span>&#125;</span><br><span class="line"><span class="comment">// 多个内容</span></span><br><span class="line">dict := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"张三"</span>:<span class="number">43</span>,<span class="string">"李四"</span>:<span class="number">50</span>&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>Map的键可以是任何值，键的类型可以是内置的类型，也可以是结构类型，但是不管怎么样，这个键可以使用<code>==</code>运算符进行比较，所以像切片、函数以及含有切片的结构类型就不能用于Map的键了，因为他们具有引用的语义，不可比较。</p>
<blockquote>
<p>总结: 对于Map的值来说没有什么限制，但切片这种类型在键里不能用的，可以用在值里</p>
</blockquote>
<h3 id="使用Map"><a href="#使用Map" class="headerlink" title="使用Map"></a>使用Map</h3><p>Go语言的Map和别的语言都大同小异，使用非常简单和数组切片差不多   </p>
<p>如果键张三存在，则对其值修改，如果不存在，则新增这个键值对</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dict := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">dict[<span class="string">"张三"</span>] = <span class="number">43</span></span><br><span class="line">age := dict[<span class="string">"张三"</span>]</span><br></pre></td></tr></table></figure>

<p>很多时候我们都要判断Map中是否存在某个键值对.在Go Map中，如果我们获取一个不存在的键的值，也是可以的，返回的是<em>值类型</em>的零值，这样就会导致我们不知道是真的存在一个为零值的键值对呢，还是说这个键值对就不存在。对此，Map为我们提供了检测一个键值对是否存在的方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">age, exist := dict[<span class="string">"李四"</span>]</span><br><span class="line"><span class="keyword">if</span> exist &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看这个例子，和获取键的值没有太大区别，只是多了一个返回值。第一个返回值是键的值；第二个返回值标记这个键是否存在，这是一个boolean类型的变量，我们判断它就知道该键是否存在了。这也是Go多值返回的好处。</p>
<p>如果我们想删除一个键值对，可以使用内置的<code>delete</code>函数, <code>delete</code>函数接受两个参数，第一个是要操作的Map，第二个是要删除的Map的键。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(dict,<span class="string">"张三"</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>delete函数删除不存在的键也是可以的，只是没有任何作用。</p>
</blockquote>
<p>在Go中，我们可以使用<code>range</code>迭代Map，这和遍历切片是一样的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dict := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"张三"</span>: <span class="number">43</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> dict &#123;</span><br><span class="line">	fmt.Println(key, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>rang</code>返回两个值，这和python是类似的，第一个是键，第二个是值。</p>
<h3 id="在函数间传递Map"><a href="#在函数间传递Map" class="headerlink" title="在函数间传递Map"></a>在函数间传递Map</h3><p>函数间传递Map是不会制造副本的，也就是说如果一个Map传递给一个函数，该函数对这个Map做了修改，那么这个Map的所有引用都会被修改。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	dict := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"王五"</span>: <span class="number">60</span>, <span class="string">"张三"</span>: <span class="number">43</span>&#125;</span><br><span class="line">	modify(dict)</span><br><span class="line">	fmt.Println(dict[<span class="string">"张三"</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(dict <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	dict[<span class="string">"张三"</span>] = <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</div><div class="tags"><a href="/tags/%E7%AC%94%E8%AE%B0/"><i class="fa fa-tag"></i>笔记</a><a href="/tags/Golang/"><i class="fa fa-tag"></i>Golang</a></div><div class="post-nav"><a class="pre" href="/2021/09/03/%E6%96%B0%E7%89%88%E6%AD%A3%E6%96%B9%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%E7%99%BB%E5%BD%95%E5%AE%9E%E7%8E%B0/">新版正方教务系统登录实现</a><a class="next" href="/2021/08/07/%E6%8F%90%E9%97%AE%E4%B8%AD%E9%9C%80%E8%A6%81%E9%81%BF%E5%85%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%8C%E4%B8%BA/">提问中需要避免的一些行为</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88/">学了些什么</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%90%9E%E4%BA%8B%E6%83%85/">搞事情</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%83%A1%E6%80%9D%E4%B9%B1%E8%AF%AD/">胡思乱语</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/" style="font-size: 15px;">计算机网络基础</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/%E7%AC%94%E8%AE%B0/" style="font-size: 15px;">笔记</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 15px;">前端</a> <a href="/tags/web/" style="font-size: 15px;">web</a> <a href="/tags/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 15px;">算法和数据结构</a> <a href="/tags/leetcode/" style="font-size: 15px;">leetcode</a> <a href="/tags/Golang/" style="font-size: 15px;">Golang</a> <a href="/tags/%E5%88%B7%E9%A2%98/" style="font-size: 15px;">刷题</a> <a href="/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/" style="font-size: 15px;">位运算</a> <a href="/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/" style="font-size: 15px;">哈希表</a> <a href="/tags/Sliding-Window/" style="font-size: 15px;">Sliding Window</a> <a href="/tags/%E9%93%BE%E8%A1%A8/" style="font-size: 15px;">链表</a> <a href="/tags/PTA/" style="font-size: 15px;">PTA</a> <a href="/tags/nginx/" style="font-size: 15px;">nginx</a> <a href="/tags/DDNS/" style="font-size: 15px;">DDNS</a> <a href="/tags/%E7%88%AC%E8%99%AB/" style="font-size: 15px;">爬虫</a> <a href="/tags/%E7%94%9F%E6%B4%BB%E8%AE%B0%E5%BD%95/" style="font-size: 15px;">生活记录</a> <a href="/tags/%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD/" style="font-size: 15px;">胡言乱语</a> <a href="/tags/%E5%90%90%E6%A7%BD/" style="font-size: 15px;">吐槽</a> <a href="/tags/%E9%BB%91%E6%9A%97%E6%96%99%E7%90%86/" style="font-size: 15px;">黑暗料理</a> <a href="/tags/TypeScript/" style="font-size: 15px;">TypeScript</a> <a href="/tags/vs-code/" style="font-size: 15px;">vs code</a> <a href="/tags/%E6%8F%92%E4%BB%B6/" style="font-size: 15px;">插件</a> <a href="/tags/%E6%AD%A3%E6%96%B9%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F/" style="font-size: 15px;">正方教务系统</a> <a href="/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/" style="font-size: 15px;">蓝桥杯</a> <a href="/tags/CTF/" style="font-size: 15px;">CTF</a> <a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 15px;">C语言</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/11/07/%E5%A4%A7%E5%AD%A6-%E5%86%8D%E8%A7%81/">Review of life in university ✔</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/09/05/A-distributed-with-Go/">A distributed system with Go</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/09/03/%E6%96%B0%E7%89%88%E6%AD%A3%E6%96%B9%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%E7%99%BB%E5%BD%95%E5%AE%9E%E7%8E%B0/">新版正方教务系统登录实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/08/20/Golang%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0/">Golang基础语法笔记 | 数组、切片&映射</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/08/07/%E6%8F%90%E9%97%AE%E4%B8%AD%E9%9C%80%E8%A6%81%E9%81%BF%E5%85%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%8C%E4%B8%BA/">提问中需要避免的一些行为</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/08/02/Leetcode-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E7%9B%AE%E9%9B%86%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E5%A4%A9/">[Leetcode]数据结构题目集的最后一天</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/08/02/Leetcode-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2-%E6%8F%92%E5%85%A5/">[Leetcode]二叉搜索树中的搜索&插入</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/08/01/Leetcode-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/">[Leetcode]翻转二叉树&路径总和</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/08/01/Leetcode-%E7%AC%AC%E5%8D%81%E4%B8%80%E5%A4%A9-%E6%A0%91%E7%9A%84%E6%9B%B4%E5%A4%9A%E6%93%8D%E4%BD%9C/">[Leetcode]第十一天-树的更多操作</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/07/31/Leetcode-%E9%A2%98%E7%9B%AE%E9%9B%86%E7%AC%AC%E5%8D%81%E5%A4%A9-%E6%A0%91%E7%9A%84%E5%BC%80%E5%A7%8B/">[Leetcode]题目集第十天-树的开始</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://blog.xiaotao233.top/" title="咸鱼的窝" target="_blank">咸鱼的窝</a><ul></ul><a href="https://blog.diyxi.top/" title="DIY，熙!" target="_blank">DIY，熙!</a><ul></ul><a href="https://darkroom.vip/" title="Dark的小黑屋" target="_blank">Dark的小黑屋</a><ul></ul><a href="https://blog.ziki2333.top/" title="ziki" target="_blank">ziki</a><ul></ul><a href="https://blog.feldan.top/" title="feldan" target="_blank">feldan</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">Farmer.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>